// @ts-nocheck
import { GraphQLResolveInfo, SelectionSetNode, FieldNode, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import type { GetMeshOptions } from '@graphql-mesh/runtime';
import type { YamlConfig } from '@graphql-mesh/types';
import { PubSub } from '@graphql-mesh/utils';
import { DefaultLogger } from '@graphql-mesh/utils';
import MeshCache from "@graphql-mesh/cache-localforage";
import { fetch as fetchFn } from '@whatwg-node/fetch';

import { MeshResolvedSource } from '@graphql-mesh/runtime';
import { MeshTransform, MeshPlugin } from '@graphql-mesh/types';
import PostgraphileHandler from "@graphql-mesh/postgraphile"
import BareMerger from "@graphql-mesh/merger-bare";
import { createMeshHTTPHandler, MeshHTTPHandler } from '@graphql-mesh/http';
import { getMesh, ExecuteMeshFn, SubscribeMeshFn, MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';
import { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';
import { path as pathModule } from '@graphql-mesh/cross-helpers';
import { ImportFn } from '@graphql-mesh/types';
import type { MainDbTypes } from './sources/MainDB/types';
import * as importedModule$0 from "./sources/MainDB/pgCache.json";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };



/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigInt: any;
  Datetime: any;
  Cursor: any;
  Date: any;
  BigFloat: any;
  JSON: any;
  Time: any;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `Account`. */
  allAccounts?: Maybe<AccountsConnection>;
  /** Reads a set of `Account`. */
  allAccountsList?: Maybe<Array<Account>>;
  /** Reads and enables pagination through a set of `Agreement`. */
  allAgreements?: Maybe<AgreementsConnection>;
  /** Reads a set of `Agreement`. */
  allAgreementsList?: Maybe<Array<Agreement>>;
  /** Reads and enables pagination through a set of `Analytic`. */
  allAnalytics?: Maybe<AnalyticsConnection>;
  /** Reads a set of `Analytic`. */
  allAnalyticsList?: Maybe<Array<Analytic>>;
  /** Reads and enables pagination through a set of `Apitoken`. */
  allApitokens?: Maybe<ApitokensConnection>;
  /** Reads a set of `Apitoken`. */
  allApitokensList?: Maybe<Array<Apitoken>>;
  /** Reads and enables pagination through a set of `Article`. */
  allArticles?: Maybe<ArticlesConnection>;
  /** Reads a set of `Article`. */
  allArticlesList?: Maybe<Array<Article>>;
  /** Reads and enables pagination through a set of `Attribute`. */
  allAttributes?: Maybe<AttributesConnection>;
  /** Reads a set of `Attribute`. */
  allAttributesList?: Maybe<Array<Attribute>>;
  /** Reads and enables pagination through a set of `Brand`. */
  allBrands?: Maybe<BrandsConnection>;
  /** Reads a set of `Brand`. */
  allBrandsList?: Maybe<Array<Brand>>;
  /** Reads and enables pagination through a set of `CartPriceRule`. */
  allCartPriceRules?: Maybe<CartPriceRulesConnection>;
  /** Reads a set of `CartPriceRule`. */
  allCartPriceRulesList?: Maybe<Array<CartPriceRule>>;
  /** Reads and enables pagination through a set of `Case`. */
  allCases?: Maybe<CasesConnection>;
  /** Reads a set of `Case`. */
  allCasesList?: Maybe<Array<Case>>;
  /** Reads and enables pagination through a set of `CatalogPriceRule`. */
  allCatalogPriceRules?: Maybe<CatalogPriceRulesConnection>;
  /** Reads a set of `CatalogPriceRule`. */
  allCatalogPriceRulesList?: Maybe<Array<CatalogPriceRule>>;
  /** Reads and enables pagination through a set of `Category`. */
  allCategories?: Maybe<CategoriesConnection>;
  /** Reads a set of `Category`. */
  allCategoriesList?: Maybe<Array<Category>>;
  /** Reads and enables pagination through a set of `Channel`. */
  allChannels?: Maybe<ChannelsConnection>;
  /** Reads a set of `Channel`. */
  allChannelsList?: Maybe<Array<Channel>>;
  /** Reads and enables pagination through a set of `Checklist`. */
  allChecklists?: Maybe<ChecklistsConnection>;
  /** Reads a set of `Checklist`. */
  allChecklistsList?: Maybe<Array<Checklist>>;
  /** Reads and enables pagination through a set of `City`. */
  allCities?: Maybe<CitiesConnection>;
  /** Reads a set of `City`. */
  allCitiesList?: Maybe<Array<City>>;
  /** Reads and enables pagination through a set of `Collection`. */
  allCollections?: Maybe<CollectionsConnection>;
  /** Reads a set of `Collection`. */
  allCollectionsList?: Maybe<Array<Collection>>;
  /** Reads and enables pagination through a set of `Comment`. */
  allComments?: Maybe<CommentsConnection>;
  /** Reads a set of `Comment`. */
  allCommentsList?: Maybe<Array<Comment>>;
  /** Reads and enables pagination through a set of `ContentType`. */
  allContentTypes?: Maybe<ContentTypesConnection>;
  /** Reads a set of `ContentType`. */
  allContentTypesList?: Maybe<Array<ContentType>>;
  /** Reads and enables pagination through a set of `Contract`. */
  allContracts?: Maybe<ContractsConnection>;
  /** Reads a set of `Contract`. */
  allContractsList?: Maybe<Array<Contract>>;
  /** Reads and enables pagination through a set of `Country`. */
  allCountries?: Maybe<CountriesConnection>;
  /** Reads a set of `Country`. */
  allCountriesList?: Maybe<Array<Country>>;
  /** Reads and enables pagination through a set of `Coupon`. */
  allCoupons?: Maybe<CouponsConnection>;
  /** Reads a set of `Coupon`. */
  allCouponsList?: Maybe<Array<Coupon>>;
  /** Reads and enables pagination through a set of `CreditMemo`. */
  allCreditMemos?: Maybe<CreditMemosConnection>;
  /** Reads a set of `CreditMemo`. */
  allCreditMemosList?: Maybe<Array<CreditMemo>>;
  /** Reads and enables pagination through a set of `Currency`. */
  allCurrencies?: Maybe<CurrenciesConnection>;
  /** Reads a set of `Currency`. */
  allCurrenciesList?: Maybe<Array<Currency>>;
  /** Reads and enables pagination through a set of `CurrencyRate`. */
  allCurrencyRates?: Maybe<CurrencyRatesConnection>;
  /** Reads a set of `CurrencyRate`. */
  allCurrencyRatesList?: Maybe<Array<CurrencyRate>>;
  /** Reads and enables pagination through a set of `CurrencySymbol`. */
  allCurrencySymbols?: Maybe<CurrencySymbolsConnection>;
  /** Reads a set of `CurrencySymbol`. */
  allCurrencySymbolsList?: Maybe<Array<CurrencySymbol>>;
  /** Reads and enables pagination through a set of `CustomerGroup`. */
  allCustomerGroups?: Maybe<CustomerGroupsConnection>;
  /** Reads a set of `CustomerGroup`. */
  allCustomerGroupsList?: Maybe<Array<CustomerGroup>>;
  /** Reads and enables pagination through a set of `Customer`. */
  allCustomers?: Maybe<CustomersConnection>;
  /** Reads a set of `Customer`. */
  allCustomersList?: Maybe<Array<Customer>>;
  /** Reads and enables pagination through a set of `Customization`. */
  allCustomizations?: Maybe<CustomizationsConnection>;
  /** Reads a set of `Customization`. */
  allCustomizationsList?: Maybe<Array<Customization>>;
  /** Reads and enables pagination through a set of `Dashboard`. */
  allDashboards?: Maybe<DashboardsConnection>;
  /** Reads a set of `Dashboard`. */
  allDashboardsList?: Maybe<Array<Dashboard>>;
  /** Reads and enables pagination through a set of `Deepdive`. */
  allDeepdives?: Maybe<DeepdivesConnection>;
  /** Reads a set of `Deepdive`. */
  allDeepdivesList?: Maybe<Array<Deepdive>>;
  /** Reads and enables pagination through a set of `Digiboard`. */
  allDigiboards?: Maybe<DigiboardsConnection>;
  /** Reads a set of `Digiboard`. */
  allDigiboardsList?: Maybe<Array<Digiboard>>;
  /** Reads and enables pagination through a set of `Email`. */
  allEmails?: Maybe<EmailsConnection>;
  /** Reads a set of `Email`. */
  allEmailsList?: Maybe<Array<Email>>;
  /** Reads and enables pagination through a set of `Endofshift`. */
  allEndofshifts?: Maybe<EndofshiftsConnection>;
  /** Reads a set of `Endofshift`. */
  allEndofshiftsList?: Maybe<Array<Endofshift>>;
  /** Reads and enables pagination through a set of `Event`. */
  allEvents?: Maybe<EventsConnection>;
  /** Reads a set of `Event`. */
  allEventsList?: Maybe<Array<Event>>;
  /** Reads and enables pagination through a set of `Fullfillment`. */
  allFullfillments?: Maybe<FullfillmentsConnection>;
  /** Reads a set of `Fullfillment`. */
  allFullfillmentsList?: Maybe<Array<Fullfillment>>;
  /** Reads and enables pagination through a set of `GiftCertificate`. */
  allGiftCertificates?: Maybe<GiftCertificatesConnection>;
  /** Reads a set of `GiftCertificate`. */
  allGiftCertificatesList?: Maybe<Array<GiftCertificate>>;
  /** Reads and enables pagination through a set of `Glossary`. */
  allGlossaries?: Maybe<GlossariesConnection>;
  /** Reads a set of `Glossary`. */
  allGlossariesList?: Maybe<Array<Glossary>>;
  /** Reads and enables pagination through a set of `Importm`. */
  allImportms?: Maybe<ImportmsConnection>;
  /** Reads a set of `Importm`. */
  allImportmsList?: Maybe<Array<Importm>>;
  /** Reads and enables pagination through a set of `Integration`. */
  allIntegrations?: Maybe<IntegrationsConnection>;
  /** Reads a set of `Integration`. */
  allIntegrationsList?: Maybe<Array<Integration>>;
  /** Reads and enables pagination through a set of `Internalization`. */
  allInternalizations?: Maybe<InternalizationsConnection>;
  /** Reads a set of `Internalization`. */
  allInternalizationsList?: Maybe<Array<Internalization>>;
  /** Reads and enables pagination through a set of `Invitation`. */
  allInvitations?: Maybe<InvitationsConnection>;
  /** Reads a set of `Invitation`. */
  allInvitationsList?: Maybe<Array<Invitation>>;
  /** Reads and enables pagination through a set of `Invoice`. */
  allInvoices?: Maybe<InvoicesConnection>;
  /** Reads a set of `Invoice`. */
  allInvoicesList?: Maybe<Array<Invoice>>;
  /** Reads and enables pagination through a set of `Lead`. */
  allLeads?: Maybe<LeadsConnection>;
  /** Reads a set of `Lead`. */
  allLeadsList?: Maybe<Array<Lead>>;
  /** Reads and enables pagination through a set of `Manufacturer`. */
  allManufacturers?: Maybe<ManufacturersConnection>;
  /** Reads a set of `Manufacturer`. */
  allManufacturersList?: Maybe<Array<Manufacturer>>;
  /** Reads and enables pagination through a set of `Mediamanager`. */
  allMediamanagers?: Maybe<MediamanagersConnection>;
  /** Reads a set of `Mediamanager`. */
  allMediamanagersList?: Maybe<Array<Mediamanager>>;
  /** Reads and enables pagination through a set of `Meeting`. */
  allMeetings?: Maybe<MeetingsConnection>;
  /** Reads a set of `Meeting`. */
  allMeetingsList?: Maybe<Array<Meeting>>;
  /** Reads and enables pagination through a set of `Message`. */
  allMessages?: Maybe<MessagesConnection>;
  /** Reads a set of `Message`. */
  allMessagesList?: Maybe<Array<Message>>;
  /** Reads and enables pagination through a set of `Newsletter`. */
  allNewsletters?: Maybe<NewslettersConnection>;
  /** Reads a set of `Newsletter`. */
  allNewslettersList?: Maybe<Array<Newsletter>>;
  /** Reads and enables pagination through a set of `Ooto`. */
  allOotos?: Maybe<OotosConnection>;
  /** Reads a set of `Ooto`. */
  allOotosList?: Maybe<Array<Ooto>>;
  /** Reads and enables pagination through a set of `Opportunity`. */
  allOpportunities?: Maybe<OpportunitiesConnection>;
  /** Reads a set of `Opportunity`. */
  allOpportunitiesList?: Maybe<Array<Opportunity>>;
  /** Reads and enables pagination through a set of `Order`. */
  allOrders?: Maybe<OrdersConnection>;
  /** Reads a set of `Order`. */
  allOrdersList?: Maybe<Array<Order>>;
  /** Reads and enables pagination through a set of `Page`. */
  allPages?: Maybe<PagesConnection>;
  /** Reads a set of `Page`. */
  allPagesList?: Maybe<Array<Page>>;
  /** Reads and enables pagination through a set of `Partner`. */
  allPartners?: Maybe<PartnersConnection>;
  /** Reads a set of `Partner`. */
  allPartnersList?: Maybe<Array<Partner>>;
  /** Reads and enables pagination through a set of `Payment`. */
  allPayments?: Maybe<PaymentsConnection>;
  /** Reads a set of `Payment`. */
  allPaymentsList?: Maybe<Array<Payment>>;
  /** Reads and enables pagination through a set of `Permission`. */
  allPermissions?: Maybe<PermissionsConnection>;
  /** Reads a set of `Permission`. */
  allPermissionsList?: Maybe<Array<Permission>>;
  /** Reads and enables pagination through a set of `Plugin`. */
  allPlugins?: Maybe<PluginsConnection>;
  /** Reads a set of `Plugin`. */
  allPluginsList?: Maybe<Array<Plugin>>;
  /** Reads and enables pagination through a set of `Poll`. */
  allPolls?: Maybe<PollsConnection>;
  /** Reads a set of `Poll`. */
  allPollsList?: Maybe<Array<Poll>>;
  /** Reads and enables pagination through a set of `ProductType`. */
  allProductTypes?: Maybe<ProductTypesConnection>;
  /** Reads a set of `ProductType`. */
  allProductTypesList?: Maybe<Array<ProductType>>;
  /** Reads and enables pagination through a set of `Product`. */
  allProducts?: Maybe<ProductsConnection>;
  /** Reads a set of `Product`. */
  allProductsList?: Maybe<Array<Product>>;
  /** Reads and enables pagination through a set of `Project`. */
  allProjects?: Maybe<ProjectsConnection>;
  /** Reads a set of `Project`. */
  allProjectsList?: Maybe<Array<Project>>;
  /** Reads and enables pagination through a set of `Provider`. */
  allProviders?: Maybe<ProvidersConnection>;
  /** Reads a set of `Provider`. */
  allProvidersList?: Maybe<Array<Provider>>;
  /** Reads and enables pagination through a set of `Quote`. */
  allQuotes?: Maybe<QuotesConnection>;
  /** Reads a set of `Quote`. */
  allQuotesList?: Maybe<Array<Quote>>;
  /** Reads and enables pagination through a set of `Rating`. */
  allRatings?: Maybe<RatingsConnection>;
  /** Reads a set of `Rating`. */
  allRatingsList?: Maybe<Array<Rating>>;
  /** Reads and enables pagination through a set of `Report`. */
  allReports?: Maybe<ReportsConnection>;
  /** Reads a set of `Report`. */
  allReportsList?: Maybe<Array<Report>>;
  /** Reads and enables pagination through a set of `Return`. */
  allReturns?: Maybe<ReturnsConnection>;
  /** Reads a set of `Return`. */
  allReturnsList?: Maybe<Array<Return>>;
  /** Reads and enables pagination through a set of `Review`. */
  allReviews?: Maybe<ReviewsConnection>;
  /** Reads a set of `Review`. */
  allReviewsList?: Maybe<Array<Review>>;
  /** Reads and enables pagination through a set of `Reward`. */
  allRewards?: Maybe<RewardsConnection>;
  /** Reads a set of `Reward`. */
  allRewardsList?: Maybe<Array<Reward>>;
  /** Reads and enables pagination through a set of `Role`. */
  allRoles?: Maybe<RolesConnection>;
  /** Reads a set of `Role`. */
  allRolesList?: Maybe<Array<Role>>;
  /** Reads and enables pagination through a set of `Scheduler`. */
  allSchedulers?: Maybe<SchedulersConnection>;
  /** Reads a set of `Scheduler`. */
  allSchedulersList?: Maybe<Array<Scheduler>>;
  /** Reads and enables pagination through a set of `Segment`. */
  allSegments?: Maybe<SegmentsConnection>;
  /** Reads a set of `Segment`. */
  allSegmentsList?: Maybe<Array<Segment>>;
  /** Reads and enables pagination through a set of `Setting`. */
  allSettings?: Maybe<SettingsConnection>;
  /** Reads a set of `Setting`. */
  allSettingsList?: Maybe<Array<Setting>>;
  /** Reads and enables pagination through a set of `Shipment`. */
  allShipments?: Maybe<ShipmentsConnection>;
  /** Reads a set of `Shipment`. */
  allShipmentsList?: Maybe<Array<Shipment>>;
  /** Reads and enables pagination through a set of `SpecialDiscount`. */
  allSpecialDiscounts?: Maybe<SpecialDiscountsConnection>;
  /** Reads a set of `SpecialDiscount`. */
  allSpecialDiscountsList?: Maybe<Array<SpecialDiscount>>;
  /** Reads and enables pagination through a set of `State`. */
  allStates?: Maybe<StatesConnection>;
  /** Reads a set of `State`. */
  allStatesList?: Maybe<Array<State>>;
  /** Reads and enables pagination through a set of `Statistic`. */
  allStatistics?: Maybe<StatisticsConnection>;
  /** Reads a set of `Statistic`. */
  allStatisticsList?: Maybe<Array<Statistic>>;
  /** Reads and enables pagination through a set of `Stock`. */
  allStocks?: Maybe<StocksConnection>;
  /** Reads a set of `Stock`. */
  allStocksList?: Maybe<Array<Stock>>;
  /** Reads and enables pagination through a set of `Survey`. */
  allSurveys?: Maybe<SurveysConnection>;
  /** Reads a set of `Survey`. */
  allSurveysList?: Maybe<Array<Survey>>;
  /** Reads and enables pagination through a set of `Tag`. */
  allTags?: Maybe<TagsConnection>;
  /** Reads a set of `Tag`. */
  allTagsList?: Maybe<Array<Tag>>;
  /** Reads and enables pagination through a set of `Target`. */
  allTargets?: Maybe<TargetsConnection>;
  /** Reads a set of `Target`. */
  allTargetsList?: Maybe<Array<Target>>;
  /** Reads and enables pagination through a set of `TaxCategory`. */
  allTaxCategories?: Maybe<TaxCategoriesConnection>;
  /** Reads a set of `TaxCategory`. */
  allTaxCategoriesList?: Maybe<Array<TaxCategory>>;
  /** Reads and enables pagination through a set of `TaxRate`. */
  allTaxRates?: Maybe<TaxRatesConnection>;
  /** Reads a set of `TaxRate`. */
  allTaxRatesList?: Maybe<Array<TaxRate>>;
  /** Reads and enables pagination through a set of `TaxRule`. */
  allTaxRules?: Maybe<TaxRulesConnection>;
  /** Reads a set of `TaxRule`. */
  allTaxRulesList?: Maybe<Array<TaxRule>>;
  /** Reads and enables pagination through a set of `Template`. */
  allTemplates?: Maybe<TemplatesConnection>;
  /** Reads a set of `Template`. */
  allTemplatesList?: Maybe<Array<Template>>;
  /** Reads and enables pagination through a set of `Theme`. */
  allThemes?: Maybe<ThemesConnection>;
  /** Reads a set of `Theme`. */
  allThemesList?: Maybe<Array<Theme>>;
  /** Reads and enables pagination through a set of `Ticketing`. */
  allTicketings?: Maybe<TicketingsConnection>;
  /** Reads a set of `Ticketing`. */
  allTicketingsList?: Maybe<Array<Ticketing>>;
  /** Reads and enables pagination through a set of `Training`. */
  allTrainings?: Maybe<TrainingsConnection>;
  /** Reads a set of `Training`. */
  allTrainingsList?: Maybe<Array<Training>>;
  /** Reads and enables pagination through a set of `Transaction`. */
  allTransactions?: Maybe<TransactionsConnection>;
  /** Reads a set of `Transaction`. */
  allTransactionsList?: Maybe<Array<Transaction>>;
  /** Reads and enables pagination through a set of `UploadFile`. */
  allUploadFiles?: Maybe<UploadFilesConnection>;
  /** Reads a set of `UploadFile`. */
  allUploadFilesList?: Maybe<Array<UploadFile>>;
  /** Reads and enables pagination through a set of `User`. */
  allUsers?: Maybe<UsersConnection>;
  /** Reads a set of `User`. */
  allUsersList?: Maybe<Array<User>>;
  /** Reads and enables pagination through a set of `Vendor`. */
  allVendors?: Maybe<VendorsConnection>;
  /** Reads a set of `Vendor`. */
  allVendorsList?: Maybe<Array<Vendor>>;
  /** Reads and enables pagination through a set of `Visit`. */
  allVisits?: Maybe<VisitsConnection>;
  /** Reads a set of `Visit`. */
  allVisitsList?: Maybe<Array<Visit>>;
  /** Reads and enables pagination through a set of `Warehouse`. */
  allWarehouses?: Maybe<WarehousesConnection>;
  /** Reads a set of `Warehouse`. */
  allWarehousesList?: Maybe<Array<Warehouse>>;
  /** Reads and enables pagination through a set of `Webhook`. */
  allWebhooks?: Maybe<WebhooksConnection>;
  /** Reads a set of `Webhook`. */
  allWebhooksList?: Maybe<Array<Webhook>>;
  /** Reads and enables pagination through a set of `Website`. */
  allWebsites?: Maybe<WebsitesConnection>;
  /** Reads a set of `Website`. */
  allWebsitesList?: Maybe<Array<Website>>;
  /** Reads and enables pagination through a set of `Wishlist`. */
  allWishlists?: Maybe<WishlistsConnection>;
  /** Reads a set of `Wishlist`. */
  allWishlistsList?: Maybe<Array<Wishlist>>;
  /** Reads and enables pagination through a set of `Workspace`. */
  allWorkspaces?: Maybe<WorkspacesConnection>;
  /** Reads a set of `Workspace`. */
  allWorkspacesList?: Maybe<Array<Workspace>>;
  /** Reads and enables pagination through a set of `Zone`. */
  allZones?: Maybe<ZonesConnection>;
  /** Reads a set of `Zone`. */
  allZonesList?: Maybe<Array<Zone>>;
  accountById?: Maybe<Account>;
  agreementById?: Maybe<Agreement>;
  analyticById?: Maybe<Analytic>;
  apitokenById?: Maybe<Apitoken>;
  articleById?: Maybe<Article>;
  attributeById?: Maybe<Attribute>;
  brandById?: Maybe<Brand>;
  cartPriceRuleById?: Maybe<CartPriceRule>;
  caseById?: Maybe<Case>;
  catalogPriceRuleById?: Maybe<CatalogPriceRule>;
  categoryById?: Maybe<Category>;
  channelById?: Maybe<Channel>;
  checklistById?: Maybe<Checklist>;
  cityById?: Maybe<City>;
  collectionById?: Maybe<Collection>;
  commentById?: Maybe<Comment>;
  contentTypeById?: Maybe<ContentType>;
  contractById?: Maybe<Contract>;
  countryById?: Maybe<Country>;
  couponById?: Maybe<Coupon>;
  creditMemoByCreditMemoAndId?: Maybe<CreditMemo>;
  currencyById?: Maybe<Currency>;
  currencyRateByImportService?: Maybe<CurrencyRate>;
  currencySymbolBySymbol?: Maybe<CurrencySymbol>;
  customerGroupById?: Maybe<CustomerGroup>;
  customerById?: Maybe<Customer>;
  customizationById?: Maybe<Customization>;
  dashboardById?: Maybe<Dashboard>;
  deepdiveById?: Maybe<Deepdive>;
  digiboardById?: Maybe<Digiboard>;
  emailById?: Maybe<Email>;
  endofshiftById?: Maybe<Endofshift>;
  eventById?: Maybe<Event>;
  fullfillmentById?: Maybe<Fullfillment>;
  giftCertificateById?: Maybe<GiftCertificate>;
  glossaryById?: Maybe<Glossary>;
  importmById?: Maybe<Importm>;
  integrationById?: Maybe<Integration>;
  internalizationById?: Maybe<Internalization>;
  invitationById?: Maybe<Invitation>;
  invoiceById?: Maybe<Invoice>;
  leadById?: Maybe<Lead>;
  manufacturerById?: Maybe<Manufacturer>;
  mediamanagerById?: Maybe<Mediamanager>;
  meetingById?: Maybe<Meeting>;
  messageById?: Maybe<Message>;
  newsletterById?: Maybe<Newsletter>;
  ootoById?: Maybe<Ooto>;
  opportunityById?: Maybe<Opportunity>;
  orderById?: Maybe<Order>;
  pageById?: Maybe<Page>;
  partnerById?: Maybe<Partner>;
  paymentById?: Maybe<Payment>;
  permissionById?: Maybe<Permission>;
  pluginById?: Maybe<Plugin>;
  pollById?: Maybe<Poll>;
  productTypeById?: Maybe<ProductType>;
  productById?: Maybe<Product>;
  projectById?: Maybe<Project>;
  providerById?: Maybe<Provider>;
  quoteById?: Maybe<Quote>;
  ratingById?: Maybe<Rating>;
  reportById?: Maybe<Report>;
  returnById?: Maybe<Return>;
  reviewById?: Maybe<Review>;
  rewardById?: Maybe<Reward>;
  roleById?: Maybe<Role>;
  schedulerById?: Maybe<Scheduler>;
  segmentById?: Maybe<Segment>;
  settingById?: Maybe<Setting>;
  shipmentById?: Maybe<Shipment>;
  specialDiscountById?: Maybe<SpecialDiscount>;
  stateById?: Maybe<State>;
  statisticById?: Maybe<Statistic>;
  stockById?: Maybe<Stock>;
  surveyById?: Maybe<Survey>;
  tagById?: Maybe<Tag>;
  targetById?: Maybe<Target>;
  taxCategoryById?: Maybe<TaxCategory>;
  taxRateById?: Maybe<TaxRate>;
  taxRuleById?: Maybe<TaxRule>;
  templateById?: Maybe<Template>;
  themeById?: Maybe<Theme>;
  ticketingById?: Maybe<Ticketing>;
  trainingById?: Maybe<Training>;
  transactionById?: Maybe<Transaction>;
  uploadFileById?: Maybe<UploadFile>;
  userById?: Maybe<User>;
  vendorById?: Maybe<Vendor>;
  visitById?: Maybe<Visit>;
  warehouseById?: Maybe<Warehouse>;
  webhookById?: Maybe<Webhook>;
  websiteById?: Maybe<Website>;
  wishlistById?: Maybe<Wishlist>;
  workspaceById?: Maybe<Workspace>;
  zoneById?: Maybe<Zone>;
  /** Reads a single `Account` using its globally unique `ID`. */
  account?: Maybe<Account>;
  /** Reads a single `Agreement` using its globally unique `ID`. */
  agreement?: Maybe<Agreement>;
  /** Reads a single `Analytic` using its globally unique `ID`. */
  analytic?: Maybe<Analytic>;
  /** Reads a single `Apitoken` using its globally unique `ID`. */
  apitoken?: Maybe<Apitoken>;
  /** Reads a single `Article` using its globally unique `ID`. */
  article?: Maybe<Article>;
  /** Reads a single `Attribute` using its globally unique `ID`. */
  attribute?: Maybe<Attribute>;
  /** Reads a single `Brand` using its globally unique `ID`. */
  brand?: Maybe<Brand>;
  /** Reads a single `CartPriceRule` using its globally unique `ID`. */
  cartPriceRule?: Maybe<CartPriceRule>;
  /** Reads a single `Case` using its globally unique `ID`. */
  case?: Maybe<Case>;
  /** Reads a single `CatalogPriceRule` using its globally unique `ID`. */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  /** Reads a single `Category` using its globally unique `ID`. */
  category?: Maybe<Category>;
  /** Reads a single `Channel` using its globally unique `ID`. */
  channel?: Maybe<Channel>;
  /** Reads a single `Checklist` using its globally unique `ID`. */
  checklist?: Maybe<Checklist>;
  /** Reads a single `City` using its globally unique `ID`. */
  city?: Maybe<City>;
  /** Reads a single `Collection` using its globally unique `ID`. */
  collection?: Maybe<Collection>;
  /** Reads a single `Comment` using its globally unique `ID`. */
  comment?: Maybe<Comment>;
  /** Reads a single `ContentType` using its globally unique `ID`. */
  contentType?: Maybe<ContentType>;
  /** Reads a single `Contract` using its globally unique `ID`. */
  contract?: Maybe<Contract>;
  /** Reads a single `Country` using its globally unique `ID`. */
  country?: Maybe<Country>;
  /** Reads a single `Coupon` using its globally unique `ID`. */
  coupon?: Maybe<Coupon>;
  /** Reads a single `CreditMemo` using its globally unique `ID`. */
  creditMemo?: Maybe<CreditMemo>;
  /** Reads a single `Currency` using its globally unique `ID`. */
  currency?: Maybe<Currency>;
  /** Reads a single `CurrencyRate` using its globally unique `ID`. */
  currencyRate?: Maybe<CurrencyRate>;
  /** Reads a single `CurrencySymbol` using its globally unique `ID`. */
  currencySymbol?: Maybe<CurrencySymbol>;
  /** Reads a single `CustomerGroup` using its globally unique `ID`. */
  customerGroup?: Maybe<CustomerGroup>;
  /** Reads a single `Customer` using its globally unique `ID`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Customization` using its globally unique `ID`. */
  customization?: Maybe<Customization>;
  /** Reads a single `Dashboard` using its globally unique `ID`. */
  dashboard?: Maybe<Dashboard>;
  /** Reads a single `Deepdive` using its globally unique `ID`. */
  deepdive?: Maybe<Deepdive>;
  /** Reads a single `Digiboard` using its globally unique `ID`. */
  digiboard?: Maybe<Digiboard>;
  /** Reads a single `Email` using its globally unique `ID`. */
  email?: Maybe<Email>;
  /** Reads a single `Endofshift` using its globally unique `ID`. */
  endofshift?: Maybe<Endofshift>;
  /** Reads a single `Event` using its globally unique `ID`. */
  event?: Maybe<Event>;
  /** Reads a single `Fullfillment` using its globally unique `ID`. */
  fullfillment?: Maybe<Fullfillment>;
  /** Reads a single `GiftCertificate` using its globally unique `ID`. */
  giftCertificate?: Maybe<GiftCertificate>;
  /** Reads a single `Glossary` using its globally unique `ID`. */
  glossary?: Maybe<Glossary>;
  /** Reads a single `Importm` using its globally unique `ID`. */
  importm?: Maybe<Importm>;
  /** Reads a single `Integration` using its globally unique `ID`. */
  integration?: Maybe<Integration>;
  /** Reads a single `Internalization` using its globally unique `ID`. */
  internalization?: Maybe<Internalization>;
  /** Reads a single `Invitation` using its globally unique `ID`. */
  invitation?: Maybe<Invitation>;
  /** Reads a single `Invoice` using its globally unique `ID`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Lead` using its globally unique `ID`. */
  lead?: Maybe<Lead>;
  /** Reads a single `Manufacturer` using its globally unique `ID`. */
  manufacturer?: Maybe<Manufacturer>;
  /** Reads a single `Mediamanager` using its globally unique `ID`. */
  mediamanager?: Maybe<Mediamanager>;
  /** Reads a single `Meeting` using its globally unique `ID`. */
  meeting?: Maybe<Meeting>;
  /** Reads a single `Message` using its globally unique `ID`. */
  message?: Maybe<Message>;
  /** Reads a single `Newsletter` using its globally unique `ID`. */
  newsletter?: Maybe<Newsletter>;
  /** Reads a single `Ooto` using its globally unique `ID`. */
  ooto?: Maybe<Ooto>;
  /** Reads a single `Opportunity` using its globally unique `ID`. */
  opportunity?: Maybe<Opportunity>;
  /** Reads a single `Order` using its globally unique `ID`. */
  order?: Maybe<Order>;
  /** Reads a single `Page` using its globally unique `ID`. */
  page?: Maybe<Page>;
  /** Reads a single `Partner` using its globally unique `ID`. */
  partner?: Maybe<Partner>;
  /** Reads a single `Payment` using its globally unique `ID`. */
  payment?: Maybe<Payment>;
  /** Reads a single `Permission` using its globally unique `ID`. */
  permission?: Maybe<Permission>;
  /** Reads a single `Plugin` using its globally unique `ID`. */
  plugin?: Maybe<Plugin>;
  /** Reads a single `Poll` using its globally unique `ID`. */
  poll?: Maybe<Poll>;
  /** Reads a single `ProductType` using its globally unique `ID`. */
  productType?: Maybe<ProductType>;
  /** Reads a single `Product` using its globally unique `ID`. */
  product?: Maybe<Product>;
  /** Reads a single `Project` using its globally unique `ID`. */
  project?: Maybe<Project>;
  /** Reads a single `Provider` using its globally unique `ID`. */
  provider?: Maybe<Provider>;
  /** Reads a single `Quote` using its globally unique `ID`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Rating` using its globally unique `ID`. */
  rating?: Maybe<Rating>;
  /** Reads a single `Report` using its globally unique `ID`. */
  report?: Maybe<Report>;
  /** Reads a single `Return` using its globally unique `ID`. */
  return?: Maybe<Return>;
  /** Reads a single `Review` using its globally unique `ID`. */
  review?: Maybe<Review>;
  /** Reads a single `Reward` using its globally unique `ID`. */
  reward?: Maybe<Reward>;
  /** Reads a single `Role` using its globally unique `ID`. */
  role?: Maybe<Role>;
  /** Reads a single `Scheduler` using its globally unique `ID`. */
  scheduler?: Maybe<Scheduler>;
  /** Reads a single `Segment` using its globally unique `ID`. */
  segment?: Maybe<Segment>;
  /** Reads a single `Setting` using its globally unique `ID`. */
  setting?: Maybe<Setting>;
  /** Reads a single `Shipment` using its globally unique `ID`. */
  shipment?: Maybe<Shipment>;
  /** Reads a single `SpecialDiscount` using its globally unique `ID`. */
  specialDiscount?: Maybe<SpecialDiscount>;
  /** Reads a single `State` using its globally unique `ID`. */
  state?: Maybe<State>;
  /** Reads a single `Statistic` using its globally unique `ID`. */
  statistic?: Maybe<Statistic>;
  /** Reads a single `Stock` using its globally unique `ID`. */
  stock?: Maybe<Stock>;
  /** Reads a single `Survey` using its globally unique `ID`. */
  survey?: Maybe<Survey>;
  /** Reads a single `Tag` using its globally unique `ID`. */
  tag?: Maybe<Tag>;
  /** Reads a single `Target` using its globally unique `ID`. */
  target?: Maybe<Target>;
  /** Reads a single `TaxCategory` using its globally unique `ID`. */
  taxCategory?: Maybe<TaxCategory>;
  /** Reads a single `TaxRate` using its globally unique `ID`. */
  taxRate?: Maybe<TaxRate>;
  /** Reads a single `TaxRule` using its globally unique `ID`. */
  taxRule?: Maybe<TaxRule>;
  /** Reads a single `Template` using its globally unique `ID`. */
  template?: Maybe<Template>;
  /** Reads a single `Theme` using its globally unique `ID`. */
  theme?: Maybe<Theme>;
  /** Reads a single `Ticketing` using its globally unique `ID`. */
  ticketing?: Maybe<Ticketing>;
  /** Reads a single `Training` using its globally unique `ID`. */
  training?: Maybe<Training>;
  /** Reads a single `Transaction` using its globally unique `ID`. */
  transaction?: Maybe<Transaction>;
  /** Reads a single `UploadFile` using its globally unique `ID`. */
  uploadFile?: Maybe<UploadFile>;
  /** Reads a single `User` using its globally unique `ID`. */
  user?: Maybe<User>;
  /** Reads a single `Vendor` using its globally unique `ID`. */
  vendor?: Maybe<Vendor>;
  /** Reads a single `Visit` using its globally unique `ID`. */
  visit?: Maybe<Visit>;
  /** Reads a single `Warehouse` using its globally unique `ID`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `Webhook` using its globally unique `ID`. */
  webhook?: Maybe<Webhook>;
  /** Reads a single `Website` using its globally unique `ID`. */
  website?: Maybe<Website>;
  /** Reads a single `Wishlist` using its globally unique `ID`. */
  wishlist?: Maybe<Wishlist>;
  /** Reads a single `Workspace` using its globally unique `ID`. */
  workspace?: Maybe<Workspace>;
  /** Reads a single `Zone` using its globally unique `ID`. */
  zone?: Maybe<Zone>;
};


/** The root query type which gives access points into the data universe. */
export type QuerynodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryallAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  condition?: InputMaybe<AccountCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAccountsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  condition?: InputMaybe<AccountCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAgreementsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
  condition?: InputMaybe<AgreementCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAgreementsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
  condition?: InputMaybe<AgreementCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAnalyticsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
  condition?: InputMaybe<AnalyticCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAnalyticsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
  condition?: InputMaybe<AnalyticCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallApitokensArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
  condition?: InputMaybe<ApitokenCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallApitokensListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
  condition?: InputMaybe<ApitokenCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallArticlesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
  condition?: InputMaybe<ArticleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallArticlesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
  condition?: InputMaybe<ArticleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAttributesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
  condition?: InputMaybe<AttributeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAttributesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
  condition?: InputMaybe<AttributeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallBrandsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
  condition?: InputMaybe<BrandCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallBrandsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
  condition?: InputMaybe<BrandCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCartPriceRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
  condition?: InputMaybe<CartPriceRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCartPriceRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
  condition?: InputMaybe<CartPriceRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
  condition?: InputMaybe<CaseCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCasesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
  condition?: InputMaybe<CaseCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCatalogPriceRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
  condition?: InputMaybe<CatalogPriceRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCatalogPriceRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
  condition?: InputMaybe<CatalogPriceRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
  condition?: InputMaybe<CategoryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCategoriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
  condition?: InputMaybe<CategoryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
  condition?: InputMaybe<ChannelCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallChannelsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
  condition?: InputMaybe<ChannelCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallChecklistsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
  condition?: InputMaybe<ChecklistCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallChecklistsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
  condition?: InputMaybe<ChecklistCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  condition?: InputMaybe<CityCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCitiesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  condition?: InputMaybe<CityCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCollectionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
  condition?: InputMaybe<CollectionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCollectionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
  condition?: InputMaybe<CollectionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCommentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
  condition?: InputMaybe<CommentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCommentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
  condition?: InputMaybe<CommentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallContentTypesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
  condition?: InputMaybe<ContentTypeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallContentTypesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
  condition?: InputMaybe<ContentTypeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallContractsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
  condition?: InputMaybe<ContractCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallContractsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
  condition?: InputMaybe<ContractCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCountriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  condition?: InputMaybe<CountryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCountriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  condition?: InputMaybe<CountryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCouponsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
  condition?: InputMaybe<CouponCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCouponsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
  condition?: InputMaybe<CouponCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCreditMemosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
  condition?: InputMaybe<CreditMemoCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCreditMemosListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
  condition?: InputMaybe<CreditMemoCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrenciesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
  condition?: InputMaybe<CurrencyCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrenciesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
  condition?: InputMaybe<CurrencyCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrencyRatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
  condition?: InputMaybe<CurrencyRateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrencyRatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
  condition?: InputMaybe<CurrencyRateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrencySymbolsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
  condition?: InputMaybe<CurrencySymbolCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrencySymbolsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
  condition?: InputMaybe<CurrencySymbolCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomerGroupsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
  condition?: InputMaybe<CustomerGroupCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomerGroupsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
  condition?: InputMaybe<CustomerGroupCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
  condition?: InputMaybe<CustomerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
  condition?: InputMaybe<CustomerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomizationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
  condition?: InputMaybe<CustomizationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomizationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
  condition?: InputMaybe<CustomizationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDashboardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
  condition?: InputMaybe<DashboardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDashboardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
  condition?: InputMaybe<DashboardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDeepdivesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
  condition?: InputMaybe<DeepdiveCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDeepdivesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
  condition?: InputMaybe<DeepdiveCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDigiboardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
  condition?: InputMaybe<DigiboardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDigiboardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
  condition?: InputMaybe<DigiboardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEmailsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  condition?: InputMaybe<EmailCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEmailsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  condition?: InputMaybe<EmailCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEndofshiftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
  condition?: InputMaybe<EndofshiftCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEndofshiftsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
  condition?: InputMaybe<EndofshiftCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  condition?: InputMaybe<EventCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEventsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  condition?: InputMaybe<EventCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallFullfillmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
  condition?: InputMaybe<FullfillmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallFullfillmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
  condition?: InputMaybe<FullfillmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallGiftCertificatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
  condition?: InputMaybe<GiftCertificateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallGiftCertificatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
  condition?: InputMaybe<GiftCertificateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallGlossariesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
  condition?: InputMaybe<GlossaryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallGlossariesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
  condition?: InputMaybe<GlossaryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallImportmsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
  condition?: InputMaybe<ImportmCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallImportmsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
  condition?: InputMaybe<ImportmCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallIntegrationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
  condition?: InputMaybe<IntegrationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallIntegrationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
  condition?: InputMaybe<IntegrationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInternalizationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
  condition?: InputMaybe<InternalizationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInternalizationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
  condition?: InputMaybe<InternalizationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInvitationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
  condition?: InputMaybe<InvitationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInvitationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
  condition?: InputMaybe<InvitationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInvoicesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
  condition?: InputMaybe<InvoiceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInvoicesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
  condition?: InputMaybe<InvoiceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallLeadsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
  condition?: InputMaybe<LeadCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallLeadsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
  condition?: InputMaybe<LeadCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallManufacturersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
  condition?: InputMaybe<ManufacturerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallManufacturersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
  condition?: InputMaybe<ManufacturerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMediamanagersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
  condition?: InputMaybe<MediamanagerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMediamanagersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
  condition?: InputMaybe<MediamanagerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMeetingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
  condition?: InputMaybe<MeetingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMeetingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
  condition?: InputMaybe<MeetingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMessagesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  condition?: InputMaybe<MessageCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMessagesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  condition?: InputMaybe<MessageCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallNewslettersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
  condition?: InputMaybe<NewsletterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallNewslettersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
  condition?: InputMaybe<NewsletterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOotosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
  condition?: InputMaybe<OotoCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOotosListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
  condition?: InputMaybe<OotoCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOpportunitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
  condition?: InputMaybe<OpportunityCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOpportunitiesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
  condition?: InputMaybe<OpportunityCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOrdersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
  condition?: InputMaybe<OrderCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOrdersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
  condition?: InputMaybe<OrderCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPagesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
  condition?: InputMaybe<PageCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPagesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
  condition?: InputMaybe<PageCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPartnersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
  condition?: InputMaybe<PartnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPartnersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
  condition?: InputMaybe<PartnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPaymentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
  condition?: InputMaybe<PaymentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPaymentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
  condition?: InputMaybe<PaymentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPermissionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  condition?: InputMaybe<PermissionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPermissionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  condition?: InputMaybe<PermissionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPluginsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
  condition?: InputMaybe<PluginCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPluginsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
  condition?: InputMaybe<PluginCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPollsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
  condition?: InputMaybe<PollCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPollsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
  condition?: InputMaybe<PollCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProductTypesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
  condition?: InputMaybe<ProductTypeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProductTypesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
  condition?: InputMaybe<ProductTypeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProductsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
  condition?: InputMaybe<ProductCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProductsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
  condition?: InputMaybe<ProductCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProjectsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  condition?: InputMaybe<ProjectCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProjectsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  condition?: InputMaybe<ProjectCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProvidersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
  condition?: InputMaybe<ProviderCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProvidersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
  condition?: InputMaybe<ProviderCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallQuotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  condition?: InputMaybe<QuoteCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallQuotesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  condition?: InputMaybe<QuoteCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRatingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
  condition?: InputMaybe<RatingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRatingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
  condition?: InputMaybe<RatingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
  condition?: InputMaybe<ReportCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReportsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
  condition?: InputMaybe<ReportCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReturnsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
  condition?: InputMaybe<ReturnCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReturnsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
  condition?: InputMaybe<ReturnCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReviewsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
  condition?: InputMaybe<ReviewCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReviewsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
  condition?: InputMaybe<ReviewCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRewardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
  condition?: InputMaybe<RewardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRewardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
  condition?: InputMaybe<RewardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRolesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  condition?: InputMaybe<RoleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRolesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  condition?: InputMaybe<RoleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSchedulersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
  condition?: InputMaybe<SchedulerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSchedulersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
  condition?: InputMaybe<SchedulerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSegmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
  condition?: InputMaybe<SegmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSegmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
  condition?: InputMaybe<SegmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSettingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
  condition?: InputMaybe<SettingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSettingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
  condition?: InputMaybe<SettingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallShipmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
  condition?: InputMaybe<ShipmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallShipmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
  condition?: InputMaybe<ShipmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSpecialDiscountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
  condition?: InputMaybe<SpecialDiscountCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSpecialDiscountsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
  condition?: InputMaybe<SpecialDiscountCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
  condition?: InputMaybe<StateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
  condition?: InputMaybe<StateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStatisticsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
  condition?: InputMaybe<StatisticCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStatisticsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
  condition?: InputMaybe<StatisticCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStocksArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
  condition?: InputMaybe<StockCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStocksListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
  condition?: InputMaybe<StockCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSurveysArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
  condition?: InputMaybe<SurveyCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSurveysListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
  condition?: InputMaybe<SurveyCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTagsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
  condition?: InputMaybe<TagCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTagsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
  condition?: InputMaybe<TagCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTargetsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
  condition?: InputMaybe<TargetCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTargetsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
  condition?: InputMaybe<TargetCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
  condition?: InputMaybe<TaxCategoryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxCategoriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
  condition?: InputMaybe<TaxCategoryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxRatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
  condition?: InputMaybe<TaxRateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxRatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
  condition?: InputMaybe<TaxRateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
  condition?: InputMaybe<TaxRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
  condition?: InputMaybe<TaxRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTemplatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
  condition?: InputMaybe<TemplateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTemplatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
  condition?: InputMaybe<TemplateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallThemesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
  condition?: InputMaybe<ThemeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallThemesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
  condition?: InputMaybe<ThemeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTicketingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
  condition?: InputMaybe<TicketingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTicketingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
  condition?: InputMaybe<TicketingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTrainingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
  condition?: InputMaybe<TrainingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTrainingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
  condition?: InputMaybe<TrainingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
  condition?: InputMaybe<TransactionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTransactionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
  condition?: InputMaybe<TransactionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallUploadFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
  condition?: InputMaybe<UploadFileCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallUploadFilesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
  condition?: InputMaybe<UploadFileCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallUsersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  condition?: InputMaybe<UserCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallUsersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  condition?: InputMaybe<UserCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallVendorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
  condition?: InputMaybe<VendorCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallVendorsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
  condition?: InputMaybe<VendorCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallVisitsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
  condition?: InputMaybe<VisitCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallVisitsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
  condition?: InputMaybe<VisitCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWarehousesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
  condition?: InputMaybe<WarehouseCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWarehousesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
  condition?: InputMaybe<WarehouseCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWebhooksArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
  condition?: InputMaybe<WebhookCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWebhooksListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
  condition?: InputMaybe<WebhookCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWebsitesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
  condition?: InputMaybe<WebsiteCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWebsitesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
  condition?: InputMaybe<WebsiteCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWishlistsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
  condition?: InputMaybe<WishlistCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWishlistsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
  condition?: InputMaybe<WishlistCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWorkspacesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
  condition?: InputMaybe<WorkspaceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWorkspacesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
  condition?: InputMaybe<WorkspaceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallZonesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
  condition?: InputMaybe<ZoneCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallZonesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
  condition?: InputMaybe<ZoneCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryaccountByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryagreementByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryanalyticByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryapitokenByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryarticleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryattributeByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerybrandByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycartPriceRuleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycaseByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycatalogPriceRuleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycategoryByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerychannelByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerychecklistByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycityByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycollectionByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycommentByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycontentTypeByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycontractByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycountryByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycouponByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycreditMemoByCreditMemoAndIdArgs = {
  creditMemo: Scalars['String'];
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencyByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencyRateByImportServiceArgs = {
  importService: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencySymbolBySymbolArgs = {
  symbol: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomerGroupByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomerByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomizationByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydashboardByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydeepdiveByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydigiboardByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryemailByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryendofshiftByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryeventByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryfullfillmentByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerygiftCertificateByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryglossaryByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryimportmByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryintegrationByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinternalizationByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinvitationByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinvoiceByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryleadByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymanufacturerByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymediamanagerByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymeetingByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymessageByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerynewsletterByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryootoByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryopportunityByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryorderByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypageByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypartnerByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypaymentByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypermissionByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypluginByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypollByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproductTypeByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproductByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryprojectByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproviderByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryquoteByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryratingByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreportByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreturnByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreviewByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryrewardByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryroleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryschedulerByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysegmentByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysettingByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryshipmentByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryspecialDiscountByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystateByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystatisticByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystockByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysurveyByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytagByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytargetByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxCategoryByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxRateByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxRuleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytemplateByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerythemeByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryticketingByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytrainingByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytransactionByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryuploadFileByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryuserByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryvendorByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryvisitByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywarehouseByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywebhookByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywebsiteByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywishlistByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryworkspaceByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryzoneByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryaccountArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryagreementArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryanalyticArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryapitokenArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryarticleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryattributeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerybrandArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycartPriceRuleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycaseArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycatalogPriceRuleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycategoryArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerychannelArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerychecklistArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycityArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycollectionArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycommentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycontentTypeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycontractArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycountryArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycouponArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycreditMemoArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencyArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencyRateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencySymbolArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomerGroupArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomizationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydashboardArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydeepdiveArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydigiboardArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryemailArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryendofshiftArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryeventArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryfullfillmentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerygiftCertificateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryglossaryArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryimportmArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryintegrationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinternalizationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinvitationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinvoiceArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryleadArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymanufacturerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymediamanagerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymeetingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymessageArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerynewsletterArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryootoArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryopportunityArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryorderArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypageArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypartnerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypaymentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypermissionArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypluginArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypollArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproductTypeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproductArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryprojectArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproviderArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryquoteArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryratingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreportArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreturnArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreviewArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryrewardArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryroleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryschedulerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysegmentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysettingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryshipmentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryspecialDiscountArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystatisticArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystockArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysurveyArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytagArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytargetArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxCategoryArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxRateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxRuleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytemplateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerythemeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryticketingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytrainingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytransactionArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryuploadFileArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryuserArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryvendorArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryvisitArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywarehouseArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywebhookArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywebsiteArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywishlistArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryworkspaceArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryzoneArgs = {
  nodeId: Scalars['ID'];
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

/** A connection to a list of `Account` values. */
export type AccountsConnection = {
  /** A list of `Account` objects. */
  nodes: Array<Maybe<Account>>;
  /** A list of edges which contains the `Account` and cursor to aid in pagination. */
  edges: Array<AccountsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Account` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Account = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  officePhone?: Maybe<Scalars['String']>;
  fax?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  postalcode?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  altAddress?: Maybe<Scalars['String']>;
  altPostalcode?: Maybe<Scalars['String']>;
  altCity?: Maybe<Scalars['String']>;
  altState?: Maybe<Scalars['String']>;
  altCountry?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  industry?: Maybe<Scalars['String']>;
  employees?: Maybe<Scalars['String']>;
  annualRevenue?: Maybe<Scalars['String']>;
  memberOf?: Maybe<Scalars['String']>;
  campaign?: Maybe<Scalars['String']>;
};

/** A `Account` edge in the connection. */
export type AccountsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Account` at the end of the edge. */
  node?: Maybe<Account>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
};

/** Methods to use when ordering `Account`. */
export type AccountsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'OFFICE_PHONE_ASC'
  | 'OFFICE_PHONE_DESC'
  | 'FAX_ASC'
  | 'FAX_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'POSTALCODE_ASC'
  | 'POSTALCODE_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'ALT_ADDRESS_ASC'
  | 'ALT_ADDRESS_DESC'
  | 'ALT_POSTALCODE_ASC'
  | 'ALT_POSTALCODE_DESC'
  | 'ALT_CITY_ASC'
  | 'ALT_CITY_DESC'
  | 'ALT_STATE_ASC'
  | 'ALT_STATE_DESC'
  | 'ALT_COUNTRY_ASC'
  | 'ALT_COUNTRY_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'INDUSTRY_ASC'
  | 'INDUSTRY_DESC'
  | 'EMPLOYEES_ASC'
  | 'EMPLOYEES_DESC'
  | 'ANNUAL_REVENUE_ASC'
  | 'ANNUAL_REVENUE_DESC'
  | 'MEMBER_OF_ASC'
  | 'MEMBER_OF_DESC'
  | 'CAMPAIGN_ASC'
  | 'CAMPAIGN_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AccountCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `officePhone` field. */
  officePhone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `fax` field. */
  fax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalcode` field. */
  postalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altAddress` field. */
  altAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altPostalcode` field. */
  altPostalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altCity` field. */
  altCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altState` field. */
  altState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altCountry` field. */
  altCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `industry` field. */
  industry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `employees` field. */
  employees?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `annualRevenue` field. */
  annualRevenue?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `memberOf` field. */
  memberOf?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `campaign` field. */
  campaign?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Agreement` values. */
export type AgreementsConnection = {
  /** A list of `Agreement` objects. */
  nodes: Array<Maybe<Agreement>>;
  /** A list of edges which contains the `Agreement` and cursor to aid in pagination. */
  edges: Array<AgreementsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Agreement` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Agreement = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  referenceId?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  updated?: Maybe<Scalars['Datetime']>;
  content?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  excerpt?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['String']>;
  shopId?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
};

/** A `Agreement` edge in the connection. */
export type AgreementsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Agreement` at the end of the edge. */
  node?: Maybe<Agreement>;
};

/** Methods to use when ordering `Agreement`. */
export type AgreementsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'REFERENCE_ID_ASC'
  | 'REFERENCE_ID_DESC'
  | 'CREATED_ASC'
  | 'CREATED_DESC'
  | 'UPDATED_ASC'
  | 'UPDATED_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC'
  | 'SHOP_ID_ASC'
  | 'SHOP_ID_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Agreement` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AgreementCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `referenceId` field. */
  referenceId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updated` field. */
  updated?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shopId` field. */
  shopId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Analytic` values. */
export type AnalyticsConnection = {
  /** A list of `Analytic` objects. */
  nodes: Array<Maybe<Analytic>>;
  /** A list of edges which contains the `Analytic` and cursor to aid in pagination. */
  edges: Array<AnalyticsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Analytic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Analytic = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  shareData?: Maybe<Scalars['String']>;
  websiteName?: Maybe<Scalars['String']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  trackingId?: Maybe<Scalars['String']>;
  propertyName?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  defaultView?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  propertyHit?: Maybe<Scalars['String']>;
  trackingCode?: Maybe<Scalars['String']>;
  dataCollection?: Maybe<Scalars['Boolean']>;
  dataRetention?: Maybe<Scalars['Boolean']>;
  searchAnalytics?: Maybe<Scalars['String']>;
};

/** A `Analytic` edge in the connection. */
export type AnalyticsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Analytic` at the end of the edge. */
  node?: Maybe<Analytic>;
};

/** Methods to use when ordering `Analytic`. */
export type AnalyticsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'SHARE_DATA_ASC'
  | 'SHARE_DATA_DESC'
  | 'WEBSITE_NAME_ASC'
  | 'WEBSITE_NAME_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'TRACKING_ID_ASC'
  | 'TRACKING_ID_DESC'
  | 'PROPERTY_NAME_ASC'
  | 'PROPERTY_NAME_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'DEFAULT_VIEW_ASC'
  | 'DEFAULT_VIEW_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'PROPERTY_HIT_ASC'
  | 'PROPERTY_HIT_DESC'
  | 'TRACKING_CODE_ASC'
  | 'TRACKING_CODE_DESC'
  | 'DATA_COLLECTION_ASC'
  | 'DATA_COLLECTION_DESC'
  | 'DATA_RETENTION_ASC'
  | 'DATA_RETENTION_DESC'
  | 'SEARCH_ANALYTICS_ASC'
  | 'SEARCH_ANALYTICS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Analytic` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AnalyticCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shareData` field. */
  shareData?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `websiteName` field. */
  websiteName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `trackingId` field. */
  trackingId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `propertyName` field. */
  propertyName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultView` field. */
  defaultView?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `propertyHit` field. */
  propertyHit?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `trackingCode` field. */
  trackingCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dataCollection` field. */
  dataCollection?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `dataRetention` field. */
  dataRetention?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `searchAnalytics` field. */
  searchAnalytics?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Apitoken` values. */
export type ApitokensConnection = {
  /** A list of `Apitoken` objects. */
  nodes: Array<Maybe<Apitoken>>;
  /** A list of edges which contains the `Apitoken` and cursor to aid in pagination. */
  edges: Array<ApitokensEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Apitoken` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Apitoken = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name: Scalars['String'];
  tokenType?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  token: Scalars['BigInt'];
};

/** A `Apitoken` edge in the connection. */
export type ApitokensEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Apitoken` at the end of the edge. */
  node?: Maybe<Apitoken>;
};

/** Methods to use when ordering `Apitoken`. */
export type ApitokensOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'TOKEN_TYPE_ASC'
  | 'TOKEN_TYPE_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'TOKEN_ASC'
  | 'TOKEN_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Apitoken` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ApitokenCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tokenType` field. */
  tokenType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `token` field. */
  token?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Article` values. */
export type ArticlesConnection = {
  /** A list of `Article` objects. */
  nodes: Array<Maybe<Article>>;
  /** A list of edges which contains the `Article` and cursor to aid in pagination. */
  edges: Array<ArticlesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Article` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Article = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  excerpt?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['String']>;
  custId?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  metaName?: Maybe<Scalars['String']>;
  metaUrl?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** A `Article` edge in the connection. */
export type ArticlesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Article` at the end of the edge. */
  node?: Maybe<Article>;
};

/** Methods to use when ordering `Article`. */
export type ArticlesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'META_NAME_ASC'
  | 'META_NAME_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Article` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ArticleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `published` field. */
  published?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaName` field. */
  metaName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Attribute` values. */
export type AttributesConnection = {
  /** A list of `Attribute` objects. */
  nodes: Array<Maybe<Attribute>>;
  /** A list of edges which contains the `Attribute` and cursor to aid in pagination. */
  edges: Array<AttributesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Attribute` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Attribute = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  defaultLabel?: Maybe<Scalars['String']>;
  attributeCode?: Maybe<Scalars['String']>;
  filterOptions?: Maybe<Scalars['String']>;
  useSearch?: Maybe<Scalars['String']>;
  layeredNavigation?: Maybe<Scalars['Boolean']>;
  searchResultsLayeredNavigation?: Maybe<Scalars['Boolean']>;
  position?: Maybe<Scalars['String']>;
  promoRuleConditions?: Maybe<Scalars['Boolean']>;
  allowHtmlTagsStorefront?: Maybe<Scalars['Boolean']>;
  visibleCatalogPagesStorefront?: Maybe<Scalars['Boolean']>;
  usedProductListing?: Maybe<Scalars['Boolean']>;
  usedSortingProductListing?: Maybe<Scalars['Boolean']>;
  prodId: Scalars['BigInt'];
  attributeClass?: Maybe<Scalars['String']>;
  attributeValue?: Maybe<Scalars['String']>;
  columnOptions?: Maybe<Scalars['String']>;
  facetedNavigation?: Maybe<Scalars['Boolean']>;
  isPublic?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  metaName?: Maybe<Scalars['Boolean']>;
  metaUrl?: Maybe<Scalars['String']>;
  productAttributeSet?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
};

/** A `Attribute` edge in the connection. */
export type AttributesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Attribute` at the end of the edge. */
  node?: Maybe<Attribute>;
};

/** Methods to use when ordering `Attribute`. */
export type AttributesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'DEFAULT_LABEL_ASC'
  | 'DEFAULT_LABEL_DESC'
  | 'ATTRIBUTE_CODE_ASC'
  | 'ATTRIBUTE_CODE_DESC'
  | 'FILTER_OPTIONS_ASC'
  | 'FILTER_OPTIONS_DESC'
  | 'USE_SEARCH_ASC'
  | 'USE_SEARCH_DESC'
  | 'LAYERED_NAVIGATION_ASC'
  | 'LAYERED_NAVIGATION_DESC'
  | 'SEARCH_RESULTS_LAYERED_NAVIGATION_ASC'
  | 'SEARCH_RESULTS_LAYERED_NAVIGATION_DESC'
  | 'POSITION_ASC'
  | 'POSITION_DESC'
  | 'PROMO_RULE_CONDITIONS_ASC'
  | 'PROMO_RULE_CONDITIONS_DESC'
  | 'ALLOW_HTML_TAGS_STOREFRONT_ASC'
  | 'ALLOW_HTML_TAGS_STOREFRONT_DESC'
  | 'VISIBLE_CATALOG_PAGES_STOREFRONT_ASC'
  | 'VISIBLE_CATALOG_PAGES_STOREFRONT_DESC'
  | 'USED_PRODUCT_LISTING_ASC'
  | 'USED_PRODUCT_LISTING_DESC'
  | 'USED_SORTING_PRODUCT_LISTING_ASC'
  | 'USED_SORTING_PRODUCT_LISTING_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'ATTRIBUTE_CLASS_ASC'
  | 'ATTRIBUTE_CLASS_DESC'
  | 'ATTRIBUTE_VALUE_ASC'
  | 'ATTRIBUTE_VALUE_DESC'
  | 'COLUMN_OPTIONS_ASC'
  | 'COLUMN_OPTIONS_DESC'
  | 'FACETED_NAVIGATION_ASC'
  | 'FACETED_NAVIGATION_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'META_NAME_ASC'
  | 'META_NAME_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'PRODUCT_ATTRIBUTE_SET_ASC'
  | 'PRODUCT_ATTRIBUTE_SET_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Attribute` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AttributeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `defaultLabel` field. */
  defaultLabel?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `attributeCode` field. */
  attributeCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `filterOptions` field. */
  filterOptions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `useSearch` field. */
  useSearch?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `layeredNavigation` field. */
  layeredNavigation?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `searchResultsLayeredNavigation` field. */
  searchResultsLayeredNavigation?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `position` field. */
  position?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `promoRuleConditions` field. */
  promoRuleConditions?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `allowHtmlTagsStorefront` field. */
  allowHtmlTagsStorefront?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `visibleCatalogPagesStorefront` field. */
  visibleCatalogPagesStorefront?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `usedProductListing` field. */
  usedProductListing?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `usedSortingProductListing` field. */
  usedSortingProductListing?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `attributeClass` field. */
  attributeClass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `attributeValue` field. */
  attributeValue?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `columnOptions` field. */
  columnOptions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `facetedNavigation` field. */
  facetedNavigation?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaName` field. */
  metaName?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `productAttributeSet` field. */
  productAttributeSet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Brand` values. */
export type BrandsConnection = {
  /** A list of `Brand` objects. */
  nodes: Array<Maybe<Brand>>;
  /** A list of edges which contains the `Brand` and cursor to aid in pagination. */
  edges: Array<BrandsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Brand` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Brand = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['BigInt']>;
  description?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Brand` edge in the connection. */
export type BrandsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Brand` at the end of the edge. */
  node?: Maybe<Brand>;
};

/** Methods to use when ordering `Brand`. */
export type BrandsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type BrandCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `product` field. */
  product?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `CartPriceRule` values. */
export type CartPriceRulesConnection = {
  /** A list of `CartPriceRule` objects. */
  nodes: Array<Maybe<CartPriceRule>>;
  /** A list of edges which contains the `CartPriceRule` and cursor to aid in pagination. */
  edges: Array<CartPriceRulesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CartPriceRule` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CartPriceRule = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  rule?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  coupon?: Maybe<Scalars['String']>;
  usesPerCustomer?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Date']>;
  endDate?: Maybe<Scalars['Date']>;
  status?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  actionsApply?: Maybe<Scalars['String']>;
  actionsDiscountAmount?: Maybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: Maybe<Scalars['Boolean']>;
  actionsMaxQtyDiscountIsAppliedTo?: Maybe<Scalars['BigFloat']>;
  actionsDiscountQtyStep?: Maybe<Scalars['BigFloat']>;
  actionsApplyShippingAmount?: Maybe<Scalars['Boolean']>;
};

/** A `CartPriceRule` edge in the connection. */
export type CartPriceRulesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CartPriceRule` at the end of the edge. */
  node?: Maybe<CartPriceRule>;
};

/** Methods to use when ordering `CartPriceRule`. */
export type CartPriceRulesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'RULE_ASC'
  | 'RULE_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'COUPON_ASC'
  | 'COUPON_DESC'
  | 'USES_PER_CUSTOMER_ASC'
  | 'USES_PER_CUSTOMER_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'ACTIONS_APPLY_ASC'
  | 'ACTIONS_APPLY_DESC'
  | 'ACTIONS_DISCOUNT_AMOUNT_ASC'
  | 'ACTIONS_DISCOUNT_AMOUNT_DESC'
  | 'ACTIONS_DISCARD_SUBSEQUENT_RULES_ASC'
  | 'ACTIONS_DISCARD_SUBSEQUENT_RULES_DESC'
  | 'ACTIONS_MAX_QTY_DISCOUNT_IS_APPLIED_TO_ASC'
  | 'ACTIONS_MAX_QTY_DISCOUNT_IS_APPLIED_TO_DESC'
  | 'ACTIONS_DISCOUNT_QTY_STEP_ASC'
  | 'ACTIONS_DISCOUNT_QTY_STEP_DESC'
  | 'ACTIONS_APPLY_SHIPPING_AMOUNT_ASC'
  | 'ACTIONS_APPLY_SHIPPING_AMOUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CartPriceRule` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CartPriceRuleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rule` field. */
  rule?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `coupon` field. */
  coupon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `usesPerCustomer` field. */
  usesPerCustomer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `actionsApply` field. */
  actionsApply?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `actionsDiscountAmount` field. */
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `actionsDiscardSubsequentRules` field. */
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `actionsMaxQtyDiscountIsAppliedTo` field. */
  actionsMaxQtyDiscountIsAppliedTo?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `actionsDiscountQtyStep` field. */
  actionsDiscountQtyStep?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `actionsApplyShippingAmount` field. */
  actionsApplyShippingAmount?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Case` values. */
export type CasesConnection = {
  /** A list of `Case` objects. */
  nodes: Array<Maybe<Case>>;
  /** A list of edges which contains the `Case` and cursor to aid in pagination. */
  edges: Array<CasesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Case` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Case = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  caseNumber?: Maybe<Scalars['Int']>;
  state?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  resolution?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  accountName?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  dateModified?: Maybe<Scalars['Datetime']>;
};

/** A `Case` edge in the connection. */
export type CasesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Case` at the end of the edge. */
  node?: Maybe<Case>;
};

/** Methods to use when ordering `Case`. */
export type CasesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CASE_NUMBER_ASC'
  | 'CASE_NUMBER_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'RESOLUTION_ASC'
  | 'RESOLUTION_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'DATE_MODIFIED_ASC'
  | 'DATE_MODIFIED_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Case` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CaseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `caseNumber` field. */
  caseNumber?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `resolution` field. */
  resolution?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateModified` field. */
  dateModified?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `CatalogPriceRule` values. */
export type CatalogPriceRulesConnection = {
  /** A list of `CatalogPriceRule` objects. */
  nodes: Array<Maybe<CatalogPriceRule>>;
  /** A list of edges which contains the `CatalogPriceRule` and cursor to aid in pagination. */
  edges: Array<CatalogPriceRulesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CatalogPriceRule` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CatalogPriceRule = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  rule?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  customerGroups?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Date']>;
  endDate?: Maybe<Scalars['Date']>;
  status?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  actionsApply?: Maybe<Scalars['String']>;
  actionsDiscountAmount?: Maybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: Maybe<Scalars['Boolean']>;
};

/** A `CatalogPriceRule` edge in the connection. */
export type CatalogPriceRulesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CatalogPriceRule` at the end of the edge. */
  node?: Maybe<CatalogPriceRule>;
};

/** Methods to use when ordering `CatalogPriceRule`. */
export type CatalogPriceRulesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'RULE_ASC'
  | 'RULE_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'CUSTOMER_GROUPS_ASC'
  | 'CUSTOMER_GROUPS_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'ACTIONS_APPLY_ASC'
  | 'ACTIONS_APPLY_DESC'
  | 'ACTIONS_DISCOUNT_AMOUNT_ASC'
  | 'ACTIONS_DISCOUNT_AMOUNT_DESC'
  | 'ACTIONS_DISCARD_SUBSEQUENT_RULES_ASC'
  | 'ACTIONS_DISCARD_SUBSEQUENT_RULES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CatalogPriceRule` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CatalogPriceRuleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rule` field. */
  rule?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `customerGroups` field. */
  customerGroups?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `actionsApply` field. */
  actionsApply?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `actionsDiscountAmount` field. */
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `actionsDiscardSubsequentRules` field. */
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Category` values. */
export type CategoriesConnection = {
  /** A list of `Category` objects. */
  nodes: Array<Maybe<Category>>;
  /** A list of edges which contains the `Category` and cursor to aid in pagination. */
  edges: Array<CategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Category` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Category = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  thumbnail?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  visibility?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Boolean']>;
  websites?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  metaTitle?: Maybe<Scalars['String']>;
  metaKeywords?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  metaUrl?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Category` edge in the connection. */
export type CategoriesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Category` at the end of the edge. */
  node?: Maybe<Category>;
};

/** Methods to use when ordering `Category`. */
export type CategoriesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'THUMBNAIL_ASC'
  | 'THUMBNAIL_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'VISIBILITY_ASC'
  | 'VISIBILITY_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'META_TITLE_ASC'
  | 'META_TITLE_DESC'
  | 'META_KEYWORDS_ASC'
  | 'META_KEYWORDS_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Category` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `thumbnail` field. */
  thumbnail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `visibility` field. */
  visibility?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaTitle` field. */
  metaTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaKeywords` field. */
  metaKeywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Channel` values. */
export type ChannelsConnection = {
  /** A list of `Channel` objects. */
  nodes: Array<Maybe<Channel>>;
  /** A list of edges which contains the `Channel` and cursor to aid in pagination. */
  edges: Array<ChannelsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Channel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Channel = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  defaultLang?: Maybe<Scalars['String']>;
  includeTax?: Maybe<Scalars['String']>;
  defaultZone?: Maybe<Scalars['String']>;
  defaultShipping?: Maybe<Scalars['String']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
};

/** A `Channel` edge in the connection. */
export type ChannelsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Channel` at the end of the edge. */
  node?: Maybe<Channel>;
};

/** Methods to use when ordering `Channel`. */
export type ChannelsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CURRENCY_ASC'
  | 'CURRENCY_DESC'
  | 'DEFAULT_LANG_ASC'
  | 'DEFAULT_LANG_DESC'
  | 'INCLUDE_TAX_ASC'
  | 'INCLUDE_TAX_DESC'
  | 'DEFAULT_ZONE_ASC'
  | 'DEFAULT_ZONE_DESC'
  | 'DEFAULT_SHIPPING_ASC'
  | 'DEFAULT_SHIPPING_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Channel` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ChannelCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultLang` field. */
  defaultLang?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `includeTax` field. */
  includeTax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultZone` field. */
  defaultZone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultShipping` field. */
  defaultShipping?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Checklist` values. */
export type ChecklistsConnection = {
  /** A list of `Checklist` objects. */
  nodes: Array<Maybe<Checklist>>;
  /** A list of edges which contains the `Checklist` and cursor to aid in pagination. */
  edges: Array<ChecklistsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Checklist` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Checklist = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  username?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  regionalManager?: Maybe<Scalars['String']>;
  manager?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  ticket?: Maybe<Scalars['String']>;
  project?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  prodId?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
  task?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** A `Checklist` edge in the connection. */
export type ChecklistsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Checklist` at the end of the edge. */
  node?: Maybe<Checklist>;
};

/** Methods to use when ordering `Checklist`. */
export type ChecklistsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'REGIONAL_MANAGER_ASC'
  | 'REGIONAL_MANAGER_DESC'
  | 'MANAGER_ASC'
  | 'MANAGER_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'TICKET_ASC'
  | 'TICKET_DESC'
  | 'PROJECT_ASC'
  | 'PROJECT_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'TASK_ASC'
  | 'TASK_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Checklist` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ChecklistCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `regionalManager` field. */
  regionalManager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `manager` field. */
  manager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ticket` field. */
  ticket?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `project` field. */
  project?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `region` field. */
  region?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `task` field. */
  task?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `City` values. */
export type CitiesConnection = {
  /** A list of `City` objects. */
  nodes: Array<Maybe<City>>;
  /** A list of edges which contains the `City` and cursor to aid in pagination. */
  edges: Array<CitiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `City` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type City = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  postalCode?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
};

/** A `City` edge in the connection. */
export type CitiesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `City` at the end of the edge. */
  node?: Maybe<City>;
};

/** Methods to use when ordering `City`. */
export type CitiesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'POSTAL_CODE_ASC'
  | 'POSTAL_CODE_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `City` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CityCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalCode` field. */
  postalCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Collection` values. */
export type CollectionsConnection = {
  /** A list of `Collection` objects. */
  nodes: Array<Maybe<Collection>>;
  /** A list of edges which contains the `Collection` and cursor to aid in pagination. */
  edges: Array<CollectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Collection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Collection = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  metaTitle?: Maybe<Scalars['String']>;
  metaKeywords?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
};

/** A `Collection` edge in the connection. */
export type CollectionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Collection` at the end of the edge. */
  node?: Maybe<Collection>;
};

/** Methods to use when ordering `Collection`. */
export type CollectionsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'META_TITLE_ASC'
  | 'META_TITLE_DESC'
  | 'META_KEYWORDS_ASC'
  | 'META_KEYWORDS_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Collection` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CollectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaTitle` field. */
  metaTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaKeywords` field. */
  metaKeywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Comment` values. */
export type CommentsConnection = {
  /** A list of `Comment` objects. */
  nodes: Array<Maybe<Comment>>;
  /** A list of edges which contains the `Comment` and cursor to aid in pagination. */
  edges: Array<CommentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Comment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Comment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  customerName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  response?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  custId: Scalars['Int'];
  customers?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
};

/** A `Comment` edge in the connection. */
export type CommentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Comment` at the end of the edge. */
  node?: Maybe<Comment>;
};

/** Methods to use when ordering `Comment`. */
export type CommentsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CUSTOMER_NAME_ASC'
  | 'CUSTOMER_NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'RESPONSE_ASC'
  | 'RESPONSE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Comment` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CommentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `customerName` field. */
  customerName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `response` field. */
  response?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `ContentType` values. */
export type ContentTypesConnection = {
  /** A list of `ContentType` objects. */
  nodes: Array<Maybe<ContentType>>;
  /** A list of edges which contains the `ContentType` and cursor to aid in pagination. */
  edges: Array<ContentTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContentType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ContentType = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  text?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['BigFloat']>;
  json?: Maybe<Scalars['JSON']>;
  link?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  uid?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Date']>;
  time?: Maybe<Scalars['Time']>;
  timestamp?: Maybe<Scalars['Datetime']>;
  boolean?: Maybe<Scalars['Boolean']>;
  richText?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  databaseName?: Maybe<Scalars['String']>;
};

/** A `ContentType` edge in the connection. */
export type ContentTypesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContentType` at the end of the edge. */
  node?: Maybe<ContentType>;
};

/** Methods to use when ordering `ContentType`. */
export type ContentTypesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'TEXT_ASC'
  | 'TEXT_DESC'
  | 'NUMBER_ASC'
  | 'NUMBER_DESC'
  | 'JSON_ASC'
  | 'JSON_DESC'
  | 'LINK_ASC'
  | 'LINK_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'UID_ASC'
  | 'UID_DESC'
  | 'DATE_ASC'
  | 'DATE_DESC'
  | 'TIME_ASC'
  | 'TIME_DESC'
  | 'TIMESTAMP_ASC'
  | 'TIMESTAMP_DESC'
  | 'BOOLEAN_ASC'
  | 'BOOLEAN_DESC'
  | 'RICH_TEXT_ASC'
  | 'RICH_TEXT_DESC'
  | 'PASSWORD_ASC'
  | 'PASSWORD_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'DATABASE_NAME_ASC'
  | 'DATABASE_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `ContentType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ContentTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `text` field. */
  text?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `json` field. */
  json?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `link` field. */
  link?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uid` field. */
  uid?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `time` field. */
  time?: InputMaybe<Scalars['Time']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `boolean` field. */
  boolean?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `richText` field. */
  richText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `password` field. */
  password?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `databaseName` field. */
  databaseName?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Contract` values. */
export type ContractsConnection = {
  /** A list of `Contract` objects. */
  nodes: Array<Maybe<Contract>>;
  /** A list of edges which contains the `Contract` and cursor to aid in pagination. */
  edges: Array<ContractsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Contract` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Contract = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  contractTitle?: Maybe<Scalars['String']>;
  contractValue?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  renewalReminder?: Maybe<Scalars['String']>;
  customerSignedDate?: Maybe<Scalars['String']>;
  companySignedDate?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  contractManager?: Maybe<Scalars['String']>;
  account?: Maybe<Scalars['String']>;
  contact?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  opportunity?: Maybe<Scalars['String']>;
  contractType?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  lineItems?: Maybe<Scalars['String']>;
  total?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['String']>;
  subtotal?: Maybe<Scalars['String']>;
  shipping?: Maybe<Scalars['String']>;
  shippingTax?: Maybe<Scalars['String']>;
  tax?: Maybe<Scalars['String']>;
  grandTotal?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** A `Contract` edge in the connection. */
export type ContractsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Contract` at the end of the edge. */
  node?: Maybe<Contract>;
};

/** Methods to use when ordering `Contract`. */
export type ContractsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CONTRACT_TITLE_ASC'
  | 'CONTRACT_TITLE_DESC'
  | 'CONTRACT_VALUE_ASC'
  | 'CONTRACT_VALUE_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'RENEWAL_REMINDER_ASC'
  | 'RENEWAL_REMINDER_DESC'
  | 'CUSTOMER_SIGNED_DATE_ASC'
  | 'CUSTOMER_SIGNED_DATE_DESC'
  | 'COMPANY_SIGNED_DATE_ASC'
  | 'COMPANY_SIGNED_DATE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'CONTRACT_MANAGER_ASC'
  | 'CONTRACT_MANAGER_DESC'
  | 'ACCOUNT_ASC'
  | 'ACCOUNT_DESC'
  | 'CONTACT_ASC'
  | 'CONTACT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'OPPORTUNITY_ASC'
  | 'OPPORTUNITY_DESC'
  | 'CONTRACT_TYPE_ASC'
  | 'CONTRACT_TYPE_DESC'
  | 'CURRENCY_ASC'
  | 'CURRENCY_DESC'
  | 'LINE_ITEMS_ASC'
  | 'LINE_ITEMS_DESC'
  | 'TOTAL_ASC'
  | 'TOTAL_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'SUBTOTAL_ASC'
  | 'SUBTOTAL_DESC'
  | 'SHIPPING_ASC'
  | 'SHIPPING_DESC'
  | 'SHIPPING_TAX_ASC'
  | 'SHIPPING_TAX_DESC'
  | 'TAX_ASC'
  | 'TAX_DESC'
  | 'GRAND_TOTAL_ASC'
  | 'GRAND_TOTAL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Contract` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ContractCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `contractTitle` field. */
  contractTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `contractValue` field. */
  contractValue?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `renewalReminder` field. */
  renewalReminder?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerSignedDate` field. */
  customerSignedDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `companySignedDate` field. */
  companySignedDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `contractManager` field. */
  contractManager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `account` field. */
  account?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `contact` field. */
  contact?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `opportunity` field. */
  opportunity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `contractType` field. */
  contractType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lineItems` field. */
  lineItems?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `total` field. */
  total?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `discount` field. */
  discount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `subtotal` field. */
  subtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipping` field. */
  shipping?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingTax` field. */
  shippingTax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tax` field. */
  tax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `grandTotal` field. */
  grandTotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Country` values. */
export type CountriesConnection = {
  /** A list of `Country` objects. */
  nodes: Array<Maybe<Country>>;
  /** A list of edges which contains the `Country` and cursor to aid in pagination. */
  edges: Array<CountriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Country` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Country = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
};

/** A `Country` edge in the connection. */
export type CountriesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Country` at the end of the edge. */
  node?: Maybe<Country>;
};

/** Methods to use when ordering `Country`. */
export type CountriesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CountryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `region` field. */
  region?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Coupon` values. */
export type CouponsConnection = {
  /** A list of `Coupon` objects. */
  nodes: Array<Maybe<Coupon>>;
  /** A list of edges which contains the `Coupon` and cursor to aid in pagination. */
  edges: Array<CouponsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Coupon` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Coupon = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  expiration?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  productsCouponsToproducts?: Maybe<Scalars['String']>;
};

/** A `Coupon` edge in the connection. */
export type CouponsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Coupon` at the end of the edge. */
  node?: Maybe<Coupon>;
};

/** Methods to use when ordering `Coupon`. */
export type CouponsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_COUPONS_TOPRODUCTS_ASC'
  | 'PRODUCTS_COUPONS_TOPRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Coupon` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CouponCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `discount` field. */
  discount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `expiration` field. */
  expiration?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productsCouponsToproducts` field. */
  productsCouponsToproducts?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `CreditMemo` values. */
export type CreditMemosConnection = {
  /** A list of `CreditMemo` objects. */
  nodes: Array<Maybe<CreditMemo>>;
  /** A list of edges which contains the `CreditMemo` and cursor to aid in pagination. */
  edges: Array<CreditMemosEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CreditMemo` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CreditMemo = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  creditMemo: Scalars['String'];
  orderNumber: Scalars['Int'];
  created?: Maybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  status?: Maybe<Scalars['String']>;
  refunded?: Maybe<Scalars['String']>;
  action?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  customers?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
};

/** A `CreditMemo` edge in the connection. */
export type CreditMemosEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CreditMemo` at the end of the edge. */
  node?: Maybe<CreditMemo>;
};

/** Methods to use when ordering `CreditMemo`. */
export type CreditMemosOrderBy =
  | 'NATURAL'
  | 'CREDIT_MEMO_ASC'
  | 'CREDIT_MEMO_DESC'
  | 'ORDER_NUMBER_ASC'
  | 'ORDER_NUMBER_DESC'
  | 'CREATED_ASC'
  | 'CREATED_DESC'
  | 'BILL_TO_NAME_ASC'
  | 'BILL_TO_NAME_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'REFUNDED_ASC'
  | 'REFUNDED_DESC'
  | 'ACTION_ASC'
  | 'ACTION_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CreditMemo` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CreditMemoCondition = {
  /** Checks for equality with the object’s `creditMemo` field. */
  creditMemo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderNumber` field. */
  orderNumber?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `billToName` field. */
  billToName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `refunded` field. */
  refunded?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `action` field. */
  action?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Currency` values. */
export type CurrenciesConnection = {
  /** A list of `Currency` objects. */
  nodes: Array<Maybe<Currency>>;
  /** A list of edges which contains the `Currency` and cursor to aid in pagination. */
  edges: Array<CurrenciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Currency` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Currency = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
};

/** A `Currency` edge in the connection. */
export type CurrenciesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Currency` at the end of the edge. */
  node?: Maybe<Currency>;
};

/** Methods to use when ordering `Currency`. */
export type CurrenciesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Currency` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CurrencyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `region` field. */
  region?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `CurrencyRate` values. */
export type CurrencyRatesConnection = {
  /** A list of `CurrencyRate` objects. */
  nodes: Array<Maybe<CurrencyRate>>;
  /** A list of edges which contains the `CurrencyRate` and cursor to aid in pagination. */
  edges: Array<CurrencyRatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CurrencyRate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CurrencyRate = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  importService: Scalars['String'];
  usd?: Maybe<Scalars['BigFloat']>;
  id: Scalars['BigInt'];
};

/** A `CurrencyRate` edge in the connection. */
export type CurrencyRatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CurrencyRate` at the end of the edge. */
  node?: Maybe<CurrencyRate>;
};

/** Methods to use when ordering `CurrencyRate`. */
export type CurrencyRatesOrderBy =
  | 'NATURAL'
  | 'IMPORT_SERVICE_ASC'
  | 'IMPORT_SERVICE_DESC'
  | 'USD_ASC'
  | 'USD_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CurrencyRate` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CurrencyRateCondition = {
  /** Checks for equality with the object’s `importService` field. */
  importService?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `usd` field. */
  usd?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `CurrencySymbol` values. */
export type CurrencySymbolsConnection = {
  /** A list of `CurrencySymbol` objects. */
  nodes: Array<Maybe<CurrencySymbol>>;
  /** A list of edges which contains the `CurrencySymbol` and cursor to aid in pagination. */
  edges: Array<CurrencySymbolsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CurrencySymbol` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CurrencySymbol = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  symbol: Scalars['String'];
  useStandard?: Maybe<Scalars['Boolean']>;
  id: Scalars['BigInt'];
};

/** A `CurrencySymbol` edge in the connection. */
export type CurrencySymbolsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CurrencySymbol` at the end of the edge. */
  node?: Maybe<CurrencySymbol>;
};

/** Methods to use when ordering `CurrencySymbol`. */
export type CurrencySymbolsOrderBy =
  | 'NATURAL'
  | 'SYMBOL_ASC'
  | 'SYMBOL_DESC'
  | 'USE_STANDARD_ASC'
  | 'USE_STANDARD_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CurrencySymbol` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CurrencySymbolCondition = {
  /** Checks for equality with the object’s `symbol` field. */
  symbol?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `useStandard` field. */
  useStandard?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `CustomerGroup` values. */
export type CustomerGroupsConnection = {
  /** A list of `CustomerGroup` objects. */
  nodes: Array<Maybe<CustomerGroup>>;
  /** A list of edges which contains the `CustomerGroup` and cursor to aid in pagination. */
  edges: Array<CustomerGroupsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CustomerGroup = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  taxClass?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  customers?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  coverPhoto?: Maybe<Scalars['String']>;
};

/** A `CustomerGroup` edge in the connection. */
export type CustomerGroupsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerGroup` at the end of the edge. */
  node?: Maybe<CustomerGroup>;
};

/** Methods to use when ordering `CustomerGroup`. */
export type CustomerGroupsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'TAX_CLASS_ASC'
  | 'TAX_CLASS_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'COVER_PHOTO_ASC'
  | 'COVER_PHOTO_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CustomerGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CustomerGroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taxClass` field. */
  taxClass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `coverPhoto` field. */
  coverPhoto?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Customer` values. */
export type CustomersConnection = {
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer` and cursor to aid in pagination. */
  edges: Array<CustomersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Customer = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  thumbnail?: Maybe<Scalars['String']>;
  namePrefix?: Maybe<Scalars['String']>;
  firstName: Scalars['String'];
  middleName?: Maybe<Scalars['String']>;
  lastName: Scalars['String'];
  email: Scalars['String'];
  customerGroup?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  zipcode?: Maybe<Scalars['String']>;
  nameSuffix?: Maybe<Scalars['String']>;
  websites?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  customerSince?: Maybe<Scalars['Datetime']>;
  confirmedEmail?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['String']>;
  taxVatNumber?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  addressTwo?: Maybe<Scalars['String']>;
  paymentType?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  creditMemos?: Maybe<Scalars['String']>;
  customerPayment?: Maybe<Scalars['String']>;
  emails?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  messages?: Maybe<Scalars['String']>;
  newsletterSubscribers?: Maybe<Scalars['String']>;
  orders?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  quotes?: Maybe<Scalars['String']>;
  returns?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Customer` edge in the connection. */
export type CustomersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};

/** Methods to use when ordering `Customer`. */
export type CustomersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'THUMBNAIL_ASC'
  | 'THUMBNAIL_DESC'
  | 'NAME_PREFIX_ASC'
  | 'NAME_PREFIX_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'MIDDLE_NAME_ASC'
  | 'MIDDLE_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'CUSTOMER_GROUP_ASC'
  | 'CUSTOMER_GROUP_DESC'
  | 'PHONE_ASC'
  | 'PHONE_DESC'
  | 'ZIPCODE_ASC'
  | 'ZIPCODE_DESC'
  | 'NAME_SUFFIX_ASC'
  | 'NAME_SUFFIX_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'CUSTOMER_SINCE_ASC'
  | 'CUSTOMER_SINCE_DESC'
  | 'CONFIRMED_EMAIL_ASC'
  | 'CONFIRMED_EMAIL_DESC'
  | 'DATE_OF_BIRTH_ASC'
  | 'DATE_OF_BIRTH_DESC'
  | 'TAX_VAT_NUMBER_ASC'
  | 'TAX_VAT_NUMBER_DESC'
  | 'GENDER_ASC'
  | 'GENDER_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'SHORT_DESCRIPTION_ASC'
  | 'SHORT_DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'ADDRESS_TWO_ASC'
  | 'ADDRESS_TWO_DESC'
  | 'PAYMENT_TYPE_ASC'
  | 'PAYMENT_TYPE_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC'
  | 'PASSWORD_ASC'
  | 'PASSWORD_DESC'
  | 'COMMENTS_ASC'
  | 'COMMENTS_DESC'
  | 'CREDIT_MEMOS_ASC'
  | 'CREDIT_MEMOS_DESC'
  | 'CUSTOMER_PAYMENT_ASC'
  | 'CUSTOMER_PAYMENT_DESC'
  | 'EMAILS_ASC'
  | 'EMAILS_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'MESSAGES_ASC'
  | 'MESSAGES_DESC'
  | 'NEWSLETTER_SUBSCRIBERS_ASC'
  | 'NEWSLETTER_SUBSCRIBERS_DESC'
  | 'ORDERS_ASC'
  | 'ORDERS_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'QUOTES_ASC'
  | 'QUOTES_DESC'
  | 'RETURNS_ASC'
  | 'RETURNS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Customer` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CustomerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `thumbnail` field. */
  thumbnail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `namePrefix` field. */
  namePrefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `middleName` field. */
  middleName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerGroup` field. */
  customerGroup?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipcode` field. */
  zipcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `nameSuffix` field. */
  nameSuffix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerSince` field. */
  customerSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `confirmedEmail` field. */
  confirmedEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taxVatNumber` field. */
  taxVatNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gender` field. */
  gender?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `addressTwo` field. */
  addressTwo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `paymentType` field. */
  paymentType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `password` field. */
  password?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `comments` field. */
  comments?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `creditMemos` field. */
  creditMemos?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerPayment` field. */
  customerPayment?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `emails` field. */
  emails?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `messages` field. */
  messages?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `newsletterSubscribers` field. */
  newsletterSubscribers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `orders` field. */
  orders?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `quotes` field. */
  quotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `returns` field. */
  returns?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Customization` values. */
export type CustomizationsConnection = {
  /** A list of `Customization` objects. */
  nodes: Array<Maybe<Customization>>;
  /** A list of edges which contains the `Customization` and cursor to aid in pagination. */
  edges: Array<CustomizationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customization` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Customization = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  createdAt?: Maybe<Scalars['Datetime']>;
  siteName?: Maybe<Scalars['String']>;
  navLink?: Maybe<Scalars['String']>;
  notification?: Maybe<Scalars['String']>;
  banner?: Maybe<Scalars['String']>;
  footerLink?: Maybe<Scalars['String']>;
  announcement?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  siteUrl?: Maybe<Scalars['String']>;
  allowSignup?: Maybe<Scalars['String']>;
};

/** A `Customization` edge in the connection. */
export type CustomizationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customization` at the end of the edge. */
  node?: Maybe<Customization>;
};

/** Methods to use when ordering `Customization`. */
export type CustomizationsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SITE_NAME_ASC'
  | 'SITE_NAME_DESC'
  | 'NAV_LINK_ASC'
  | 'NAV_LINK_DESC'
  | 'NOTIFICATION_ASC'
  | 'NOTIFICATION_DESC'
  | 'BANNER_ASC'
  | 'BANNER_DESC'
  | 'FOOTER_LINK_ASC'
  | 'FOOTER_LINK_DESC'
  | 'ANNOUNCEMENT_ASC'
  | 'ANNOUNCEMENT_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'SITE_URL_ASC'
  | 'SITE_URL_DESC'
  | 'ALLOW_SIGNUP_ASC'
  | 'ALLOW_SIGNUP_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Customization` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CustomizationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `siteName` field. */
  siteName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `navLink` field. */
  navLink?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `notification` field. */
  notification?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `banner` field. */
  banner?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `footerLink` field. */
  footerLink?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `announcement` field. */
  announcement?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `siteUrl` field. */
  siteUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `allowSignup` field. */
  allowSignup?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Dashboard` values. */
export type DashboardsConnection = {
  /** A list of `Dashboard` objects. */
  nodes: Array<Maybe<Dashboard>>;
  /** A list of edges which contains the `Dashboard` and cursor to aid in pagination. */
  edges: Array<DashboardsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Dashboard` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Dashboard = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  privacy?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  task?: Maybe<Scalars['String']>;
  reports?: Maybe<Scalars['String']>;
  tasks?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  tickets?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  checklists?: Maybe<Scalars['String']>;
  visits?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  sales?: Maybe<Scalars['String']>;
};

/** A `Dashboard` edge in the connection. */
export type DashboardsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Dashboard` at the end of the edge. */
  node?: Maybe<Dashboard>;
};

/** Methods to use when ordering `Dashboard`. */
export type DashboardsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'PRIVACY_ASC'
  | 'PRIVACY_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'TASK_ASC'
  | 'TASK_DESC'
  | 'REPORTS_ASC'
  | 'REPORTS_DESC'
  | 'TASKS_ASC'
  | 'TASKS_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'TICKETS_ASC'
  | 'TICKETS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'CHECKLISTS_ASC'
  | 'CHECKLISTS_DESC'
  | 'VISITS_ASC'
  | 'VISITS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'SALES_ASC'
  | 'SALES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Dashboard` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DashboardCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `privacy` field. */
  privacy?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `task` field. */
  task?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `reports` field. */
  reports?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tasks` field. */
  tasks?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tickets` field. */
  tickets?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `checklists` field. */
  checklists?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `visits` field. */
  visits?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sales` field. */
  sales?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Deepdive` values. */
export type DeepdivesConnection = {
  /** A list of `Deepdive` objects. */
  nodes: Array<Maybe<Deepdive>>;
  /** A list of edges which contains the `Deepdive` and cursor to aid in pagination. */
  edges: Array<DeepdivesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Deepdive` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Deepdive = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  attendees?: Maybe<Scalars['String']>;
  login?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  whid?: Maybe<Scalars['String']>;
};

/** A `Deepdive` edge in the connection. */
export type DeepdivesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Deepdive` at the end of the edge. */
  node?: Maybe<Deepdive>;
};

/** Methods to use when ordering `Deepdive`. */
export type DeepdivesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'ATTENDEES_ASC'
  | 'ATTENDEES_DESC'
  | 'LOGIN_ASC'
  | 'LOGIN_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'WHID_ASC'
  | 'WHID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Deepdive` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DeepdiveCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `attendees` field. */
  attendees?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `login` field. */
  login?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `whid` field. */
  whid?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Digiboard` values. */
export type DigiboardsConnection = {
  /** A list of `Digiboard` objects. */
  nodes: Array<Maybe<Digiboard>>;
  /** A list of edges which contains the `Digiboard` and cursor to aid in pagination. */
  edges: Array<DigiboardsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Digiboard` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Digiboard = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  board?: Maybe<Scalars['String']>;
  createdAt: Scalars['Datetime'];
  student?: Maybe<Scalars['String']>;
  course?: Maybe<Scalars['String']>;
};

/** A `Digiboard` edge in the connection. */
export type DigiboardsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Digiboard` at the end of the edge. */
  node?: Maybe<Digiboard>;
};

/** Methods to use when ordering `Digiboard`. */
export type DigiboardsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'BOARD_ASC'
  | 'BOARD_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'STUDENT_ASC'
  | 'STUDENT_DESC'
  | 'COURSE_ASC'
  | 'COURSE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Digiboard` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DigiboardCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `board` field. */
  board?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `student` field. */
  student?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `course` field. */
  course?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Email` values. */
export type EmailsConnection = {
  /** A list of `Email` objects. */
  nodes: Array<Maybe<Email>>;
  /** A list of edges which contains the `Email` and cursor to aid in pagination. */
  edges: Array<EmailsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Email` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Email = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  createdAt?: Maybe<Scalars['Datetime']>;
  subject?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  bcc?: Maybe<Scalars['String']>;
  cc?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  staffId?: Maybe<Scalars['Int']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Email` edge in the connection. */
export type EmailsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Email` at the end of the edge. */
  node?: Maybe<Email>;
};

/** Methods to use when ordering `Email`. */
export type EmailsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'BCC_ASC'
  | 'BCC_DESC'
  | 'CC_ASC'
  | 'CC_DESC'
  | 'FROM_ASC'
  | 'FROM_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'STAFF_ID_ASC'
  | 'STAFF_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Email` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EmailCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `bcc` field. */
  bcc?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `cc` field. */
  cc?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `from` field. */
  from?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `staffId` field. */
  staffId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Endofshift` values. */
export type EndofshiftsConnection = {
  /** A list of `Endofshift` objects. */
  nodes: Array<Maybe<Endofshift>>;
  /** A list of edges which contains the `Endofshift` and cursor to aid in pagination. */
  edges: Array<EndofshiftsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Endofshift` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Endofshift = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  content?: Maybe<Scalars['String']>;
  login?: Maybe<Scalars['String']>;
  mcms?: Maybe<Scalars['String']>;
  nextShift?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  tickets?: Maybe<Scalars['String']>;
  whid?: Maybe<Scalars['String']>;
};

/** A `Endofshift` edge in the connection. */
export type EndofshiftsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Endofshift` at the end of the edge. */
  node?: Maybe<Endofshift>;
};

/** Methods to use when ordering `Endofshift`. */
export type EndofshiftsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'LOGIN_ASC'
  | 'LOGIN_DESC'
  | 'MCMS_ASC'
  | 'MCMS_DESC'
  | 'NEXT_SHIFT_ASC'
  | 'NEXT_SHIFT_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'TICKETS_ASC'
  | 'TICKETS_DESC'
  | 'WHID_ASC'
  | 'WHID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Endofshift` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type EndofshiftCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `login` field. */
  login?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mcms` field. */
  mcms?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `nextShift` field. */
  nextShift?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tickets` field. */
  tickets?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `whid` field. */
  whid?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  /** A list of `Event` objects. */
  nodes: Array<Maybe<Event>>;
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Event = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  tickets?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  start?: Maybe<Scalars['String']>;
  end?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  postalcode?: Maybe<Scalars['String']>;
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node?: Maybe<Event>;
};

/** Methods to use when ordering `Event`. */
export type EventsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'TICKETS_ASC'
  | 'TICKETS_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'START_ASC'
  | 'START_DESC'
  | 'END_ASC'
  | 'END_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'POSTALCODE_ASC'
  | 'POSTALCODE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tickets` field. */
  tickets?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `start` field. */
  start?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `end` field. */
  end?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalcode` field. */
  postalcode?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Fullfillment` values. */
export type FullfillmentsConnection = {
  /** A list of `Fullfillment` objects. */
  nodes: Array<Maybe<Fullfillment>>;
  /** A list of edges which contains the `Fullfillment` and cursor to aid in pagination. */
  edges: Array<FullfillmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Fullfillment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Fullfillment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  shippingZones?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  addressTwo?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  zipcode?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  countryArea?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  pickup?: Maybe<Scalars['String']>;
  stock?: Maybe<Scalars['String']>;
};

/** A `Fullfillment` edge in the connection. */
export type FullfillmentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Fullfillment` at the end of the edge. */
  node?: Maybe<Fullfillment>;
};

/** Methods to use when ordering `Fullfillment`. */
export type FullfillmentsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'SHIPPING_ZONES_ASC'
  | 'SHIPPING_ZONES_DESC'
  | 'COMPANY_ASC'
  | 'COMPANY_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'ADDRESS_TWO_ASC'
  | 'ADDRESS_TWO_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'ZIPCODE_ASC'
  | 'ZIPCODE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'COUNTRY_AREA_ASC'
  | 'COUNTRY_AREA_DESC'
  | 'PHONE_ASC'
  | 'PHONE_DESC'
  | 'PICKUP_ASC'
  | 'PICKUP_DESC'
  | 'STOCK_ASC'
  | 'STOCK_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Fullfillment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FullfillmentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingZones` field. */
  shippingZones?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `company` field. */
  company?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `addressTwo` field. */
  addressTwo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipcode` field. */
  zipcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryArea` field. */
  countryArea?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pickup` field. */
  pickup?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `stock` field. */
  stock?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `GiftCertificate` values. */
export type GiftCertificatesConnection = {
  /** A list of `GiftCertificate` objects. */
  nodes: Array<Maybe<GiftCertificate>>;
  /** A list of edges which contains the `GiftCertificate` and cursor to aid in pagination. */
  edges: Array<GiftCertificatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GiftCertificate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type GiftCertificate = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  specialOffers?: Maybe<Scalars['String']>;
  rewards?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  expiration?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** A `GiftCertificate` edge in the connection. */
export type GiftCertificatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `GiftCertificate` at the end of the edge. */
  node?: Maybe<GiftCertificate>;
};

/** Methods to use when ordering `GiftCertificate`. */
export type GiftCertificatesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'SPECIAL_OFFERS_ASC'
  | 'SPECIAL_OFFERS_DESC'
  | 'REWARDS_ASC'
  | 'REWARDS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `GiftCertificate` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GiftCertificateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `discount` field. */
  discount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `specialOffers` field. */
  specialOffers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `rewards` field. */
  rewards?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `expiration` field. */
  expiration?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Glossary` values. */
export type GlossariesConnection = {
  /** A list of `Glossary` objects. */
  nodes: Array<Maybe<Glossary>>;
  /** A list of edges which contains the `Glossary` and cursor to aid in pagination. */
  edges: Array<GlossariesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Glossary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Glossary = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  content?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
};

/** A `Glossary` edge in the connection. */
export type GlossariesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Glossary` at the end of the edge. */
  node?: Maybe<Glossary>;
};

/** Methods to use when ordering `Glossary`. */
export type GlossariesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Glossary` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GlossaryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Importm` values. */
export type ImportmsConnection = {
  /** A list of `Importm` objects. */
  nodes: Array<Maybe<Importm>>;
  /** A list of edges which contains the `Importm` and cursor to aid in pagination. */
  edges: Array<ImportmsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Importm` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Importm = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
};

/** A `Importm` edge in the connection. */
export type ImportmsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Importm` at the end of the edge. */
  node?: Maybe<Importm>;
};

/** Methods to use when ordering `Importm`. */
export type ImportmsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'FILE_ASC'
  | 'FILE_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Importm` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ImportmCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `file` field. */
  file?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Integration` values. */
export type IntegrationsConnection = {
  /** A list of `Integration` objects. */
  nodes: Array<Maybe<Integration>>;
  /** A list of edges which contains the `Integration` and cursor to aid in pagination. */
  edges: Array<IntegrationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Integration` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Integration = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
};

/** A `Integration` edge in the connection. */
export type IntegrationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Integration` at the end of the edge. */
  node?: Maybe<Integration>;
};

/** Methods to use when ordering `Integration`. */
export type IntegrationsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Integration` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type IntegrationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Internalization` values. */
export type InternalizationsConnection = {
  /** A list of `Internalization` objects. */
  nodes: Array<Maybe<Internalization>>;
  /** A list of edges which contains the `Internalization` and cursor to aid in pagination. */
  edges: Array<InternalizationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Internalization` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Internalization = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  default?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
};

/** A `Internalization` edge in the connection. */
export type InternalizationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Internalization` at the end of the edge. */
  node?: Maybe<Internalization>;
};

/** Methods to use when ordering `Internalization`. */
export type InternalizationsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'DEFAULT_ASC'
  | 'DEFAULT_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Internalization` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InternalizationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `region` field. */
  region?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `default` field. */
  default?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Invitation` values. */
export type InvitationsConnection = {
  /** A list of `Invitation` objects. */
  nodes: Array<Maybe<Invitation>>;
  /** A list of edges which contains the `Invitation` and cursor to aid in pagination. */
  edges: Array<InvitationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Invitation` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Invitation = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  invoiceDate?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  billingAddress?: Maybe<Scalars['String']>;
  shippingAddress?: Maybe<Scalars['String']>;
  orderNumber?: Maybe<Scalars['String']>;
  grandTotalPurchased?: Maybe<Scalars['String']>;
  paymentMethod?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
};

/** A `Invitation` edge in the connection. */
export type InvitationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Invitation` at the end of the edge. */
  node?: Maybe<Invitation>;
};

/** Methods to use when ordering `Invitation`. */
export type InvitationsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'INVOICE_DATE_ASC'
  | 'INVOICE_DATE_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'BILLING_ADDRESS_ASC'
  | 'BILLING_ADDRESS_DESC'
  | 'SHIPPING_ADDRESS_ASC'
  | 'SHIPPING_ADDRESS_DESC'
  | 'ORDER_NUMBER_ASC'
  | 'ORDER_NUMBER_DESC'
  | 'GRAND_TOTAL_PURCHASED_ASC'
  | 'GRAND_TOTAL_PURCHASED_DESC'
  | 'PAYMENT_METHOD_ASC'
  | 'PAYMENT_METHOD_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Invitation` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type InvitationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `invoiceDate` field. */
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `billingAddress` field. */
  billingAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingAddress` field. */
  shippingAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderNumber` field. */
  orderNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `grandTotalPurchased` field. */
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `paymentMethod` field. */
  paymentMethod?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Invoice` values. */
export type InvoicesConnection = {
  /** A list of `Invoice` objects. */
  nodes: Array<Maybe<Invoice>>;
  /** A list of edges which contains the `Invoice` and cursor to aid in pagination. */
  edges: Array<InvoicesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Invoice` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Invoice = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  invoice: Scalars['Int'];
  orderNumber: Scalars['BigInt'];
  invoiceDate?: Maybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  billingAddress?: Maybe<Scalars['String']>;
  grandTotalBase?: Maybe<Scalars['String']>;
  grandTotalPurchased?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  shippingAddress?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  customerGroup?: Maybe<Scalars['String']>;
  paymentMethod?: Maybe<Scalars['String']>;
  shippingInformation?: Maybe<Scalars['String']>;
  subtotal?: Maybe<Scalars['String']>;
  shippingAndHandling?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** A `Invoice` edge in the connection. */
export type InvoicesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Invoice` at the end of the edge. */
  node?: Maybe<Invoice>;
};

/** Methods to use when ordering `Invoice`. */
export type InvoicesOrderBy =
  | 'NATURAL'
  | 'INVOICE_ASC'
  | 'INVOICE_DESC'
  | 'ORDER_NUMBER_ASC'
  | 'ORDER_NUMBER_DESC'
  | 'INVOICE_DATE_ASC'
  | 'INVOICE_DATE_DESC'
  | 'BILL_TO_NAME_ASC'
  | 'BILL_TO_NAME_DESC'
  | 'BILLING_ADDRESS_ASC'
  | 'BILLING_ADDRESS_DESC'
  | 'GRAND_TOTAL_BASE_ASC'
  | 'GRAND_TOTAL_BASE_DESC'
  | 'GRAND_TOTAL_PURCHASED_ASC'
  | 'GRAND_TOTAL_PURCHASED_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'SHIPPING_ADDRESS_ASC'
  | 'SHIPPING_ADDRESS_DESC'
  | 'CUSTOMER_NAME_ASC'
  | 'CUSTOMER_NAME_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'CUSTOMER_GROUP_ASC'
  | 'CUSTOMER_GROUP_DESC'
  | 'PAYMENT_METHOD_ASC'
  | 'PAYMENT_METHOD_DESC'
  | 'SHIPPING_INFORMATION_ASC'
  | 'SHIPPING_INFORMATION_DESC'
  | 'SUBTOTAL_ASC'
  | 'SUBTOTAL_DESC'
  | 'SHIPPING_AND_HANDLING_ASC'
  | 'SHIPPING_AND_HANDLING_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Invoice` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type InvoiceCondition = {
  /** Checks for equality with the object’s `invoice` field. */
  invoice?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `orderNumber` field. */
  orderNumber?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `invoiceDate` field. */
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `billToName` field. */
  billToName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `billingAddress` field. */
  billingAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `grandTotalBase` field. */
  grandTotalBase?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `grandTotalPurchased` field. */
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingAddress` field. */
  shippingAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerName` field. */
  customerName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerGroup` field. */
  customerGroup?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `paymentMethod` field. */
  paymentMethod?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingInformation` field. */
  shippingInformation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `subtotal` field. */
  subtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingAndHandling` field. */
  shippingAndHandling?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Lead` values. */
export type LeadsConnection = {
  /** A list of `Lead` objects. */
  nodes: Array<Maybe<Lead>>;
  /** A list of edges which contains the `Lead` and cursor to aid in pagination. */
  edges: Array<LeadsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Lead` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Lead = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  prefix?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  department?: Maybe<Scalars['String']>;
  accountName?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  postalcode?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  fax?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  mobile?: Maybe<Scalars['String']>;
  jobTitle?: Maybe<Scalars['String']>;
  altAddress?: Maybe<Scalars['String']>;
  altPostalcode?: Maybe<Scalars['String']>;
  altCity?: Maybe<Scalars['String']>;
  altState?: Maybe<Scalars['String']>;
  altCountry?: Maybe<Scalars['String']>;
  officePhone?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  statusDescription?: Maybe<Scalars['String']>;
  opportunityAmount?: Maybe<Scalars['String']>;
  campaign?: Maybe<Scalars['String']>;
  leadSource?: Maybe<Scalars['String']>;
  leadSourceDescription?: Maybe<Scalars['String']>;
  referredBy?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
};

/** A `Lead` edge in the connection. */
export type LeadsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Lead` at the end of the edge. */
  node?: Maybe<Lead>;
};

/** Methods to use when ordering `Lead`. */
export type LeadsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'PREFIX_ASC'
  | 'PREFIX_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'DEPARTMENT_ASC'
  | 'DEPARTMENT_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'POSTALCODE_ASC'
  | 'POSTALCODE_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'FAX_ASC'
  | 'FAX_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'MOBILE_ASC'
  | 'MOBILE_DESC'
  | 'JOB_TITLE_ASC'
  | 'JOB_TITLE_DESC'
  | 'ALT_ADDRESS_ASC'
  | 'ALT_ADDRESS_DESC'
  | 'ALT_POSTALCODE_ASC'
  | 'ALT_POSTALCODE_DESC'
  | 'ALT_CITY_ASC'
  | 'ALT_CITY_DESC'
  | 'ALT_STATE_ASC'
  | 'ALT_STATE_DESC'
  | 'ALT_COUNTRY_ASC'
  | 'ALT_COUNTRY_DESC'
  | 'OFFICE_PHONE_ASC'
  | 'OFFICE_PHONE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'STATUS_DESCRIPTION_ASC'
  | 'STATUS_DESCRIPTION_DESC'
  | 'OPPORTUNITY_AMOUNT_ASC'
  | 'OPPORTUNITY_AMOUNT_DESC'
  | 'CAMPAIGN_ASC'
  | 'CAMPAIGN_DESC'
  | 'LEAD_SOURCE_ASC'
  | 'LEAD_SOURCE_DESC'
  | 'LEAD_SOURCE_DESCRIPTION_ASC'
  | 'LEAD_SOURCE_DESCRIPTION_DESC'
  | 'REFERRED_BY_ASC'
  | 'REFERRED_BY_DESC'
  | 'CUSTOMER_NAME_ASC'
  | 'CUSTOMER_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Lead` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LeadCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `prefix` field. */
  prefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `department` field. */
  department?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalcode` field. */
  postalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `fax` field. */
  fax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mobile` field. */
  mobile?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `jobTitle` field. */
  jobTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altAddress` field. */
  altAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altPostalcode` field. */
  altPostalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altCity` field. */
  altCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altState` field. */
  altState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altCountry` field. */
  altCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `officePhone` field. */
  officePhone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `statusDescription` field. */
  statusDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `opportunityAmount` field. */
  opportunityAmount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `campaign` field. */
  campaign?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `leadSource` field. */
  leadSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `leadSourceDescription` field. */
  leadSourceDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `referredBy` field. */
  referredBy?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerName` field. */
  customerName?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Manufacturer` values. */
export type ManufacturersConnection = {
  /** A list of `Manufacturer` objects. */
  nodes: Array<Maybe<Manufacturer>>;
  /** A list of edges which contains the `Manufacturer` and cursor to aid in pagination. */
  edges: Array<ManufacturersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Manufacturer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Manufacturer = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['BigInt']>;
  description?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
};

/** A `Manufacturer` edge in the connection. */
export type ManufacturersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Manufacturer` at the end of the edge. */
  node?: Maybe<Manufacturer>;
};

/** Methods to use when ordering `Manufacturer`. */
export type ManufacturersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Manufacturer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ManufacturerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `product` field. */
  product?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Mediamanager` values. */
export type MediamanagersConnection = {
  /** A list of `Mediamanager` objects. */
  nodes: Array<Maybe<Mediamanager>>;
  /** A list of edges which contains the `Mediamanager` and cursor to aid in pagination. */
  edges: Array<MediamanagersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Mediamanager` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Mediamanager = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  keywords?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  brands?: Maybe<Scalars['BigInt']>;
  status?: Maybe<Scalars['String']>;
  expirationDate?: Maybe<Scalars['String']>;
  copyright?: Maybe<Scalars['String']>;
  dimensions?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['Int']>;
  contentType?: Maybe<Scalars['String']>;
  versions?: Maybe<Scalars['String']>;
  watermarkName?: Maybe<Scalars['String']>;
  watermarkDescription?: Maybe<Scalars['String']>;
  watermarkMedia?: Maybe<Scalars['String']>;
  agreements?: Maybe<Scalars['Int']>;
  albums?: Maybe<Scalars['String']>;
  comment?: Maybe<Scalars['Int']>;
  workspace?: Maybe<Scalars['String']>;
  taskName?: Maybe<Scalars['BigInt']>;
  taskDescription?: Maybe<Scalars['String']>;
  taskType?: Maybe<Scalars['String']>;
  members?: Maybe<Scalars['Int']>;
  products?: Maybe<Scalars['BigInt']>;
  agreementsAgreementsTomediamanager?: Maybe<Scalars['String']>;
  brandsBrandsTomediamanager?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  productsMediamanagerToproducts?: Maybe<Scalars['String']>;
  tasks?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Mediamanager` edge in the connection. */
export type MediamanagersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Mediamanager` at the end of the edge. */
  node?: Maybe<Mediamanager>;
};

/** Methods to use when ordering `Mediamanager`. */
export type MediamanagersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'KEYWORDS_ASC'
  | 'KEYWORDS_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'BRANDS_ASC'
  | 'BRANDS_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'EXPIRATION_DATE_ASC'
  | 'EXPIRATION_DATE_DESC'
  | 'COPYRIGHT_ASC'
  | 'COPYRIGHT_DESC'
  | 'DIMENSIONS_ASC'
  | 'DIMENSIONS_DESC'
  | 'AUTHOR_ASC'
  | 'AUTHOR_DESC'
  | 'CONTENT_TYPE_ASC'
  | 'CONTENT_TYPE_DESC'
  | 'VERSIONS_ASC'
  | 'VERSIONS_DESC'
  | 'WATERMARK_NAME_ASC'
  | 'WATERMARK_NAME_DESC'
  | 'WATERMARK_DESCRIPTION_ASC'
  | 'WATERMARK_DESCRIPTION_DESC'
  | 'WATERMARK_MEDIA_ASC'
  | 'WATERMARK_MEDIA_DESC'
  | 'AGREEMENTS_ASC'
  | 'AGREEMENTS_DESC'
  | 'ALBUMS_ASC'
  | 'ALBUMS_DESC'
  | 'COMMENT_ASC'
  | 'COMMENT_DESC'
  | 'WORKSPACE_ASC'
  | 'WORKSPACE_DESC'
  | 'TASK_NAME_ASC'
  | 'TASK_NAME_DESC'
  | 'TASK_DESCRIPTION_ASC'
  | 'TASK_DESCRIPTION_DESC'
  | 'TASK_TYPE_ASC'
  | 'TASK_TYPE_DESC'
  | 'MEMBERS_ASC'
  | 'MEMBERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'AGREEMENTS_AGREEMENTS_TOMEDIAMANAGER_ASC'
  | 'AGREEMENTS_AGREEMENTS_TOMEDIAMANAGER_DESC'
  | 'BRANDS_BRANDS_TOMEDIAMANAGER_ASC'
  | 'BRANDS_BRANDS_TOMEDIAMANAGER_DESC'
  | 'COMMENTS_ASC'
  | 'COMMENTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRODUCTS_MEDIAMANAGER_TOPRODUCTS_ASC'
  | 'PRODUCTS_MEDIAMANAGER_TOPRODUCTS_DESC'
  | 'TASKS_ASC'
  | 'TASKS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Mediamanager` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MediamanagerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `keywords` field. */
  keywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `brands` field. */
  brands?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `copyright` field. */
  copyright?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dimensions` field. */
  dimensions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `author` field. */
  author?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `contentType` field. */
  contentType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `versions` field. */
  versions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `watermarkName` field. */
  watermarkName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `watermarkDescription` field. */
  watermarkDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `watermarkMedia` field. */
  watermarkMedia?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `agreements` field. */
  agreements?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `albums` field. */
  albums?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `workspace` field. */
  workspace?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taskName` field. */
  taskName?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `taskDescription` field. */
  taskDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taskType` field. */
  taskType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `members` field. */
  members?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `agreementsAgreementsTomediamanager` field. */
  agreementsAgreementsTomediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `brandsBrandsTomediamanager` field. */
  brandsBrandsTomediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `comments` field. */
  comments?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `productsMediamanagerToproducts` field. */
  productsMediamanagerToproducts?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tasks` field. */
  tasks?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Meeting` values. */
export type MeetingsConnection = {
  /** A list of `Meeting` objects. */
  nodes: Array<Maybe<Meeting>>;
  /** A list of edges which contains the `Meeting` and cursor to aid in pagination. */
  edges: Array<MeetingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Meeting` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Meeting = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  subject?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  relatedTo?: Maybe<Scalars['String']>;
  reminders?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  invitees?: Maybe<Scalars['String']>;
  scheduling?: Maybe<Scalars['String']>;
};

/** A `Meeting` edge in the connection. */
export type MeetingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Meeting` at the end of the edge. */
  node?: Maybe<Meeting>;
};

/** Methods to use when ordering `Meeting`. */
export type MeetingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'DURATION_ASC'
  | 'DURATION_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'RELATED_TO_ASC'
  | 'RELATED_TO_DESC'
  | 'REMINDERS_ASC'
  | 'REMINDERS_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'INVITEES_ASC'
  | 'INVITEES_DESC'
  | 'SCHEDULING_ASC'
  | 'SCHEDULING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Meeting` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MeetingCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `relatedTo` field. */
  relatedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `reminders` field. */
  reminders?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `invitees` field. */
  invitees?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `scheduling` field. */
  scheduling?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Message` values. */
export type MessagesConnection = {
  /** A list of `Message` objects. */
  nodes: Array<Maybe<Message>>;
  /** A list of edges which contains the `Message` and cursor to aid in pagination. */
  edges: Array<MessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Message = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  from?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  subject?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  media?: Maybe<Scalars['String']>;
  staffId?: Maybe<Scalars['Int']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Message` edge in the connection. */
export type MessagesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Message` at the end of the edge. */
  node?: Maybe<Message>;
};

/** Methods to use when ordering `Message`. */
export type MessagesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'FROM_ASC'
  | 'FROM_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'SENDER_ASC'
  | 'SENDER_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'STAFF_ID_ASC'
  | 'STAFF_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `from` field. */
  from?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sender` field. */
  sender?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `staffId` field. */
  staffId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Newsletter` values. */
export type NewslettersConnection = {
  /** A list of `Newsletter` objects. */
  nodes: Array<Maybe<Newsletter>>;
  /** A list of edges which contains the `Newsletter` and cursor to aid in pagination. */
  edges: Array<NewslettersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Newsletter` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Newsletter = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  email: Scalars['String'];
  customerFirstName?: Maybe<Scalars['String']>;
  customerLastName?: Maybe<Scalars['String']>;
  store?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  websites?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  custId: Scalars['Int'];
  customers?: Maybe<Scalars['String']>;
};

/** A `Newsletter` edge in the connection. */
export type NewslettersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Newsletter` at the end of the edge. */
  node?: Maybe<Newsletter>;
};

/** Methods to use when ordering `Newsletter`. */
export type NewslettersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'CUSTOMER_FIRST_NAME_ASC'
  | 'CUSTOMER_FIRST_NAME_DESC'
  | 'CUSTOMER_LAST_NAME_ASC'
  | 'CUSTOMER_LAST_NAME_DESC'
  | 'STORE_ASC'
  | 'STORE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Newsletter` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type NewsletterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerFirstName` field. */
  customerFirstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerLastName` field. */
  customerLastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `store` field. */
  store?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Ooto` values. */
export type OotosConnection = {
  /** A list of `Ooto` objects. */
  nodes: Array<Maybe<Ooto>>;
  /** A list of edges which contains the `Ooto` and cursor to aid in pagination. */
  edges: Array<OotosEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Ooto` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Ooto = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  login?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  usingTime?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
};

/** A `Ooto` edge in the connection. */
export type OotosEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Ooto` at the end of the edge. */
  node?: Maybe<Ooto>;
};

/** Methods to use when ordering `Ooto`. */
export type OotosOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'LOGIN_ASC'
  | 'LOGIN_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'NOTE_ASC'
  | 'NOTE_DESC'
  | 'USING_TIME_ASC'
  | 'USING_TIME_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Ooto` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type OotoCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `login` field. */
  login?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `note` field. */
  note?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `usingTime` field. */
  usingTime?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Opportunity` values. */
export type OpportunitiesConnection = {
  /** A list of `Opportunity` objects. */
  nodes: Array<Maybe<Opportunity>>;
  /** A list of edges which contains the `Opportunity` and cursor to aid in pagination. */
  edges: Array<OpportunitiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Opportunity` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Opportunity = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['String']>;
  salesStage?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  probability?: Maybe<Scalars['String']>;
  nextStep?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  leadSource?: Maybe<Scalars['String']>;
  campaign?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  accountName?: Maybe<Scalars['String']>;
  expectedCloseDate?: Maybe<Scalars['String']>;
};

/** A `Opportunity` edge in the connection. */
export type OpportunitiesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Opportunity` at the end of the edge. */
  node?: Maybe<Opportunity>;
};

/** Methods to use when ordering `Opportunity`. */
export type OpportunitiesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'AMOUNT_ASC'
  | 'AMOUNT_DESC'
  | 'SALES_STAGE_ASC'
  | 'SALES_STAGE_DESC'
  | 'CURRENCY_ASC'
  | 'CURRENCY_DESC'
  | 'PROBABILITY_ASC'
  | 'PROBABILITY_DESC'
  | 'NEXT_STEP_ASC'
  | 'NEXT_STEP_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'LEAD_SOURCE_ASC'
  | 'LEAD_SOURCE_DESC'
  | 'CAMPAIGN_ASC'
  | 'CAMPAIGN_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'EXPECTED_CLOSE_DATE_ASC'
  | 'EXPECTED_CLOSE_DATE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Opportunity` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OpportunityCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `salesStage` field. */
  salesStage?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `probability` field. */
  probability?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `nextStep` field. */
  nextStep?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `leadSource` field. */
  leadSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `campaign` field. */
  campaign?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `expectedCloseDate` field. */
  expectedCloseDate?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Order` values. */
export type OrdersConnection = {
  /** A list of `Order` objects. */
  nodes: Array<Maybe<Order>>;
  /** A list of edges which contains the `Order` and cursor to aid in pagination. */
  edges: Array<OrdersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Order` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Order = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  purchasePoint?: Maybe<Scalars['Int']>;
  purchaseDate?: Maybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  shipToName?: Maybe<Scalars['String']>;
  grandTotalBase?: Maybe<Scalars['Int']>;
  grandTotalPurchased?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['Boolean']>;
  action?: Maybe<Scalars['Boolean']>;
  allocatedSources?: Maybe<Scalars['String']>;
  braintreeTransactionSource?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  customers?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  quotes?: Maybe<Scalars['String']>;
  transactions?: Maybe<Scalars['String']>;
};

/** A `Order` edge in the connection. */
export type OrdersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Order` at the end of the edge. */
  node?: Maybe<Order>;
};

/** Methods to use when ordering `Order`. */
export type OrdersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'PURCHASE_POINT_ASC'
  | 'PURCHASE_POINT_DESC'
  | 'PURCHASE_DATE_ASC'
  | 'PURCHASE_DATE_DESC'
  | 'BILL_TO_NAME_ASC'
  | 'BILL_TO_NAME_DESC'
  | 'SHIP_TO_NAME_ASC'
  | 'SHIP_TO_NAME_DESC'
  | 'GRAND_TOTAL_BASE_ASC'
  | 'GRAND_TOTAL_BASE_DESC'
  | 'GRAND_TOTAL_PURCHASED_ASC'
  | 'GRAND_TOTAL_PURCHASED_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'ACTION_ASC'
  | 'ACTION_DESC'
  | 'ALLOCATED_SOURCES_ASC'
  | 'ALLOCATED_SOURCES_DESC'
  | 'BRAINTREE_TRANSACTION_SOURCE_ASC'
  | 'BRAINTREE_TRANSACTION_SOURCE_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'QUOTES_ASC'
  | 'QUOTES_DESC'
  | 'TRANSACTIONS_ASC'
  | 'TRANSACTIONS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Order` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type OrderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `purchasePoint` field. */
  purchasePoint?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `purchaseDate` field. */
  purchaseDate?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `billToName` field. */
  billToName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipToName` field. */
  shipToName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `grandTotalBase` field. */
  grandTotalBase?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `grandTotalPurchased` field. */
  grandTotalPurchased?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `action` field. */
  action?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `allocatedSources` field. */
  allocatedSources?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `braintreeTransactionSource` field. */
  braintreeTransactionSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `quotes` field. */
  quotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `transactions` field. */
  transactions?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  /** A list of `Page` objects. */
  nodes: Array<Maybe<Page>>;
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Page = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  enablePage?: Maybe<Scalars['Boolean']>;
  title: Scalars['String'];
  contentTitle?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  urlKey?: Maybe<Scalars['String']>;
  metaTitle?: Maybe<Scalars['String']>;
  metaKeywords?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Page` at the end of the edge. */
  node?: Maybe<Page>;
};

/** Methods to use when ordering `Page`. */
export type PagesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'ENABLE_PAGE_ASC'
  | 'ENABLE_PAGE_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'CONTENT_TITLE_ASC'
  | 'CONTENT_TITLE_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'URL_KEY_ASC'
  | 'URL_KEY_DESC'
  | 'META_TITLE_ASC'
  | 'META_TITLE_DESC'
  | 'META_KEYWORDS_ASC'
  | 'META_KEYWORDS_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `enablePage` field. */
  enablePage?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentTitle` field. */
  contentTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `urlKey` field. */
  urlKey?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaTitle` field. */
  metaTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaKeywords` field. */
  metaKeywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Partner` values. */
export type PartnersConnection = {
  /** A list of `Partner` objects. */
  nodes: Array<Maybe<Partner>>;
  /** A list of edges which contains the `Partner` and cursor to aid in pagination. */
  edges: Array<PartnersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Partner` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Partner = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  businessType?: Maybe<Scalars['String']>;
};

/** A `Partner` edge in the connection. */
export type PartnersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Partner` at the end of the edge. */
  node?: Maybe<Partner>;
};

/** Methods to use when ordering `Partner`. */
export type PartnersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'BUSINESS_TYPE_ASC'
  | 'BUSINESS_TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Partner` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PartnerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `businessType` field. */
  businessType?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Payment` values. */
export type PaymentsConnection = {
  /** A list of `Payment` objects. */
  nodes: Array<Maybe<Payment>>;
  /** A list of edges which contains the `Payment` and cursor to aid in pagination. */
  edges: Array<PaymentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Payment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Payment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  hostUri?: Maybe<Scalars['String']>;
  redirectUrl?: Maybe<Scalars['String']>;
  redirectUrlApp?: Maybe<Scalars['String']>;
  icon?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  active?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
};

/** A `Payment` edge in the connection. */
export type PaymentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Payment` at the end of the edge. */
  node?: Maybe<Payment>;
};

/** Methods to use when ordering `Payment`. */
export type PaymentsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'HOST_URI_ASC'
  | 'HOST_URI_DESC'
  | 'REDIRECT_URL_ASC'
  | 'REDIRECT_URL_DESC'
  | 'REDIRECT_URL_APP_ASC'
  | 'REDIRECT_URL_APP_DESC'
  | 'ICON_ASC'
  | 'ICON_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Payment` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PaymentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `hostUri` field. */
  hostUri?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `redirectUrl` field. */
  redirectUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `redirectUrlApp` field. */
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `icon` field. */
  icon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Permission = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  create?: Maybe<Scalars['String']>;
  delete?: Maybe<Scalars['String']>;
  read?: Maybe<Scalars['String']>;
  role?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
};

/** Methods to use when ordering `Permission`. */
export type PermissionsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATE_ASC'
  | 'CREATE_DESC'
  | 'DELETE_ASC'
  | 'DELETE_DESC'
  | 'READ_ASC'
  | 'READ_DESC'
  | 'ROLE_ASC'
  | 'ROLE_DESC'
  | 'UPDATE_ASC'
  | 'UPDATE_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Permission` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PermissionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `create` field. */
  create?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `delete` field. */
  delete?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `read` field. */
  read?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `role` field. */
  role?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `update` field. */
  update?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Plugin` values. */
export type PluginsConnection = {
  /** A list of `Plugin` objects. */
  nodes: Array<Maybe<Plugin>>;
  /** A list of edges which contains the `Plugin` and cursor to aid in pagination. */
  edges: Array<PluginsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Plugin` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Plugin = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  githubLink?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  logo?: Maybe<Scalars['String']>;
  screenshots?: Maybe<Scalars['String']>;
  lastUpdated?: Maybe<Scalars['Datetime']>;
  publisherName?: Maybe<Scalars['String']>;
  agreeTerms?: Maybe<Scalars['Boolean']>;
  publisherEmail?: Maybe<Scalars['String']>;
};

/** A `Plugin` edge in the connection. */
export type PluginsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Plugin` at the end of the edge. */
  node?: Maybe<Plugin>;
};

/** Methods to use when ordering `Plugin`. */
export type PluginsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'GITHUB_LINK_ASC'
  | 'GITHUB_LINK_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'LOGO_ASC'
  | 'LOGO_DESC'
  | 'SCREENSHOTS_ASC'
  | 'SCREENSHOTS_DESC'
  | 'LAST_UPDATED_ASC'
  | 'LAST_UPDATED_DESC'
  | 'PUBLISHER_NAME_ASC'
  | 'PUBLISHER_NAME_DESC'
  | 'AGREE_TERMS_ASC'
  | 'AGREE_TERMS_DESC'
  | 'PUBLISHER_EMAIL_ASC'
  | 'PUBLISHER_EMAIL_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Plugin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PluginCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `githubLink` field. */
  githubLink?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `logo` field. */
  logo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `screenshots` field. */
  screenshots?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastUpdated` field. */
  lastUpdated?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `publisherName` field. */
  publisherName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `agreeTerms` field. */
  agreeTerms?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `publisherEmail` field. */
  publisherEmail?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Poll` values. */
export type PollsConnection = {
  /** A list of `Poll` objects. */
  nodes: Array<Maybe<Poll>>;
  /** A list of edges which contains the `Poll` and cursor to aid in pagination. */
  edges: Array<PollsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Poll` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Poll = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  question?: Maybe<Scalars['String']>;
  response?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Poll` edge in the connection. */
export type PollsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Poll` at the end of the edge. */
  node?: Maybe<Poll>;
};

/** Methods to use when ordering `Poll`. */
export type PollsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'QUESTION_ASC'
  | 'QUESTION_DESC'
  | 'RESPONSE_ASC'
  | 'RESPONSE_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Poll` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PollCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `question` field. */
  question?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `response` field. */
  response?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `ProductType` values. */
export type ProductTypesConnection = {
  /** A list of `ProductType` objects. */
  nodes: Array<Maybe<ProductType>>;
  /** A list of edges which contains the `ProductType` and cursor to aid in pagination. */
  edges: Array<ProductTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ProductType = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  typeName?: Maybe<Scalars['String']>;
  taxes?: Maybe<Scalars['String']>;
  isShippable?: Maybe<Scalars['String']>;
  metaUrl?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  filterOptions?: Maybe<Scalars['String']>;
  productType?: Maybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: Maybe<Scalars['String']>;
};

/** A `ProductType` edge in the connection. */
export type ProductTypesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductType` at the end of the edge. */
  node?: Maybe<ProductType>;
};

/** Methods to use when ordering `ProductType`. */
export type ProductTypesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'TYPE_NAME_ASC'
  | 'TYPE_NAME_DESC'
  | 'TAXES_ASC'
  | 'TAXES_DESC'
  | 'IS_SHIPPABLE_ASC'
  | 'IS_SHIPPABLE_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'FILTER_OPTIONS_ASC'
  | 'FILTER_OPTIONS_DESC'
  | 'PRODUCT_TYPE_ASC'
  | 'PRODUCT_TYPE_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `ProductType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ProductTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `typeName` field. */
  typeName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taxes` field. */
  taxes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isShippable` field. */
  isShippable?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `filterOptions` field. */
  filterOptions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `productType` field. */
  productType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Product` values. */
export type ProductsConnection = {
  /** A list of `Product` objects. */
  nodes: Array<Maybe<Product>>;
  /** A list of edges which contains the `Product` and cursor to aid in pagination. */
  edges: Array<ProductsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Product` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Product = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  sku: Scalars['BigInt'];
  thumbnail?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  price?: Maybe<Scalars['String']>;
  quantityPerSource?: Maybe<Scalars['String']>;
  salableQuantity?: Maybe<Scalars['String']>;
  visibility?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Boolean']>;
  websites?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  taxClass?: Maybe<Scalars['String']>;
  stockStatus?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  country?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  format?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  metaTitle?: Maybe<Scalars['String']>;
  metaKeywords?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  metaUrl?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
  manufacture?: Maybe<Scalars['String']>;
  attributes?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  contract?: Maybe<Scalars['String']>;
  costString?: Maybe<Scalars['String']>;
  customerType?: Maybe<Scalars['String']>;
  family?: Maybe<Scalars['String']>;
  manufacturerPartNumber?: Maybe<Scalars['String']>;
  occassions?: Maybe<Scalars['String']>;
  partNumber?: Maybe<Scalars['String']>;
  relatedProduct?: Maybe<Scalars['BigInt']>;
  tags?: Maybe<Scalars['String']>;
  types?: Maybe<Scalars['String']>;
  variants?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
  brands?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  creditMemos?: Maybe<Scalars['String']>;
  manufacturer?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  occassionsOccassionsToproducts?: Maybe<Scalars['String']>;
  orders?: Maybe<Scalars['String']>;
  otherProducts?: Maybe<Scalars['String']>;
  productAttribute?: Maybe<Scalars['String']>;
  productTypes?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  quotes?: Maybe<Scalars['String']>;
  rating?: Maybe<Scalars['String']>;
  returns?: Maybe<Scalars['String']>;
  taxRate?: Maybe<Scalars['String']>;
  taxRule?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Product` edge in the connection. */
export type ProductsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Product` at the end of the edge. */
  node?: Maybe<Product>;
};

/** Methods to use when ordering `Product`. */
export type ProductsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'SKU_ASC'
  | 'SKU_DESC'
  | 'THUMBNAIL_ASC'
  | 'THUMBNAIL_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'PRICE_ASC'
  | 'PRICE_DESC'
  | 'QUANTITY_PER_SOURCE_ASC'
  | 'QUANTITY_PER_SOURCE_DESC'
  | 'SALABLE_QUANTITY_ASC'
  | 'SALABLE_QUANTITY_DESC'
  | 'VISIBILITY_ASC'
  | 'VISIBILITY_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'TAX_CLASS_ASC'
  | 'TAX_CLASS_DESC'
  | 'STOCK_STATUS_ASC'
  | 'STOCK_STATUS_DESC'
  | 'WEIGHT_ASC'
  | 'WEIGHT_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'SIZE_ASC'
  | 'SIZE_DESC'
  | 'FORMAT_ASC'
  | 'FORMAT_DESC'
  | 'HEIGHT_ASC'
  | 'HEIGHT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'SHORT_DESCRIPTION_ASC'
  | 'SHORT_DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'META_TITLE_ASC'
  | 'META_TITLE_DESC'
  | 'META_KEYWORDS_ASC'
  | 'META_KEYWORDS_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'FILE_ASC'
  | 'FILE_DESC'
  | 'MANUFACTURE_ASC'
  | 'MANUFACTURE_DESC'
  | 'ATTRIBUTES_ASC'
  | 'ATTRIBUTES_DESC'
  | 'BRAND_ASC'
  | 'BRAND_DESC'
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'COST_STRING_ASC'
  | 'COST_STRING_DESC'
  | 'CUSTOMER_TYPE_ASC'
  | 'CUSTOMER_TYPE_DESC'
  | 'FAMILY_ASC'
  | 'FAMILY_DESC'
  | 'MANUFACTURER_PART_NUMBER_ASC'
  | 'MANUFACTURER_PART_NUMBER_DESC'
  | 'OCCASSIONS_ASC'
  | 'OCCASSIONS_DESC'
  | 'PART_NUMBER_ASC'
  | 'PART_NUMBER_DESC'
  | 'RELATED_PRODUCT_ASC'
  | 'RELATED_PRODUCT_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'TYPES_ASC'
  | 'TYPES_DESC'
  | 'VARIANTS_ASC'
  | 'VARIANTS_DESC'
  | 'ZONE_ASC'
  | 'ZONE_DESC'
  | 'BRANDS_ASC'
  | 'BRANDS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'CREDIT_MEMOS_ASC'
  | 'CREDIT_MEMOS_DESC'
  | 'MANUFACTURER_ASC'
  | 'MANUFACTURER_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'OCCASSIONS_OCCASSIONS_TOPRODUCTS_ASC'
  | 'OCCASSIONS_OCCASSIONS_TOPRODUCTS_DESC'
  | 'ORDERS_ASC'
  | 'ORDERS_DESC'
  | 'OTHER_PRODUCTS_ASC'
  | 'OTHER_PRODUCTS_DESC'
  | 'PRODUCT_ATTRIBUTE_ASC'
  | 'PRODUCT_ATTRIBUTE_DESC'
  | 'PRODUCT_TYPES_ASC'
  | 'PRODUCT_TYPES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'QUOTES_ASC'
  | 'QUOTES_DESC'
  | 'RATING_ASC'
  | 'RATING_DESC'
  | 'RETURNS_ASC'
  | 'RETURNS_DESC'
  | 'TAX_RATE_ASC'
  | 'TAX_RATE_DESC'
  | 'TAX_RULE_ASC'
  | 'TAX_RULE_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Product` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ProductCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sku` field. */
  sku?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `thumbnail` field. */
  thumbnail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `price` field. */
  price?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantityPerSource` field. */
  quantityPerSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `salableQuantity` field. */
  salableQuantity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `visibility` field. */
  visibility?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taxClass` field. */
  taxClass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `stockStatus` field. */
  stockStatus?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `format` field. */
  format?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `height` field. */
  height?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaTitle` field. */
  metaTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaKeywords` field. */
  metaKeywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `file` field. */
  file?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `manufacture` field. */
  manufacture?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `attributes` field. */
  attributes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `brand` field. */
  brand?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `contract` field. */
  contract?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `costString` field. */
  costString?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerType` field. */
  customerType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `family` field. */
  family?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `manufacturerPartNumber` field. */
  manufacturerPartNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `occassions` field. */
  occassions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `partNumber` field. */
  partNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `relatedProduct` field. */
  relatedProduct?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `types` field. */
  types?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `variants` field. */
  variants?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `zone` field. */
  zone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `brands` field. */
  brands?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `creditMemos` field. */
  creditMemos?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `manufacturer` field. */
  manufacturer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `occassionsOccassionsToproducts` field. */
  occassionsOccassionsToproducts?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `orders` field. */
  orders?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `otherProducts` field. */
  otherProducts?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `productAttribute` field. */
  productAttribute?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `productTypes` field. */
  productTypes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `quotes` field. */
  quotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `rating` field. */
  rating?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `returns` field. */
  returns?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taxRate` field. */
  taxRate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taxRule` field. */
  taxRule?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Project` values. */
export type ProjectsConnection = {
  /** A list of `Project` objects. */
  nodes: Array<Maybe<Project>>;
  /** A list of edges which contains the `Project` and cursor to aid in pagination. */
  edges: Array<ProjectsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Project` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Project = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  name?: Maybe<Scalars['String']>;
  projectManager?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  resource?: Maybe<Scalars['String']>;
  considerworkingdays?: Maybe<Scalars['String']>;
  projectTemplate?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  assignee?: Maybe<Scalars['String']>;
  custId?: Maybe<Scalars['Int']>;
  doing?: Maybe<Scalars['String']>;
  done?: Maybe<Scalars['String']>;
  goalCollaborators?: Maybe<Scalars['String']>;
  goalMeasurement?: Maybe<Scalars['String']>;
  goalName?: Maybe<Scalars['String']>;
  goalPrivacy?: Maybe<Scalars['String']>;
  goalProgressSource?: Maybe<Scalars['String']>;
  goalTimeperiod?: Maybe<Scalars['String']>;
  goalUpdatemethod?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  sectionRule?: Maybe<Scalars['String']>;
  staffId?: Maybe<Scalars['Int']>;
  taskId?: Maybe<Scalars['BigInt']>;
  ticketId?: Maybe<Scalars['BigInt']>;
  customers?: Maybe<Scalars['String']>;
  tasks?: Maybe<Scalars['String']>;
  ticketing?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  websites?: Maybe<Scalars['String']>;
  method?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  team?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
};

/** A `Project` edge in the connection. */
export type ProjectsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Project` at the end of the edge. */
  node?: Maybe<Project>;
};

/** Methods to use when ordering `Project`. */
export type ProjectsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'PROJECT_MANAGER_ASC'
  | 'PROJECT_MANAGER_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'RESOURCE_ASC'
  | 'RESOURCE_DESC'
  | 'CONSIDERWORKINGDAYS_ASC'
  | 'CONSIDERWORKINGDAYS_DESC'
  | 'PROJECT_TEMPLATE_ASC'
  | 'PROJECT_TEMPLATE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ASSIGNEE_ASC'
  | 'ASSIGNEE_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'DOING_ASC'
  | 'DOING_DESC'
  | 'DONE_ASC'
  | 'DONE_DESC'
  | 'GOAL_COLLABORATORS_ASC'
  | 'GOAL_COLLABORATORS_DESC'
  | 'GOAL_MEASUREMENT_ASC'
  | 'GOAL_MEASUREMENT_DESC'
  | 'GOAL_NAME_ASC'
  | 'GOAL_NAME_DESC'
  | 'GOAL_PRIVACY_ASC'
  | 'GOAL_PRIVACY_DESC'
  | 'GOAL_PROGRESS_SOURCE_ASC'
  | 'GOAL_PROGRESS_SOURCE_DESC'
  | 'GOAL_TIMEPERIOD_ASC'
  | 'GOAL_TIMEPERIOD_DESC'
  | 'GOAL_UPDATEMETHOD_ASC'
  | 'GOAL_UPDATEMETHOD_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'SECTION_RULE_ASC'
  | 'SECTION_RULE_DESC'
  | 'STAFF_ID_ASC'
  | 'STAFF_ID_DESC'
  | 'TASK_ID_ASC'
  | 'TASK_ID_DESC'
  | 'TICKET_ID_ASC'
  | 'TICKET_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'TASKS_ASC'
  | 'TASKS_DESC'
  | 'TICKETING_ASC'
  | 'TICKETING_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'METHOD_ASC'
  | 'METHOD_DESC'
  | 'ZONE_ASC'
  | 'ZONE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'TEAM_ASC'
  | 'TEAM_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'COMPANY_ASC'
  | 'COMPANY_DESC'
  | 'FILE_ASC'
  | 'FILE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ProjectCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projectManager` field. */
  projectManager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `resource` field. */
  resource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `considerworkingdays` field. */
  considerworkingdays?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projectTemplate` field. */
  projectTemplate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `assignee` field. */
  assignee?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doing` field. */
  doing?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `done` field. */
  done?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `goalCollaborators` field. */
  goalCollaborators?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `goalMeasurement` field. */
  goalMeasurement?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `goalName` field. */
  goalName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `goalPrivacy` field. */
  goalPrivacy?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `goalProgressSource` field. */
  goalProgressSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `goalTimeperiod` field. */
  goalTimeperiod?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `goalUpdatemethod` field. */
  goalUpdatemethod?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sectionRule` field. */
  sectionRule?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `staffId` field. */
  staffId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `taskId` field. */
  taskId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `ticketId` field. */
  ticketId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tasks` field. */
  tasks?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ticketing` field. */
  ticketing?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `method` field. */
  method?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `zone` field. */
  zone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `team` field. */
  team?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `company` field. */
  company?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `file` field. */
  file?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Provider` values. */
export type ProvidersConnection = {
  /** A list of `Provider` objects. */
  nodes: Array<Maybe<Provider>>;
  /** A list of edges which contains the `Provider` and cursor to aid in pagination. */
  edges: Array<ProvidersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Provider` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Provider = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  hostUri?: Maybe<Scalars['String']>;
  redirectUrl?: Maybe<Scalars['String']>;
  redirectUrlApp?: Maybe<Scalars['String']>;
  icon?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  active?: Maybe<Scalars['String']>;
};

/** A `Provider` edge in the connection. */
export type ProvidersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Provider` at the end of the edge. */
  node?: Maybe<Provider>;
};

/** Methods to use when ordering `Provider`. */
export type ProvidersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'HOST_URI_ASC'
  | 'HOST_URI_DESC'
  | 'REDIRECT_URL_ASC'
  | 'REDIRECT_URL_DESC'
  | 'REDIRECT_URL_APP_ASC'
  | 'REDIRECT_URL_APP_DESC'
  | 'ICON_ASC'
  | 'ICON_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Provider` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ProviderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `hostUri` field. */
  hostUri?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `redirectUrl` field. */
  redirectUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `redirectUrlApp` field. */
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `icon` field. */
  icon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Quote` values. */
export type QuotesConnection = {
  /** A list of `Quote` objects. */
  nodes: Array<Maybe<Quote>>;
  /** A list of edges which contains the `Quote` and cursor to aid in pagination. */
  edges: Array<QuotesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Quote` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Quote = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  grandTotal?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  categories?: Maybe<Scalars['String']>;
  validUntil?: Maybe<Scalars['String']>;
  quoteStage?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  orderId: Scalars['Int'];
  account?: Maybe<Scalars['String']>;
  approvalIssues?: Maybe<Scalars['String']>;
  approvalStatus?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  billingCity?: Maybe<Scalars['String']>;
  billingCountry?: Maybe<Scalars['String']>;
  billingPostal?: Maybe<Scalars['String']>;
  billingState?: Maybe<Scalars['String']>;
  billingStreet?: Maybe<Scalars['String']>;
  contact?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['String']>;
  invoiceStatus?: Maybe<Scalars['String']>;
  lineItemDiscount?: Maybe<Scalars['String']>;
  lineItemGroupTotal?: Maybe<Scalars['String']>;
  lineItemName?: Maybe<Scalars['String']>;
  lineItemSubtotal?: Maybe<Scalars['String']>;
  lineItemTax?: Maybe<Scalars['String']>;
  lineItemTotal?: Maybe<Scalars['String']>;
  paymentTerms?: Maybe<Scalars['String']>;
  shipping?: Maybe<Scalars['String']>;
  shippingCity?: Maybe<Scalars['String']>;
  shippingCountry?: Maybe<Scalars['String']>;
  shippingPostal?: Maybe<Scalars['String']>;
  shippingState?: Maybe<Scalars['String']>;
  shippingStreet?: Maybe<Scalars['String']>;
  shippingTax?: Maybe<Scalars['String']>;
  subtotal?: Maybe<Scalars['String']>;
  tax?: Maybe<Scalars['String']>;
  total?: Maybe<Scalars['String']>;
  customersCustomersToquotes?: Maybe<Scalars['String']>;
  orders?: Maybe<Scalars['String']>;
  productsProductsToquotes?: Maybe<Scalars['String']>;
};

/** A `Quote` edge in the connection. */
export type QuotesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Quote` at the end of the edge. */
  node?: Maybe<Quote>;
};

/** Methods to use when ordering `Quote`. */
export type QuotesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'GRAND_TOTAL_ASC'
  | 'GRAND_TOTAL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'VALID_UNTIL_ASC'
  | 'VALID_UNTIL_DESC'
  | 'QUOTE_STAGE_ASC'
  | 'QUOTE_STAGE_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'ORDER_ID_ASC'
  | 'ORDER_ID_DESC'
  | 'ACCOUNT_ASC'
  | 'ACCOUNT_DESC'
  | 'APPROVAL_ISSUES_ASC'
  | 'APPROVAL_ISSUES_DESC'
  | 'APPROVAL_STATUS_ASC'
  | 'APPROVAL_STATUS_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'BILLING_CITY_ASC'
  | 'BILLING_CITY_DESC'
  | 'BILLING_COUNTRY_ASC'
  | 'BILLING_COUNTRY_DESC'
  | 'BILLING_POSTAL_ASC'
  | 'BILLING_POSTAL_DESC'
  | 'BILLING_STATE_ASC'
  | 'BILLING_STATE_DESC'
  | 'BILLING_STREET_ASC'
  | 'BILLING_STREET_DESC'
  | 'CONTACT_ASC'
  | 'CONTACT_DESC'
  | 'CURRENCY_ASC'
  | 'CURRENCY_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'INVOICE_STATUS_ASC'
  | 'INVOICE_STATUS_DESC'
  | 'LINE_ITEM_DISCOUNT_ASC'
  | 'LINE_ITEM_DISCOUNT_DESC'
  | 'LINE_ITEM_GROUP_TOTAL_ASC'
  | 'LINE_ITEM_GROUP_TOTAL_DESC'
  | 'LINE_ITEM_NAME_ASC'
  | 'LINE_ITEM_NAME_DESC'
  | 'LINE_ITEM_SUBTOTAL_ASC'
  | 'LINE_ITEM_SUBTOTAL_DESC'
  | 'LINE_ITEM_TAX_ASC'
  | 'LINE_ITEM_TAX_DESC'
  | 'LINE_ITEM_TOTAL_ASC'
  | 'LINE_ITEM_TOTAL_DESC'
  | 'PAYMENT_TERMS_ASC'
  | 'PAYMENT_TERMS_DESC'
  | 'SHIPPING_ASC'
  | 'SHIPPING_DESC'
  | 'SHIPPING_CITY_ASC'
  | 'SHIPPING_CITY_DESC'
  | 'SHIPPING_COUNTRY_ASC'
  | 'SHIPPING_COUNTRY_DESC'
  | 'SHIPPING_POSTAL_ASC'
  | 'SHIPPING_POSTAL_DESC'
  | 'SHIPPING_STATE_ASC'
  | 'SHIPPING_STATE_DESC'
  | 'SHIPPING_STREET_ASC'
  | 'SHIPPING_STREET_DESC'
  | 'SHIPPING_TAX_ASC'
  | 'SHIPPING_TAX_DESC'
  | 'SUBTOTAL_ASC'
  | 'SUBTOTAL_DESC'
  | 'TAX_ASC'
  | 'TAX_DESC'
  | 'TOTAL_ASC'
  | 'TOTAL_DESC'
  | 'CUSTOMERS_CUSTOMERS_TOQUOTES_ASC'
  | 'CUSTOMERS_CUSTOMERS_TOQUOTES_DESC'
  | 'ORDERS_ASC'
  | 'ORDERS_DESC'
  | 'PRODUCTS_PRODUCTS_TOQUOTES_ASC'
  | 'PRODUCTS_PRODUCTS_TOQUOTES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Quote` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `grandTotal` field. */
  grandTotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `validUntil` field. */
  validUntil?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `quoteStage` field. */
  quoteStage?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `account` field. */
  account?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `approvalIssues` field. */
  approvalIssues?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `approvalStatus` field. */
  approvalStatus?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `billingCity` field. */
  billingCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `billingCountry` field. */
  billingCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `billingPostal` field. */
  billingPostal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `billingState` field. */
  billingState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `billingStreet` field. */
  billingStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `contact` field. */
  contact?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `discount` field. */
  discount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiceStatus` field. */
  invoiceStatus?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lineItemDiscount` field. */
  lineItemDiscount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lineItemGroupTotal` field. */
  lineItemGroupTotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lineItemName` field. */
  lineItemName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lineItemSubtotal` field. */
  lineItemSubtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lineItemTax` field. */
  lineItemTax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lineItemTotal` field. */
  lineItemTotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `paymentTerms` field. */
  paymentTerms?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipping` field. */
  shipping?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingCity` field. */
  shippingCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingCountry` field. */
  shippingCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingPostal` field. */
  shippingPostal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingState` field. */
  shippingState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingStreet` field. */
  shippingStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingTax` field. */
  shippingTax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `subtotal` field. */
  subtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tax` field. */
  tax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `total` field. */
  total?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customersCustomersToquotes` field. */
  customersCustomersToquotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `orders` field. */
  orders?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `productsProductsToquotes` field. */
  productsProductsToquotes?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Rating` values. */
export type RatingsConnection = {
  /** A list of `Rating` objects. */
  nodes: Array<Maybe<Rating>>;
  /** A list of edges which contains the `Rating` and cursor to aid in pagination. */
  edges: Array<RatingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Rating` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Rating = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  defaultValue?: Maybe<Scalars['String']>;
  defaultStoreView?: Maybe<Scalars['String']>;
  ratingVisibility?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  sortOrder?: Maybe<Scalars['BigFloat']>;
  prodId: Scalars['BigInt'];
  products?: Maybe<Scalars['String']>;
};

/** A `Rating` edge in the connection. */
export type RatingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Rating` at the end of the edge. */
  node?: Maybe<Rating>;
};

/** Methods to use when ordering `Rating`. */
export type RatingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'DEFAULT_VALUE_ASC'
  | 'DEFAULT_VALUE_DESC'
  | 'DEFAULT_STORE_VIEW_ASC'
  | 'DEFAULT_STORE_VIEW_DESC'
  | 'RATING_VISIBILITY_ASC'
  | 'RATING_VISIBILITY_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'SORT_ORDER_ASC'
  | 'SORT_ORDER_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Rating` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RatingCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `defaultValue` field. */
  defaultValue?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultStoreView` field. */
  defaultStoreView?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ratingVisibility` field. */
  ratingVisibility?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Report` values. */
export type ReportsConnection = {
  /** A list of `Report` objects. */
  nodes: Array<Maybe<Report>>;
  /** A list of edges which contains the `Report` and cursor to aid in pagination. */
  edges: Array<ReportsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Report` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Report = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  customer?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  subtotal?: Maybe<Scalars['String']>;
  appliedCoupon?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  updated?: Maybe<Scalars['Datetime']>;
  ipAddress?: Maybe<Scalars['String']>;
};

/** A `Report` edge in the connection. */
export type ReportsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Report` at the end of the edge. */
  node?: Maybe<Report>;
};

/** Methods to use when ordering `Report`. */
export type ReportsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CUSTOMER_ASC'
  | 'CUSTOMER_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'QUANTITY_ASC'
  | 'QUANTITY_DESC'
  | 'SUBTOTAL_ASC'
  | 'SUBTOTAL_DESC'
  | 'APPLIED_COUPON_ASC'
  | 'APPLIED_COUPON_DESC'
  | 'CREATED_ASC'
  | 'CREATED_DESC'
  | 'UPDATED_ASC'
  | 'UPDATED_DESC'
  | 'IP_ADDRESS_ASC'
  | 'IP_ADDRESS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Report` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReportCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `customer` field. */
  customer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `subtotal` field. */
  subtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `appliedCoupon` field. */
  appliedCoupon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updated` field. */
  updated?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Return` values. */
export type ReturnsConnection = {
  /** A list of `Return` objects. */
  nodes: Array<Maybe<Return>>;
  /** A list of edges which contains the `Return` and cursor to aid in pagination. */
  edges: Array<ReturnsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Return` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Return = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  validity?: Maybe<Scalars['String']>;
  returnPrefix?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  shippingNumber?: Maybe<Scalars['String']>;
  shippingDescription?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  liquidationReason?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['String']>;
  howShipped?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  shipTo?: Maybe<Scalars['String']>;
  caseId?: Maybe<Scalars['String']>;
};

/** A `Return` edge in the connection. */
export type ReturnsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Return` at the end of the edge. */
  node?: Maybe<Return>;
};

/** Methods to use when ordering `Return`. */
export type ReturnsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'VALIDITY_ASC'
  | 'VALIDITY_DESC'
  | 'RETURN_PREFIX_ASC'
  | 'RETURN_PREFIX_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'SHIPPING_NUMBER_ASC'
  | 'SHIPPING_NUMBER_DESC'
  | 'SHIPPING_DESCRIPTION_ASC'
  | 'SHIPPING_DESCRIPTION_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'LIQUIDATION_REASON_ASC'
  | 'LIQUIDATION_REASON_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'WEIGHT_ASC'
  | 'WEIGHT_DESC'
  | 'HEIGHT_ASC'
  | 'HEIGHT_DESC'
  | 'HOW_SHIPPED_ASC'
  | 'HOW_SHIPPED_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'SHIP_TO_ASC'
  | 'SHIP_TO_DESC'
  | 'CASE_ID_ASC'
  | 'CASE_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Return` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReturnCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `validity` field. */
  validity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `returnPrefix` field. */
  returnPrefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingNumber` field. */
  shippingNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shippingDescription` field. */
  shippingDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `liquidationReason` field. */
  liquidationReason?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `height` field. */
  height?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `howShipped` field. */
  howShipped?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipTo` field. */
  shipTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `caseId` field. */
  caseId?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Review` values. */
export type ReviewsConnection = {
  /** A list of `Review` objects. */
  nodes: Array<Maybe<Review>>;
  /** A list of edges which contains the `Review` and cursor to aid in pagination. */
  edges: Array<ReviewsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Review` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Review = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  websites?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  shopId: Scalars['Int'];
  commentId: Scalars['Int'];
};

/** A `Review` edge in the connection. */
export type ReviewsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Review` at the end of the edge. */
  node?: Maybe<Review>;
};

/** Methods to use when ordering `Review`. */
export type ReviewsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SHOP_ID_ASC'
  | 'SHOP_ID_DESC'
  | 'COMMENT_ID_ASC'
  | 'COMMENT_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Review` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `shopId` field. */
  shopId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `commentId` field. */
  commentId?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `Reward` values. */
export type RewardsConnection = {
  /** A list of `Reward` objects. */
  nodes: Array<Maybe<Reward>>;
  /** A list of edges which contains the `Reward` and cursor to aid in pagination. */
  edges: Array<RewardsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Reward` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Reward = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  level?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  coupons?: Maybe<Scalars['String']>;
  expiration?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Reward` edge in the connection. */
export type RewardsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Reward` at the end of the edge. */
  node?: Maybe<Reward>;
};

/** Methods to use when ordering `Reward`. */
export type RewardsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'SLUG_ASC'
  | 'SLUG_DESC'
  | 'LEVEL_ASC'
  | 'LEVEL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Reward` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RewardCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `level` field. */
  level?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `expiration` field. */
  expiration?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Role` values. */
export type RolesConnection = {
  /** A list of `Role` objects. */
  nodes: Array<Maybe<Role>>;
  /** A list of edges which contains the `Role` and cursor to aid in pagination. */
  edges: Array<RolesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Role = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  roleName: Scalars['String'];
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** A `Role` edge in the connection. */
export type RolesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Role` at the end of the edge. */
  node?: Maybe<Role>;
};

/** Methods to use when ordering `Role`. */
export type RolesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'ROLE_NAME_ASC'
  | 'ROLE_NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `roleName` field. */
  roleName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Scheduler` values. */
export type SchedulersConnection = {
  /** A list of `Scheduler` objects. */
  nodes: Array<Maybe<Scheduler>>;
  /** A list of edges which contains the `Scheduler` and cursor to aid in pagination. */
  edges: Array<SchedulersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Scheduler` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Scheduler = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['String']>;
  level?: Maybe<Scalars['String']>;
  login?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  whid?: Maybe<Scalars['String']>;
};

/** A `Scheduler` edge in the connection. */
export type SchedulersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Scheduler` at the end of the edge. */
  node?: Maybe<Scheduler>;
};

/** Methods to use when ordering `Scheduler`. */
export type SchedulersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'LEVEL_ASC'
  | 'LEVEL_DESC'
  | 'LOGIN_ASC'
  | 'LOGIN_DESC'
  | 'NOTES_ASC'
  | 'NOTES_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'WHID_ASC'
  | 'WHID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Scheduler` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SchedulerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `level` field. */
  level?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `login` field. */
  login?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `whid` field. */
  whid?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Segment` values. */
export type SegmentsConnection = {
  /** A list of `Segment` objects. */
  nodes: Array<Maybe<Segment>>;
  /** A list of edges which contains the `Segment` and cursor to aid in pagination. */
  edges: Array<SegmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Segment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Segment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  applyTo?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
};

/** A `Segment` edge in the connection. */
export type SegmentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Segment` at the end of the edge. */
  node?: Maybe<Segment>;
};

/** Methods to use when ordering `Segment`. */
export type SegmentsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'APPLY_TO_ASC'
  | 'APPLY_TO_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Segment` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SegmentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `applyTo` field. */
  applyTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Setting` values. */
export type SettingsConnection = {
  /** A list of `Setting` objects. */
  nodes: Array<Maybe<Setting>>;
  /** A list of edges which contains the `Setting` and cursor to aid in pagination. */
  edges: Array<SettingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Setting` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Setting = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  storeName?: Maybe<Scalars['String']>;
  storePhone?: Maybe<Scalars['String']>;
  storeHours?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  zipcode?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  addressTwo?: Maybe<Scalars['String']>;
  vatNumber?: Maybe<Scalars['String']>;
  allowState?: Maybe<Scalars['String']>;
  stateRequiredFor?: Maybe<Scalars['String']>;
  allowCountries?: Maybe<Scalars['String']>;
  defaultCountry?: Maybe<Scalars['String']>;
  optionalZip?: Maybe<Scalars['String']>;
  europeanUnionCountries?: Maybe<Scalars['String']>;
  topDestinations?: Maybe<Scalars['String']>;
  baseCurrency?: Maybe<Scalars['String']>;
  defaultCurrency?: Maybe<Scalars['String']>;
  allowedCurrency?: Maybe<Scalars['String']>;
  siteName?: Maybe<Scalars['String']>;
  siteWebsite?: Maybe<Scalars['String']>;
  sentryDsn?: Maybe<Scalars['String']>;
  awsS3?: Maybe<Scalars['String']>;
  databaseUrl?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  googleAnalytics?: Maybe<Scalars['String']>;
  searchSetting?: Maybe<Scalars['String']>;
  mailServer?: Maybe<Scalars['String']>;
  youtubeVideos?: Maybe<Scalars['String']>;
  siteTagline?: Maybe<Scalars['String']>;
  googleDrive?: Maybe<Scalars['String']>;
  disqusKey?: Maybe<Scalars['String']>;
};

/** A `Setting` edge in the connection. */
export type SettingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Setting` at the end of the edge. */
  node?: Maybe<Setting>;
};

/** Methods to use when ordering `Setting`. */
export type SettingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'STORE_NAME_ASC'
  | 'STORE_NAME_DESC'
  | 'STORE_PHONE_ASC'
  | 'STORE_PHONE_DESC'
  | 'STORE_HOURS_ASC'
  | 'STORE_HOURS_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'ZIPCODE_ASC'
  | 'ZIPCODE_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'ADDRESS_TWO_ASC'
  | 'ADDRESS_TWO_DESC'
  | 'VAT_NUMBER_ASC'
  | 'VAT_NUMBER_DESC'
  | 'ALLOW_STATE_ASC'
  | 'ALLOW_STATE_DESC'
  | 'STATE_REQUIRED_FOR_ASC'
  | 'STATE_REQUIRED_FOR_DESC'
  | 'ALLOW_COUNTRIES_ASC'
  | 'ALLOW_COUNTRIES_DESC'
  | 'DEFAULT_COUNTRY_ASC'
  | 'DEFAULT_COUNTRY_DESC'
  | 'OPTIONAL_ZIP_ASC'
  | 'OPTIONAL_ZIP_DESC'
  | 'EUROPEAN_UNION_COUNTRIES_ASC'
  | 'EUROPEAN_UNION_COUNTRIES_DESC'
  | 'TOP_DESTINATIONS_ASC'
  | 'TOP_DESTINATIONS_DESC'
  | 'BASE_CURRENCY_ASC'
  | 'BASE_CURRENCY_DESC'
  | 'DEFAULT_CURRENCY_ASC'
  | 'DEFAULT_CURRENCY_DESC'
  | 'ALLOWED_CURRENCY_ASC'
  | 'ALLOWED_CURRENCY_DESC'
  | 'SITE_NAME_ASC'
  | 'SITE_NAME_DESC'
  | 'SITE_WEBSITE_ASC'
  | 'SITE_WEBSITE_DESC'
  | 'SENTRY_DSN_ASC'
  | 'SENTRY_DSN_DESC'
  | 'AWS_S3_ASC'
  | 'AWS_S3_DESC'
  | 'DATABASE_URL_ASC'
  | 'DATABASE_URL_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'GOOGLE_ANALYTICS_ASC'
  | 'GOOGLE_ANALYTICS_DESC'
  | 'SEARCH_SETTING_ASC'
  | 'SEARCH_SETTING_DESC'
  | 'MAIL_SERVER_ASC'
  | 'MAIL_SERVER_DESC'
  | 'YOUTUBE_VIDEOS_ASC'
  | 'YOUTUBE_VIDEOS_DESC'
  | 'SITE_TAGLINE_ASC'
  | 'SITE_TAGLINE_DESC'
  | 'GOOGLE_DRIVE_ASC'
  | 'GOOGLE_DRIVE_DESC'
  | 'DISQUS_KEY_ASC'
  | 'DISQUS_KEY_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SettingCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `storeName` field. */
  storeName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `storePhone` field. */
  storePhone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `storeHours` field. */
  storeHours?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `region` field. */
  region?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipcode` field. */
  zipcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `addressTwo` field. */
  addressTwo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vatNumber` field. */
  vatNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `allowState` field. */
  allowState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `stateRequiredFor` field. */
  stateRequiredFor?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `allowCountries` field. */
  allowCountries?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultCountry` field. */
  defaultCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `optionalZip` field. */
  optionalZip?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `europeanUnionCountries` field. */
  europeanUnionCountries?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `topDestinations` field. */
  topDestinations?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `baseCurrency` field. */
  baseCurrency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultCurrency` field. */
  defaultCurrency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `allowedCurrency` field. */
  allowedCurrency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `siteName` field. */
  siteName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `siteWebsite` field. */
  siteWebsite?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sentryDsn` field. */
  sentryDsn?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `awsS3` field. */
  awsS3?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `databaseUrl` field. */
  databaseUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `googleAnalytics` field. */
  googleAnalytics?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `searchSetting` field. */
  searchSetting?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mailServer` field. */
  mailServer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `youtubeVideos` field. */
  youtubeVideos?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `siteTagline` field. */
  siteTagline?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `googleDrive` field. */
  googleDrive?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `disqusKey` field. */
  disqusKey?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Shipment` values. */
export type ShipmentsConnection = {
  /** A list of `Shipment` objects. */
  nodes: Array<Maybe<Shipment>>;
  /** A list of edges which contains the `Shipment` and cursor to aid in pagination. */
  edges: Array<ShipmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Shipment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  product?: Maybe<Scalars['String']>;
  speedGrade?: Maybe<Scalars['String']>;
  shipDate?: Maybe<Scalars['Datetime']>;
  carrierName: Scalars['String'];
  transitTime?: Maybe<Scalars['String']>;
  trackingUrl?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
};

/** A `Shipment` edge in the connection. */
export type ShipmentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipment` at the end of the edge. */
  node?: Maybe<Shipment>;
};

/** Methods to use when ordering `Shipment`. */
export type ShipmentsOrderBy =
  | 'NATURAL'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'SPEED_GRADE_ASC'
  | 'SPEED_GRADE_DESC'
  | 'SHIP_DATE_ASC'
  | 'SHIP_DATE_DESC'
  | 'CARRIER_NAME_ASC'
  | 'CARRIER_NAME_DESC'
  | 'TRANSIT_TIME_ASC'
  | 'TRANSIT_TIME_DESC'
  | 'TRACKING_URL_ASC'
  | 'TRACKING_URL_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Shipment` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ShipmentCondition = {
  /** Checks for equality with the object’s `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `speedGrade` field. */
  speedGrade?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipDate` field. */
  shipDate?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `carrierName` field. */
  carrierName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `transitTime` field. */
  transitTime?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `trackingUrl` field. */
  trackingUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `SpecialDiscount` values. */
export type SpecialDiscountsConnection = {
  /** A list of `SpecialDiscount` objects. */
  nodes: Array<Maybe<SpecialDiscount>>;
  /** A list of edges which contains the `SpecialDiscount` and cursor to aid in pagination. */
  edges: Array<SpecialDiscountsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpecialDiscount` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type SpecialDiscount = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['BigFloat']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  rewards?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  expiration?: Maybe<Scalars['Date']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `SpecialDiscount` edge in the connection. */
export type SpecialDiscountsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SpecialDiscount` at the end of the edge. */
  node?: Maybe<SpecialDiscount>;
};

/** Methods to use when ordering `SpecialDiscount`. */
export type SpecialDiscountsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'REWARDS_ASC'
  | 'REWARDS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `SpecialDiscount` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SpecialDiscountCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `discount` field. */
  discount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `rewards` field. */
  rewards?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `expiration` field. */
  expiration?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `State` values. */
export type StatesConnection = {
  /** A list of `State` objects. */
  nodes: Array<Maybe<State>>;
  /** A list of edges which contains the `State` and cursor to aid in pagination. */
  edges: Array<StatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `State` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type State = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
};

/** A `State` edge in the connection. */
export type StatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `State` at the end of the edge. */
  node?: Maybe<State>;
};

/** Methods to use when ordering `State`. */
export type StatesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `State` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type StateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Statistic` values. */
export type StatisticsConnection = {
  /** A list of `Statistic` objects. */
  nodes: Array<Maybe<Statistic>>;
  /** A list of edges which contains the `Statistic` and cursor to aid in pagination. */
  edges: Array<StatisticsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Statistic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Statistic = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  specialOffers?: Maybe<Scalars['String']>;
  reports?: Maybe<Scalars['String']>;
  rewards?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  expiration?: Maybe<Scalars['Date']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Statistic` edge in the connection. */
export type StatisticsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Statistic` at the end of the edge. */
  node?: Maybe<Statistic>;
};

/** Methods to use when ordering `Statistic`. */
export type StatisticsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'SPECIAL_OFFERS_ASC'
  | 'SPECIAL_OFFERS_DESC'
  | 'REPORTS_ASC'
  | 'REPORTS_DESC'
  | 'REWARDS_ASC'
  | 'REWARDS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Statistic` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type StatisticCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `specialOffers` field. */
  specialOffers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `reports` field. */
  reports?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `rewards` field. */
  rewards?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `expiration` field. */
  expiration?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Stock` values. */
export type StocksConnection = {
  /** A list of `Stock` objects. */
  nodes: Array<Maybe<Stock>>;
  /** A list of edges which contains the `Stock` and cursor to aid in pagination. */
  edges: Array<StocksEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Stock` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Stock = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  enabled?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sources?: Maybe<Scalars['String']>;
};

/** A `Stock` edge in the connection. */
export type StocksEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Stock` at the end of the edge. */
  node?: Maybe<Stock>;
};

/** Methods to use when ordering `Stock`. */
export type StocksOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ENABLED_ASC'
  | 'ENABLED_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'SOURCES_ASC'
  | 'SOURCES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Stock` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type StockCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `enabled` field. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sources` field. */
  sources?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Survey` values. */
export type SurveysConnection = {
  /** A list of `Survey` objects. */
  nodes: Array<Maybe<Survey>>;
  /** A list of edges which contains the `Survey` and cursor to aid in pagination. */
  edges: Array<SurveysEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Survey` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Survey = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  question?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  submitText?: Maybe<Scalars['String']>;
  satisfiedText?: Maybe<Scalars['String']>;
  neitherText?: Maybe<Scalars['String']>;
  dissatisfiedText?: Maybe<Scalars['String']>;
};

/** A `Survey` edge in the connection. */
export type SurveysEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Survey` at the end of the edge. */
  node?: Maybe<Survey>;
};

/** Methods to use when ordering `Survey`. */
export type SurveysOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'QUESTION_ASC'
  | 'QUESTION_DESC'
  | 'ANSWER_ASC'
  | 'ANSWER_DESC'
  | 'SUBMIT_TEXT_ASC'
  | 'SUBMIT_TEXT_DESC'
  | 'SATISFIED_TEXT_ASC'
  | 'SATISFIED_TEXT_DESC'
  | 'NEITHER_TEXT_ASC'
  | 'NEITHER_TEXT_DESC'
  | 'DISSATISFIED_TEXT_ASC'
  | 'DISSATISFIED_TEXT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Survey` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SurveyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `question` field. */
  question?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `answer` field. */
  answer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `submitText` field. */
  submitText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `satisfiedText` field. */
  satisfiedText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `neitherText` field. */
  neitherText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dissatisfiedText` field. */
  dissatisfiedText?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Tag` values. */
export type TagsConnection = {
  /** A list of `Tag` objects. */
  nodes: Array<Maybe<Tag>>;
  /** A list of edges which contains the `Tag` and cursor to aid in pagination. */
  edges: Array<TagsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Tag = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Tag` edge in the connection. */
export type TagsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Tag` at the end of the edge. */
  node?: Maybe<Tag>;
};

/** Methods to use when ordering `Tag`. */
export type TagsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TagCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Target` values. */
export type TargetsConnection = {
  /** A list of `Target` objects. */
  nodes: Array<Maybe<Target>>;
  /** A list of edges which contains the `Target` and cursor to aid in pagination. */
  edges: Array<TargetsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Target` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Target = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  prefix?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  department?: Maybe<Scalars['String']>;
  accountName?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  postalcode?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  fax?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  mobile?: Maybe<Scalars['String']>;
  jobTitle?: Maybe<Scalars['String']>;
  altAddress?: Maybe<Scalars['String']>;
  altPostalcode?: Maybe<Scalars['String']>;
  altCity?: Maybe<Scalars['String']>;
  altState?: Maybe<Scalars['String']>;
  altCountry?: Maybe<Scalars['String']>;
  officePhone?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  emailOptOut?: Maybe<Scalars['String']>;
  donotcall?: Maybe<Scalars['String']>;
};

/** A `Target` edge in the connection. */
export type TargetsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Target` at the end of the edge. */
  node?: Maybe<Target>;
};

/** Methods to use when ordering `Target`. */
export type TargetsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'PREFIX_ASC'
  | 'PREFIX_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'DEPARTMENT_ASC'
  | 'DEPARTMENT_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'POSTALCODE_ASC'
  | 'POSTALCODE_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'FAX_ASC'
  | 'FAX_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'MOBILE_ASC'
  | 'MOBILE_DESC'
  | 'JOB_TITLE_ASC'
  | 'JOB_TITLE_DESC'
  | 'ALT_ADDRESS_ASC'
  | 'ALT_ADDRESS_DESC'
  | 'ALT_POSTALCODE_ASC'
  | 'ALT_POSTALCODE_DESC'
  | 'ALT_CITY_ASC'
  | 'ALT_CITY_DESC'
  | 'ALT_STATE_ASC'
  | 'ALT_STATE_DESC'
  | 'ALT_COUNTRY_ASC'
  | 'ALT_COUNTRY_DESC'
  | 'OFFICE_PHONE_ASC'
  | 'OFFICE_PHONE_DESC'
  | 'CUSTOMER_NAME_ASC'
  | 'CUSTOMER_NAME_DESC'
  | 'EMAIL_OPT_OUT_ASC'
  | 'EMAIL_OPT_OUT_DESC'
  | 'DONOTCALL_ASC'
  | 'DONOTCALL_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Target` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TargetCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `prefix` field. */
  prefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `department` field. */
  department?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalcode` field. */
  postalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `fax` field. */
  fax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mobile` field. */
  mobile?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `jobTitle` field. */
  jobTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altAddress` field. */
  altAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altPostalcode` field. */
  altPostalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altCity` field. */
  altCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altState` field. */
  altState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `altCountry` field. */
  altCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `officePhone` field. */
  officePhone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerName` field. */
  customerName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `emailOptOut` field. */
  emailOptOut?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `donotcall` field. */
  donotcall?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `TaxCategory` values. */
export type TaxCategoriesConnection = {
  /** A list of `TaxCategory` objects. */
  nodes: Array<Maybe<TaxCategory>>;
  /** A list of edges which contains the `TaxCategory` and cursor to aid in pagination. */
  edges: Array<TaxCategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TaxCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TaxCategory = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  default?: Maybe<Scalars['String']>;
};

/** A `TaxCategory` edge in the connection. */
export type TaxCategoriesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TaxCategory` at the end of the edge. */
  node?: Maybe<TaxCategory>;
};

/** Methods to use when ordering `TaxCategory`. */
export type TaxCategoriesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DEFAULT_ASC'
  | 'DEFAULT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `TaxCategory` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TaxCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `default` field. */
  default?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `TaxRate` values. */
export type TaxRatesConnection = {
  /** A list of `TaxRate` objects. */
  nodes: Array<Maybe<TaxRate>>;
  /** A list of edges which contains the `TaxRate` and cursor to aid in pagination. */
  edges: Array<TaxRatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TaxRate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TaxRate = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  taxIdentifier: Scalars['String'];
  zipPostIsRange?: Maybe<Scalars['Boolean']>;
  postcode?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  ratePercent?: Maybe<Scalars['String']>;
  defaultStoreView?: Maybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: Maybe<Scalars['String']>;
};

/** A `TaxRate` edge in the connection. */
export type TaxRatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TaxRate` at the end of the edge. */
  node?: Maybe<TaxRate>;
};

/** Methods to use when ordering `TaxRate`. */
export type TaxRatesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'TAX_IDENTIFIER_ASC'
  | 'TAX_IDENTIFIER_DESC'
  | 'ZIP_POST_IS_RANGE_ASC'
  | 'ZIP_POST_IS_RANGE_DESC'
  | 'POSTCODE_ASC'
  | 'POSTCODE_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'RATE_PERCENT_ASC'
  | 'RATE_PERCENT_DESC'
  | 'DEFAULT_STORE_VIEW_ASC'
  | 'DEFAULT_STORE_VIEW_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `TaxRate` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TaxRateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `taxIdentifier` field. */
  taxIdentifier?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipPostIsRange` field. */
  zipPostIsRange?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ratePercent` field. */
  ratePercent?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultStoreView` field. */
  defaultStoreView?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `TaxRule` values. */
export type TaxRulesConnection = {
  /** A list of `TaxRule` objects. */
  nodes: Array<Maybe<TaxRule>>;
  /** A list of edges which contains the `TaxRule` and cursor to aid in pagination. */
  edges: Array<TaxRulesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TaxRule` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TaxRule = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  taxRate?: Maybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: Maybe<Scalars['String']>;
};

/** A `TaxRule` edge in the connection. */
export type TaxRulesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TaxRule` at the end of the edge. */
  node?: Maybe<TaxRule>;
};

/** Methods to use when ordering `TaxRule`. */
export type TaxRulesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'TAX_RATE_ASC'
  | 'TAX_RATE_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `TaxRule` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TaxRuleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `taxRate` field. */
  taxRate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Template` values. */
export type TemplatesConnection = {
  /** A list of `Template` objects. */
  nodes: Array<Maybe<Template>>;
  /** A list of edges which contains the `Template` and cursor to aid in pagination. */
  edges: Array<TemplatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Template` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Template = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['String']>;
  pageSize?: Maybe<Scalars['String']>;
  orientation?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  footer?: Maybe<Scalars['String']>;
  marginLeft?: Maybe<Scalars['String']>;
  marginRight?: Maybe<Scalars['String']>;
  marginTop?: Maybe<Scalars['String']>;
  marginBottom?: Maybe<Scalars['String']>;
  marginHeader?: Maybe<Scalars['String']>;
  marginFooter?: Maybe<Scalars['String']>;
};

/** A `Template` edge in the connection. */
export type TemplatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Template` at the end of the edge. */
  node?: Maybe<Template>;
};

/** Methods to use when ordering `Template`. */
export type TemplatesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'PAGE_SIZE_ASC'
  | 'PAGE_SIZE_DESC'
  | 'ORIENTATION_ASC'
  | 'ORIENTATION_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'HEADER_ASC'
  | 'HEADER_DESC'
  | 'FOOTER_ASC'
  | 'FOOTER_DESC'
  | 'MARGIN_LEFT_ASC'
  | 'MARGIN_LEFT_DESC'
  | 'MARGIN_RIGHT_ASC'
  | 'MARGIN_RIGHT_DESC'
  | 'MARGIN_TOP_ASC'
  | 'MARGIN_TOP_DESC'
  | 'MARGIN_BOTTOM_ASC'
  | 'MARGIN_BOTTOM_DESC'
  | 'MARGIN_HEADER_ASC'
  | 'MARGIN_HEADER_DESC'
  | 'MARGIN_FOOTER_ASC'
  | 'MARGIN_FOOTER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Template` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TemplateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pageSize` field. */
  pageSize?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `orientation` field. */
  orientation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `header` field. */
  header?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `footer` field. */
  footer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `marginLeft` field. */
  marginLeft?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `marginRight` field. */
  marginRight?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `marginTop` field. */
  marginTop?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `marginBottom` field. */
  marginBottom?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `marginHeader` field. */
  marginHeader?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `marginFooter` field. */
  marginFooter?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Theme` values. */
export type ThemesConnection = {
  /** A list of `Theme` objects. */
  nodes: Array<Maybe<Theme>>;
  /** A list of edges which contains the `Theme` and cursor to aid in pagination. */
  edges: Array<ThemesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Theme` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Theme = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  title?: Maybe<Scalars['String']>;
  parentTheme?: Maybe<Scalars['String']>;
  themePath?: Maybe<Scalars['String']>;
  action?: Maybe<Scalars['String']>;
  websiteId: Scalars['BigInt'];
  websites: Scalars['String'];
};

/** A `Theme` edge in the connection. */
export type ThemesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Theme` at the end of the edge. */
  node?: Maybe<Theme>;
};

/** Methods to use when ordering `Theme`. */
export type ThemesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'PARENT_THEME_ASC'
  | 'PARENT_THEME_DESC'
  | 'THEME_PATH_ASC'
  | 'THEME_PATH_DESC'
  | 'ACTION_ASC'
  | 'ACTION_DESC'
  | 'WEBSITE_ID_ASC'
  | 'WEBSITE_ID_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Theme` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ThemeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `parentTheme` field. */
  parentTheme?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `themePath` field. */
  themePath?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `action` field. */
  action?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `websiteId` field. */
  websiteId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Ticketing` values. */
export type TicketingsConnection = {
  /** A list of `Ticketing` objects. */
  nodes: Array<Maybe<Ticketing>>;
  /** A list of edges which contains the `Ticketing` and cursor to aid in pagination. */
  edges: Array<TicketingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Ticketing` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Ticketing = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['String']>;
  severity?: Maybe<Scalars['String']>;
  team?: Maybe<Scalars['String']>;
  requester?: Maybe<Scalars['String']>;
  requesterEmail?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  department?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  ticketType?: Maybe<Scalars['String']>;
  comment?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  resolution?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  dateModified?: Maybe<Scalars['Datetime']>;
  accountName?: Maybe<Scalars['String']>;
  level?: Maybe<Scalars['String']>;
  projectsProjectsToticketing?: Maybe<Scalars['String']>;
};

/** A `Ticketing` edge in the connection. */
export type TicketingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Ticketing` at the end of the edge. */
  node?: Maybe<Ticketing>;
};

/** Methods to use when ordering `Ticketing`. */
export type TicketingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'DATE_ASC'
  | 'DATE_DESC'
  | 'SEVERITY_ASC'
  | 'SEVERITY_DESC'
  | 'TEAM_ASC'
  | 'TEAM_DESC'
  | 'REQUESTER_ASC'
  | 'REQUESTER_DESC'
  | 'REQUESTER_EMAIL_ASC'
  | 'REQUESTER_EMAIL_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'DEPARTMENT_ASC'
  | 'DEPARTMENT_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'TICKET_TYPE_ASC'
  | 'TICKET_TYPE_DESC'
  | 'COMMENT_ASC'
  | 'COMMENT_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'RESOLUTION_ASC'
  | 'RESOLUTION_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'DATE_MODIFIED_ASC'
  | 'DATE_MODIFIED_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'LEVEL_ASC'
  | 'LEVEL_DESC'
  | 'PROJECTS_PROJECTS_TOTICKETING_ASC'
  | 'PROJECTS_PROJECTS_TOTICKETING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Ticketing` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TicketingCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `severity` field. */
  severity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `team` field. */
  team?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `requester` field. */
  requester?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `requesterEmail` field. */
  requesterEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `department` field. */
  department?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ticketType` field. */
  ticketType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `resolution` field. */
  resolution?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateModified` field. */
  dateModified?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `level` field. */
  level?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projectsProjectsToticketing` field. */
  projectsProjectsToticketing?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Training` values. */
export type TrainingsConnection = {
  /** A list of `Training` objects. */
  nodes: Array<Maybe<Training>>;
  /** A list of edges which contains the `Training` and cursor to aid in pagination. */
  edges: Array<TrainingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Training` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Training = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  link?: Maybe<Scalars['String']>;
  steps?: Maybe<Scalars['String']>;
  updated?: Maybe<Scalars['Datetime']>;
  analytics?: Maybe<Scalars['String']>;
  competency?: Maybe<Scalars['String']>;
  course?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  comment?: Maybe<Scalars['Int']>;
  address?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['Int']>;
  state?: Maybe<Scalars['Int']>;
  postal?: Maybe<Scalars['String']>;
  teacher?: Maybe<Scalars['String']>;
  student?: Maybe<Scalars['String']>;
  announcement?: Maybe<Scalars['String']>;
  resource?: Maybe<Scalars['String']>;
  badges?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  isCompleted?: Maybe<Scalars['String']>;
  speakers?: Maybe<Scalars['String']>;
  fieldTrips?: Maybe<Scalars['String']>;
  assignments?: Maybe<Scalars['String']>;
  assignmentsDueDate?: Maybe<Scalars['String']>;
  origanalityReport?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['BigInt']>;
  faqs?: Maybe<Scalars['String']>;
  languages?: Maybe<Scalars['String']>;
  checklists?: Maybe<Scalars['BigInt']>;
  city?: Maybe<Scalars['String']>;
  meetups?: Maybe<Scalars['String']>;
  lab?: Maybe<Scalars['String']>;
  digiboards?: Maybe<Scalars['String']>;
  countries?: Maybe<Scalars['String']>;
  states?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** A `Training` edge in the connection. */
export type TrainingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Training` at the end of the edge. */
  node?: Maybe<Training>;
};

/** Methods to use when ordering `Training`. */
export type TrainingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'LINK_ASC'
  | 'LINK_DESC'
  | 'STEPS_ASC'
  | 'STEPS_DESC'
  | 'UPDATED_ASC'
  | 'UPDATED_DESC'
  | 'ANALYTICS_ASC'
  | 'ANALYTICS_DESC'
  | 'COMPETENCY_ASC'
  | 'COMPETENCY_DESC'
  | 'COURSE_ASC'
  | 'COURSE_DESC'
  | 'GRADE_ASC'
  | 'GRADE_DESC'
  | 'SCHOOL_ASC'
  | 'SCHOOL_DESC'
  | 'COMMENT_ASC'
  | 'COMMENT_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'POSTAL_ASC'
  | 'POSTAL_DESC'
  | 'TEACHER_ASC'
  | 'TEACHER_DESC'
  | 'STUDENT_ASC'
  | 'STUDENT_DESC'
  | 'ANNOUNCEMENT_ASC'
  | 'ANNOUNCEMENT_DESC'
  | 'RESOURCE_ASC'
  | 'RESOURCE_DESC'
  | 'BADGES_ASC'
  | 'BADGES_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'IS_COMPLETED_ASC'
  | 'IS_COMPLETED_DESC'
  | 'SPEAKERS_ASC'
  | 'SPEAKERS_DESC'
  | 'FIELD_TRIPS_ASC'
  | 'FIELD_TRIPS_DESC'
  | 'ASSIGNMENTS_ASC'
  | 'ASSIGNMENTS_DESC'
  | 'ASSIGNMENTS_DUE_DATE_ASC'
  | 'ASSIGNMENTS_DUE_DATE_DESC'
  | 'ORIGANALITY_REPORT_ASC'
  | 'ORIGANALITY_REPORT_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'FAQS_ASC'
  | 'FAQS_DESC'
  | 'LANGUAGES_ASC'
  | 'LANGUAGES_DESC'
  | 'CHECKLISTS_ASC'
  | 'CHECKLISTS_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'MEETUPS_ASC'
  | 'MEETUPS_DESC'
  | 'LAB_ASC'
  | 'LAB_DESC'
  | 'DIGIBOARDS_ASC'
  | 'DIGIBOARDS_DESC'
  | 'COUNTRIES_ASC'
  | 'COUNTRIES_DESC'
  | 'STATES_ASC'
  | 'STATES_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Training` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TrainingCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `link` field. */
  link?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `steps` field. */
  steps?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updated` field. */
  updated?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `analytics` field. */
  analytics?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `competency` field. */
  competency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `course` field. */
  course?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `school` field. */
  school?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `postal` field. */
  postal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `teacher` field. */
  teacher?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `student` field. */
  student?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `announcement` field. */
  announcement?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `resource` field. */
  resource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `badges` field. */
  badges?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isCompleted` field. */
  isCompleted?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `speakers` field. */
  speakers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldTrips` field. */
  fieldTrips?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignments` field. */
  assignments?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `assignmentsDueDate` field. */
  assignmentsDueDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `origanalityReport` field. */
  origanalityReport?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `faqs` field. */
  faqs?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `languages` field. */
  languages?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `checklists` field. */
  checklists?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `meetups` field. */
  meetups?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lab` field. */
  lab?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `digiboards` field. */
  digiboards?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `countries` field. */
  countries?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `states` field. */
  states?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Transaction` values. */
export type TransactionsConnection = {
  /** A list of `Transaction` objects. */
  nodes: Array<Maybe<Transaction>>;
  /** A list of edges which contains the `Transaction` and cursor to aid in pagination. */
  edges: Array<TransactionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Transaction` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Transaction = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  orderId: Scalars['Int'];
  transactionId: Scalars['Int'];
  parentTransactionId: Scalars['Int'];
  created?: Maybe<Scalars['Datetime']>;
  paymentMethod: Scalars['BigInt'];
  closed?: Maybe<Scalars['String']>;
  customerPayment?: Maybe<Scalars['String']>;
  orders?: Maybe<Scalars['String']>;
};

/** A `Transaction` edge in the connection. */
export type TransactionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Transaction` at the end of the edge. */
  node?: Maybe<Transaction>;
};

/** Methods to use when ordering `Transaction`. */
export type TransactionsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'ORDER_ID_ASC'
  | 'ORDER_ID_DESC'
  | 'TRANSACTION_ID_ASC'
  | 'TRANSACTION_ID_DESC'
  | 'PARENT_TRANSACTION_ID_ASC'
  | 'PARENT_TRANSACTION_ID_DESC'
  | 'CREATED_ASC'
  | 'CREATED_DESC'
  | 'PAYMENT_METHOD_ASC'
  | 'PAYMENT_METHOD_DESC'
  | 'CLOSED_ASC'
  | 'CLOSED_DESC'
  | 'CUSTOMER_PAYMENT_ASC'
  | 'CUSTOMER_PAYMENT_DESC'
  | 'ORDERS_ASC'
  | 'ORDERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Transaction` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TransactionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `transactionId` field. */
  transactionId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `parentTransactionId` field. */
  parentTransactionId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `paymentMethod` field. */
  paymentMethod?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `closed` field. */
  closed?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerPayment` field. */
  customerPayment?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `orders` field. */
  orders?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `UploadFile` values. */
export type UploadFilesConnection = {
  /** A list of `UploadFile` objects. */
  nodes: Array<Maybe<UploadFile>>;
  /** A list of edges which contains the `UploadFile` and cursor to aid in pagination. */
  edges: Array<UploadFilesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UploadFile` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type UploadFile = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  alternativeText?: Maybe<Scalars['String']>;
  caption?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  formats?: Maybe<Scalars['JSON']>;
  hash: Scalars['String'];
  ext?: Maybe<Scalars['String']>;
  mime: Scalars['String'];
  size: Scalars['BigFloat'];
  url: Scalars['String'];
  previewUrl?: Maybe<Scalars['String']>;
  provider: Scalars['String'];
  providerMetadata?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<Scalars['Int']>;
  updatedBy?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A `UploadFile` edge in the connection. */
export type UploadFilesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UploadFile` at the end of the edge. */
  node?: Maybe<UploadFile>;
};

/** Methods to use when ordering `UploadFile`. */
export type UploadFilesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ALTERNATIVE_TEXT_ASC'
  | 'ALTERNATIVE_TEXT_DESC'
  | 'CAPTION_ASC'
  | 'CAPTION_DESC'
  | 'WIDTH_ASC'
  | 'WIDTH_DESC'
  | 'HEIGHT_ASC'
  | 'HEIGHT_DESC'
  | 'FORMATS_ASC'
  | 'FORMATS_DESC'
  | 'HASH_ASC'
  | 'HASH_DESC'
  | 'EXT_ASC'
  | 'EXT_DESC'
  | 'MIME_ASC'
  | 'MIME_DESC'
  | 'SIZE_ASC'
  | 'SIZE_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'PREVIEW_URL_ASC'
  | 'PREVIEW_URL_DESC'
  | 'PROVIDER_ASC'
  | 'PROVIDER_DESC'
  | 'PROVIDER_METADATA_ASC'
  | 'PROVIDER_METADATA_DESC'
  | 'CREATED_BY_ASC'
  | 'CREATED_BY_DESC'
  | 'UPDATED_BY_ASC'
  | 'UPDATED_BY_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `UploadFile` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UploadFileCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `alternativeText` field. */
  alternativeText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `caption` field. */
  caption?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `width` field. */
  width?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `height` field. */
  height?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `formats` field. */
  formats?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `hash` field. */
  hash?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ext` field. */
  ext?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mime` field. */
  mime?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `previewUrl` field. */
  previewUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `provider` field. */
  provider?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `providerMetadata` field. */
  providerMetadata?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `createdBy` field. */
  createdBy?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `updatedBy` field. */
  updatedBy?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type User = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  username: Scalars['String'];
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
  interfaceLocale?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  emails?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  messages?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'PASSWORD_ASC'
  | 'PASSWORD_DESC'
  | 'INTERFACE_LOCALE_ASC'
  | 'INTERFACE_LOCALE_DESC'
  | 'VALUE_ASC'
  | 'VALUE_DESC'
  | 'PERMISSIONS_ASC'
  | 'PERMISSIONS_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EMAILS_ASC'
  | 'EMAILS_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'MESSAGES_ASC'
  | 'MESSAGES_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `password` field. */
  password?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `interfaceLocale` field. */
  interfaceLocale?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `permissions` field. */
  permissions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `emails` field. */
  emails?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `messages` field. */
  messages?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Vendor` values. */
export type VendorsConnection = {
  /** A list of `Vendor` objects. */
  nodes: Array<Maybe<Vendor>>;
  /** A list of edges which contains the `Vendor` and cursor to aid in pagination. */
  edges: Array<VendorsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Vendor` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Vendor = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  polls?: Maybe<Scalars['String']>;
  quotes?: Maybe<Scalars['String']>;
  reviews?: Maybe<Scalars['String']>;
  giftCertificates?: Maybe<Scalars['String']>;
  rating?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  invoices?: Maybe<Scalars['String']>;
  reports?: Maybe<Scalars['String']>;
  rewardPoints?: Maybe<Scalars['String']>;
  specialDiscounts?: Maybe<Scalars['String']>;
  statistics?: Maybe<Scalars['String']>;
  stocks?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  physicalStore?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Vendor` edge in the connection. */
export type VendorsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Vendor` at the end of the edge. */
  node?: Maybe<Vendor>;
};

/** Methods to use when ordering `Vendor`. */
export type VendorsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'COMMENTS_ASC'
  | 'COMMENTS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'POLLS_ASC'
  | 'POLLS_DESC'
  | 'QUOTES_ASC'
  | 'QUOTES_DESC'
  | 'REVIEWS_ASC'
  | 'REVIEWS_DESC'
  | 'GIFT_CERTIFICATES_ASC'
  | 'GIFT_CERTIFICATES_DESC'
  | 'RATING_ASC'
  | 'RATING_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'INVOICES_ASC'
  | 'INVOICES_DESC'
  | 'REPORTS_ASC'
  | 'REPORTS_DESC'
  | 'REWARD_POINTS_ASC'
  | 'REWARD_POINTS_DESC'
  | 'SPECIAL_DISCOUNTS_ASC'
  | 'SPECIAL_DISCOUNTS_DESC'
  | 'STATISTICS_ASC'
  | 'STATISTICS_DESC'
  | 'STOCKS_ASC'
  | 'STOCKS_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'PHYSICAL_STORE_ASC'
  | 'PHYSICAL_STORE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Vendor` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VendorCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `comments` field. */
  comments?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `polls` field. */
  polls?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `quotes` field. */
  quotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `reviews` field. */
  reviews?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `giftCertificates` field. */
  giftCertificates?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `rating` field. */
  rating?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoices` field. */
  invoices?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `reports` field. */
  reports?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `rewardPoints` field. */
  rewardPoints?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `specialDiscounts` field. */
  specialDiscounts?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `statistics` field. */
  statistics?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `stocks` field. */
  stocks?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `physicalStore` field. */
  physicalStore?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Visit` values. */
export type VisitsConnection = {
  /** A list of `Visit` objects. */
  nodes: Array<Maybe<Visit>>;
  /** A list of edges which contains the `Visit` and cursor to aid in pagination. */
  edges: Array<VisitsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Visit` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Visit = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  location?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  reason?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  emergency?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  task?: Maybe<Scalars['String']>;
  meeting?: Maybe<Scalars['String']>;
};

/** A `Visit` edge in the connection. */
export type VisitsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Visit` at the end of the edge. */
  node?: Maybe<Visit>;
};

/** Methods to use when ordering `Visit`. */
export type VisitsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC'
  | 'REASON_ASC'
  | 'REASON_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'EMERGENCY_ASC'
  | 'EMERGENCY_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'TASK_ASC'
  | 'TASK_DESC'
  | 'MEETING_ASC'
  | 'MEETING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Visit` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VisitCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `reason` field. */
  reason?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `emergency` field. */
  emergency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `task` field. */
  task?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `meeting` field. */
  meeting?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Warehouse` values. */
export type WarehousesConnection = {
  /** A list of `Warehouse` objects. */
  nodes: Array<Maybe<Warehouse>>;
  /** A list of edges which contains the `Warehouse` and cursor to aid in pagination. */
  edges: Array<WarehousesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Warehouse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Warehouse = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  postal?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
};

/** A `Warehouse` edge in the connection. */
export type WarehousesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Warehouse` at the end of the edge. */
  node?: Maybe<Warehouse>;
};

/** Methods to use when ordering `Warehouse`. */
export type WarehousesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'POSTAL_ASC'
  | 'POSTAL_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Warehouse` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type WarehouseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `postal` field. */
  postal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Webhook` values. */
export type WebhooksConnection = {
  /** A list of `Webhook` objects. */
  nodes: Array<Maybe<Webhook>>;
  /** A list of edges which contains the `Webhook` and cursor to aid in pagination. */
  edges: Array<WebhooksEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Webhook` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Webhook = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name: Scalars['String'];
  url: Scalars['String'];
  headers?: Maybe<Scalars['String']>;
  create?: Maybe<Scalars['String']>;
  retrieve?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  delete?: Maybe<Scalars['String']>;
  publish?: Maybe<Scalars['String']>;
  unpublish?: Maybe<Scalars['String']>;
};

/** A `Webhook` edge in the connection. */
export type WebhooksEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Webhook` at the end of the edge. */
  node?: Maybe<Webhook>;
};

/** Methods to use when ordering `Webhook`. */
export type WebhooksOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'HEADERS_ASC'
  | 'HEADERS_DESC'
  | 'CREATE_ASC'
  | 'CREATE_DESC'
  | 'RETRIEVE_ASC'
  | 'RETRIEVE_DESC'
  | 'UPDATE_ASC'
  | 'UPDATE_DESC'
  | 'DELETE_ASC'
  | 'DELETE_DESC'
  | 'PUBLISH_ASC'
  | 'PUBLISH_DESC'
  | 'UNPUBLISH_ASC'
  | 'UNPUBLISH_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Webhook` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type WebhookCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `headers` field. */
  headers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `create` field. */
  create?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `retrieve` field. */
  retrieve?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `update` field. */
  update?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `delete` field. */
  delete?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `publish` field. */
  publish?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `unpublish` field. */
  unpublish?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Website` values. */
export type WebsitesConnection = {
  /** A list of `Website` objects. */
  nodes: Array<Maybe<Website>>;
  /** A list of edges which contains the `Website` and cursor to aid in pagination. */
  edges: Array<WebsitesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Website` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Website = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  shop?: Maybe<Scalars['String']>;
  store?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  themes: Scalars['String'];
};

/** A `Website` edge in the connection. */
export type WebsitesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Website` at the end of the edge. */
  node?: Maybe<Website>;
};

/** Methods to use when ordering `Website`. */
export type WebsitesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'SHOP_ASC'
  | 'SHOP_DESC'
  | 'STORE_ASC'
  | 'STORE_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'THEMES_ASC'
  | 'THEMES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Website` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type WebsiteCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shop` field. */
  shop?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `store` field. */
  store?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `themes` field. */
  themes?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Wishlist` values. */
export type WishlistsConnection = {
  /** A list of `Wishlist` objects. */
  nodes: Array<Maybe<Wishlist>>;
  /** A list of edges which contains the `Wishlist` and cursor to aid in pagination. */
  edges: Array<WishlistsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Wishlist` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Wishlist = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  visibility?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['String']>;
  occassions?: Maybe<Scalars['String']>;
};

/** A `Wishlist` edge in the connection. */
export type WishlistsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Wishlist` at the end of the edge. */
  node?: Maybe<Wishlist>;
};

/** Methods to use when ordering `Wishlist`. */
export type WishlistsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'VISIBILITY_ASC'
  | 'VISIBILITY_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'QUANTITY_ASC'
  | 'QUANTITY_DESC'
  | 'OCCASSIONS_ASC'
  | 'OCCASSIONS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Wishlist` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type WishlistCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `visibility` field. */
  visibility?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `occassions` field. */
  occassions?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Workspace` values. */
export type WorkspacesConnection = {
  /** A list of `Workspace` objects. */
  nodes: Array<Maybe<Workspace>>;
  /** A list of edges which contains the `Workspace` and cursor to aid in pagination. */
  edges: Array<WorkspacesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Workspace` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Workspace = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['Int']>;
  users?: Maybe<Scalars['Int']>;
  products?: Maybe<Scalars['BigInt']>;
  tasks?: Maybe<Scalars['BigInt']>;
  brands?: Maybe<Scalars['BigInt']>;
  shops?: Maybe<Scalars['Int']>;
  category?: Maybe<Scalars['Int']>;
  isPublic?: Maybe<Scalars['Boolean']>;
  projects?: Maybe<Scalars['BigInt']>;
  author?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  brandsBrandsToworkspaces?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  customersCustomersToworkspaces?: Maybe<Scalars['String']>;
  productsProductsToworkspaces?: Maybe<Scalars['String']>;
  projectsProjectsToworkspaces?: Maybe<Scalars['String']>;
  shopsShopsToworkspaces?: Maybe<Scalars['String']>;
  tasksTasksToworkspaces?: Maybe<Scalars['String']>;
  usersUsersToworkspaces?: Maybe<Scalars['String']>;
};

/** A `Workspace` edge in the connection. */
export type WorkspacesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Workspace` at the end of the edge. */
  node?: Maybe<Workspace>;
};

/** Methods to use when ordering `Workspace`. */
export type WorkspacesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'TASKS_ASC'
  | 'TASKS_DESC'
  | 'BRANDS_ASC'
  | 'BRANDS_DESC'
  | 'SHOPS_ASC'
  | 'SHOPS_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'AUTHOR_ASC'
  | 'AUTHOR_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'BRANDS_BRANDS_TOWORKSPACES_ASC'
  | 'BRANDS_BRANDS_TOWORKSPACES_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'CUSTOMERS_CUSTOMERS_TOWORKSPACES_ASC'
  | 'CUSTOMERS_CUSTOMERS_TOWORKSPACES_DESC'
  | 'PRODUCTS_PRODUCTS_TOWORKSPACES_ASC'
  | 'PRODUCTS_PRODUCTS_TOWORKSPACES_DESC'
  | 'PROJECTS_PROJECTS_TOWORKSPACES_ASC'
  | 'PROJECTS_PROJECTS_TOWORKSPACES_DESC'
  | 'SHOPS_SHOPS_TOWORKSPACES_ASC'
  | 'SHOPS_SHOPS_TOWORKSPACES_DESC'
  | 'TASKS_TASKS_TOWORKSPACES_ASC'
  | 'TASKS_TASKS_TOWORKSPACES_DESC'
  | 'USERS_USERS_TOWORKSPACES_ASC'
  | 'USERS_USERS_TOWORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Workspace` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type WorkspaceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customers` field. */
  customers?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `users` field. */
  users?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `products` field. */
  products?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tasks` field. */
  tasks?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `brands` field. */
  brands?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shops` field. */
  shops?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `projects` field. */
  projects?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `author` field. */
  author?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `brandsBrandsToworkspaces` field. */
  brandsBrandsToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `customersCustomersToworkspaces` field. */
  customersCustomersToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `productsProductsToworkspaces` field. */
  productsProductsToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `projectsProjectsToworkspaces` field. */
  projectsProjectsToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `shopsShopsToworkspaces` field. */
  shopsShopsToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tasksTasksToworkspaces` field. */
  tasksTasksToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `usersUsersToworkspaces` field. */
  usersUsersToworkspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Zone` values. */
export type ZonesConnection = {
  /** A list of `Zone` objects. */
  nodes: Array<Maybe<Zone>>;
  /** A list of edges which contains the `Zone` and cursor to aid in pagination. */
  edges: Array<ZonesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Zone` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Zone = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  scope?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
};

/** A `Zone` edge in the connection. */
export type ZonesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Zone` at the end of the edge. */
  node?: Maybe<Zone>;
};

/** Methods to use when ordering `Zone`. */
export type ZonesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'SCOPE_ASC'
  | 'SCOPE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Zone` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ZoneCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `scope` field. */
  scope?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  /** Creates a single `Account`. */
  createAccount?: Maybe<CreateAccountPayload>;
  /** Creates a single `Agreement`. */
  createAgreement?: Maybe<CreateAgreementPayload>;
  /** Creates a single `Analytic`. */
  createAnalytic?: Maybe<CreateAnalyticPayload>;
  /** Creates a single `Apitoken`. */
  createApitoken?: Maybe<CreateApitokenPayload>;
  /** Creates a single `Article`. */
  createArticle?: Maybe<CreateArticlePayload>;
  /** Creates a single `Attribute`. */
  createAttribute?: Maybe<CreateAttributePayload>;
  /** Creates a single `Brand`. */
  createBrand?: Maybe<CreateBrandPayload>;
  /** Creates a single `CartPriceRule`. */
  createCartPriceRule?: Maybe<CreateCartPriceRulePayload>;
  /** Creates a single `Case`. */
  createCase?: Maybe<CreateCasePayload>;
  /** Creates a single `CatalogPriceRule`. */
  createCatalogPriceRule?: Maybe<CreateCatalogPriceRulePayload>;
  /** Creates a single `Category`. */
  createCategory?: Maybe<CreateCategoryPayload>;
  /** Creates a single `Channel`. */
  createChannel?: Maybe<CreateChannelPayload>;
  /** Creates a single `Checklist`. */
  createChecklist?: Maybe<CreateChecklistPayload>;
  /** Creates a single `City`. */
  createCity?: Maybe<CreateCityPayload>;
  /** Creates a single `Collection`. */
  createCollection?: Maybe<CreateCollectionPayload>;
  /** Creates a single `Comment`. */
  createComment?: Maybe<CreateCommentPayload>;
  /** Creates a single `ContentType`. */
  createContentType?: Maybe<CreateContentTypePayload>;
  /** Creates a single `Contract`. */
  createContract?: Maybe<CreateContractPayload>;
  /** Creates a single `Country`. */
  createCountry?: Maybe<CreateCountryPayload>;
  /** Creates a single `Coupon`. */
  createCoupon?: Maybe<CreateCouponPayload>;
  /** Creates a single `CreditMemo`. */
  createCreditMemo?: Maybe<CreateCreditMemoPayload>;
  /** Creates a single `Currency`. */
  createCurrency?: Maybe<CreateCurrencyPayload>;
  /** Creates a single `CurrencyRate`. */
  createCurrencyRate?: Maybe<CreateCurrencyRatePayload>;
  /** Creates a single `CurrencySymbol`. */
  createCurrencySymbol?: Maybe<CreateCurrencySymbolPayload>;
  /** Creates a single `CustomerGroup`. */
  createCustomerGroup?: Maybe<CreateCustomerGroupPayload>;
  /** Creates a single `Customer`. */
  createCustomer?: Maybe<CreateCustomerPayload>;
  /** Creates a single `Customization`. */
  createCustomization?: Maybe<CreateCustomizationPayload>;
  /** Creates a single `Dashboard`. */
  createDashboard?: Maybe<CreateDashboardPayload>;
  /** Creates a single `Deepdive`. */
  createDeepdive?: Maybe<CreateDeepdivePayload>;
  /** Creates a single `Digiboard`. */
  createDigiboard?: Maybe<CreateDigiboardPayload>;
  /** Creates a single `Email`. */
  createEmail?: Maybe<CreateEmailPayload>;
  /** Creates a single `Endofshift`. */
  createEndofshift?: Maybe<CreateEndofshiftPayload>;
  /** Creates a single `Event`. */
  createEvent?: Maybe<CreateEventPayload>;
  /** Creates a single `Fullfillment`. */
  createFullfillment?: Maybe<CreateFullfillmentPayload>;
  /** Creates a single `GiftCertificate`. */
  createGiftCertificate?: Maybe<CreateGiftCertificatePayload>;
  /** Creates a single `Glossary`. */
  createGlossary?: Maybe<CreateGlossaryPayload>;
  /** Creates a single `Importm`. */
  createImportm?: Maybe<CreateImportmPayload>;
  /** Creates a single `Integration`. */
  createIntegration?: Maybe<CreateIntegrationPayload>;
  /** Creates a single `Internalization`. */
  createInternalization?: Maybe<CreateInternalizationPayload>;
  /** Creates a single `Invitation`. */
  createInvitation?: Maybe<CreateInvitationPayload>;
  /** Creates a single `Invoice`. */
  createInvoice?: Maybe<CreateInvoicePayload>;
  /** Creates a single `Lead`. */
  createLead?: Maybe<CreateLeadPayload>;
  /** Creates a single `Manufacturer`. */
  createManufacturer?: Maybe<CreateManufacturerPayload>;
  /** Creates a single `Mediamanager`. */
  createMediamanager?: Maybe<CreateMediamanagerPayload>;
  /** Creates a single `Meeting`. */
  createMeeting?: Maybe<CreateMeetingPayload>;
  /** Creates a single `Message`. */
  createMessage?: Maybe<CreateMessagePayload>;
  /** Creates a single `Newsletter`. */
  createNewsletter?: Maybe<CreateNewsletterPayload>;
  /** Creates a single `Ooto`. */
  createOoto?: Maybe<CreateOotoPayload>;
  /** Creates a single `Opportunity`. */
  createOpportunity?: Maybe<CreateOpportunityPayload>;
  /** Creates a single `Order`. */
  createOrder?: Maybe<CreateOrderPayload>;
  /** Creates a single `Page`. */
  createPage?: Maybe<CreatePagePayload>;
  /** Creates a single `Partner`. */
  createPartner?: Maybe<CreatePartnerPayload>;
  /** Creates a single `Payment`. */
  createPayment?: Maybe<CreatePaymentPayload>;
  /** Creates a single `Permission`. */
  createPermission?: Maybe<CreatePermissionPayload>;
  /** Creates a single `Plugin`. */
  createPlugin?: Maybe<CreatePluginPayload>;
  /** Creates a single `Poll`. */
  createPoll?: Maybe<CreatePollPayload>;
  /** Creates a single `ProductType`. */
  createProductType?: Maybe<CreateProductTypePayload>;
  /** Creates a single `Product`. */
  createProduct?: Maybe<CreateProductPayload>;
  /** Creates a single `Project`. */
  createProject?: Maybe<CreateProjectPayload>;
  /** Creates a single `Provider`. */
  createProvider?: Maybe<CreateProviderPayload>;
  /** Creates a single `Quote`. */
  createQuote?: Maybe<CreateQuotePayload>;
  /** Creates a single `Rating`. */
  createRating?: Maybe<CreateRatingPayload>;
  /** Creates a single `Report`. */
  createReport?: Maybe<CreateReportPayload>;
  /** Creates a single `Return`. */
  createReturn?: Maybe<CreateReturnPayload>;
  /** Creates a single `Review`. */
  createReview?: Maybe<CreateReviewPayload>;
  /** Creates a single `Reward`. */
  createReward?: Maybe<CreateRewardPayload>;
  /** Creates a single `Role`. */
  createRole?: Maybe<CreateRolePayload>;
  /** Creates a single `Scheduler`. */
  createScheduler?: Maybe<CreateSchedulerPayload>;
  /** Creates a single `Segment`. */
  createSegment?: Maybe<CreateSegmentPayload>;
  /** Creates a single `Setting`. */
  createSetting?: Maybe<CreateSettingPayload>;
  /** Creates a single `Shipment`. */
  createShipment?: Maybe<CreateShipmentPayload>;
  /** Creates a single `SpecialDiscount`. */
  createSpecialDiscount?: Maybe<CreateSpecialDiscountPayload>;
  /** Creates a single `State`. */
  createState?: Maybe<CreateStatePayload>;
  /** Creates a single `Statistic`. */
  createStatistic?: Maybe<CreateStatisticPayload>;
  /** Creates a single `Stock`. */
  createStock?: Maybe<CreateStockPayload>;
  /** Creates a single `Survey`. */
  createSurvey?: Maybe<CreateSurveyPayload>;
  /** Creates a single `Tag`. */
  createTag?: Maybe<CreateTagPayload>;
  /** Creates a single `Target`. */
  createTarget?: Maybe<CreateTargetPayload>;
  /** Creates a single `TaxCategory`. */
  createTaxCategory?: Maybe<CreateTaxCategoryPayload>;
  /** Creates a single `TaxRate`. */
  createTaxRate?: Maybe<CreateTaxRatePayload>;
  /** Creates a single `TaxRule`. */
  createTaxRule?: Maybe<CreateTaxRulePayload>;
  /** Creates a single `Template`. */
  createTemplate?: Maybe<CreateTemplatePayload>;
  /** Creates a single `Theme`. */
  createTheme?: Maybe<CreateThemePayload>;
  /** Creates a single `Ticketing`. */
  createTicketing?: Maybe<CreateTicketingPayload>;
  /** Creates a single `Training`. */
  createTraining?: Maybe<CreateTrainingPayload>;
  /** Creates a single `Transaction`. */
  createTransaction?: Maybe<CreateTransactionPayload>;
  /** Creates a single `UploadFile`. */
  createUploadFile?: Maybe<CreateUploadFilePayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `Vendor`. */
  createVendor?: Maybe<CreateVendorPayload>;
  /** Creates a single `Visit`. */
  createVisit?: Maybe<CreateVisitPayload>;
  /** Creates a single `Warehouse`. */
  createWarehouse?: Maybe<CreateWarehousePayload>;
  /** Creates a single `Webhook`. */
  createWebhook?: Maybe<CreateWebhookPayload>;
  /** Creates a single `Website`. */
  createWebsite?: Maybe<CreateWebsitePayload>;
  /** Creates a single `Wishlist`. */
  createWishlist?: Maybe<CreateWishlistPayload>;
  /** Creates a single `Workspace`. */
  createWorkspace?: Maybe<CreateWorkspacePayload>;
  /** Creates a single `Zone`. */
  createZone?: Maybe<CreateZonePayload>;
  /** Updates a single `Account` using its globally unique id and a patch. */
  updateAccount?: Maybe<UpdateAccountPayload>;
  /** Updates a single `Account` using a unique key and a patch. */
  updateAccountById?: Maybe<UpdateAccountPayload>;
  /** Updates a single `Agreement` using its globally unique id and a patch. */
  updateAgreement?: Maybe<UpdateAgreementPayload>;
  /** Updates a single `Agreement` using a unique key and a patch. */
  updateAgreementById?: Maybe<UpdateAgreementPayload>;
  /** Updates a single `Analytic` using its globally unique id and a patch. */
  updateAnalytic?: Maybe<UpdateAnalyticPayload>;
  /** Updates a single `Analytic` using a unique key and a patch. */
  updateAnalyticById?: Maybe<UpdateAnalyticPayload>;
  /** Updates a single `Apitoken` using its globally unique id and a patch. */
  updateApitoken?: Maybe<UpdateApitokenPayload>;
  /** Updates a single `Apitoken` using a unique key and a patch. */
  updateApitokenById?: Maybe<UpdateApitokenPayload>;
  /** Updates a single `Article` using its globally unique id and a patch. */
  updateArticle?: Maybe<UpdateArticlePayload>;
  /** Updates a single `Article` using a unique key and a patch. */
  updateArticleById?: Maybe<UpdateArticlePayload>;
  /** Updates a single `Attribute` using its globally unique id and a patch. */
  updateAttribute?: Maybe<UpdateAttributePayload>;
  /** Updates a single `Attribute` using a unique key and a patch. */
  updateAttributeById?: Maybe<UpdateAttributePayload>;
  /** Updates a single `Brand` using its globally unique id and a patch. */
  updateBrand?: Maybe<UpdateBrandPayload>;
  /** Updates a single `Brand` using a unique key and a patch. */
  updateBrandById?: Maybe<UpdateBrandPayload>;
  /** Updates a single `CartPriceRule` using its globally unique id and a patch. */
  updateCartPriceRule?: Maybe<UpdateCartPriceRulePayload>;
  /** Updates a single `CartPriceRule` using a unique key and a patch. */
  updateCartPriceRuleById?: Maybe<UpdateCartPriceRulePayload>;
  /** Updates a single `Case` using its globally unique id and a patch. */
  updateCase?: Maybe<UpdateCasePayload>;
  /** Updates a single `Case` using a unique key and a patch. */
  updateCaseById?: Maybe<UpdateCasePayload>;
  /** Updates a single `CatalogPriceRule` using its globally unique id and a patch. */
  updateCatalogPriceRule?: Maybe<UpdateCatalogPriceRulePayload>;
  /** Updates a single `CatalogPriceRule` using a unique key and a patch. */
  updateCatalogPriceRuleById?: Maybe<UpdateCatalogPriceRulePayload>;
  /** Updates a single `Category` using its globally unique id and a patch. */
  updateCategory?: Maybe<UpdateCategoryPayload>;
  /** Updates a single `Category` using a unique key and a patch. */
  updateCategoryById?: Maybe<UpdateCategoryPayload>;
  /** Updates a single `Channel` using its globally unique id and a patch. */
  updateChannel?: Maybe<UpdateChannelPayload>;
  /** Updates a single `Channel` using a unique key and a patch. */
  updateChannelById?: Maybe<UpdateChannelPayload>;
  /** Updates a single `Checklist` using its globally unique id and a patch. */
  updateChecklist?: Maybe<UpdateChecklistPayload>;
  /** Updates a single `Checklist` using a unique key and a patch. */
  updateChecklistById?: Maybe<UpdateChecklistPayload>;
  /** Updates a single `City` using its globally unique id and a patch. */
  updateCity?: Maybe<UpdateCityPayload>;
  /** Updates a single `City` using a unique key and a patch. */
  updateCityById?: Maybe<UpdateCityPayload>;
  /** Updates a single `Collection` using its globally unique id and a patch. */
  updateCollection?: Maybe<UpdateCollectionPayload>;
  /** Updates a single `Collection` using a unique key and a patch. */
  updateCollectionById?: Maybe<UpdateCollectionPayload>;
  /** Updates a single `Comment` using its globally unique id and a patch. */
  updateComment?: Maybe<UpdateCommentPayload>;
  /** Updates a single `Comment` using a unique key and a patch. */
  updateCommentById?: Maybe<UpdateCommentPayload>;
  /** Updates a single `ContentType` using its globally unique id and a patch. */
  updateContentType?: Maybe<UpdateContentTypePayload>;
  /** Updates a single `ContentType` using a unique key and a patch. */
  updateContentTypeById?: Maybe<UpdateContentTypePayload>;
  /** Updates a single `Contract` using its globally unique id and a patch. */
  updateContract?: Maybe<UpdateContractPayload>;
  /** Updates a single `Contract` using a unique key and a patch. */
  updateContractById?: Maybe<UpdateContractPayload>;
  /** Updates a single `Country` using its globally unique id and a patch. */
  updateCountry?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Country` using a unique key and a patch. */
  updateCountryById?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Coupon` using its globally unique id and a patch. */
  updateCoupon?: Maybe<UpdateCouponPayload>;
  /** Updates a single `Coupon` using a unique key and a patch. */
  updateCouponById?: Maybe<UpdateCouponPayload>;
  /** Updates a single `CreditMemo` using its globally unique id and a patch. */
  updateCreditMemo?: Maybe<UpdateCreditMemoPayload>;
  /** Updates a single `CreditMemo` using a unique key and a patch. */
  updateCreditMemoByCreditMemoAndId?: Maybe<UpdateCreditMemoPayload>;
  /** Updates a single `Currency` using its globally unique id and a patch. */
  updateCurrency?: Maybe<UpdateCurrencyPayload>;
  /** Updates a single `Currency` using a unique key and a patch. */
  updateCurrencyById?: Maybe<UpdateCurrencyPayload>;
  /** Updates a single `CurrencyRate` using its globally unique id and a patch. */
  updateCurrencyRate?: Maybe<UpdateCurrencyRatePayload>;
  /** Updates a single `CurrencyRate` using a unique key and a patch. */
  updateCurrencyRateByImportService?: Maybe<UpdateCurrencyRatePayload>;
  /** Updates a single `CurrencySymbol` using its globally unique id and a patch. */
  updateCurrencySymbol?: Maybe<UpdateCurrencySymbolPayload>;
  /** Updates a single `CurrencySymbol` using a unique key and a patch. */
  updateCurrencySymbolBySymbol?: Maybe<UpdateCurrencySymbolPayload>;
  /** Updates a single `CustomerGroup` using its globally unique id and a patch. */
  updateCustomerGroup?: Maybe<UpdateCustomerGroupPayload>;
  /** Updates a single `CustomerGroup` using a unique key and a patch. */
  updateCustomerGroupById?: Maybe<UpdateCustomerGroupPayload>;
  /** Updates a single `Customer` using its globally unique id and a patch. */
  updateCustomer?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `Customer` using a unique key and a patch. */
  updateCustomerById?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `Customization` using its globally unique id and a patch. */
  updateCustomization?: Maybe<UpdateCustomizationPayload>;
  /** Updates a single `Customization` using a unique key and a patch. */
  updateCustomizationById?: Maybe<UpdateCustomizationPayload>;
  /** Updates a single `Dashboard` using its globally unique id and a patch. */
  updateDashboard?: Maybe<UpdateDashboardPayload>;
  /** Updates a single `Dashboard` using a unique key and a patch. */
  updateDashboardById?: Maybe<UpdateDashboardPayload>;
  /** Updates a single `Deepdive` using its globally unique id and a patch. */
  updateDeepdive?: Maybe<UpdateDeepdivePayload>;
  /** Updates a single `Deepdive` using a unique key and a patch. */
  updateDeepdiveById?: Maybe<UpdateDeepdivePayload>;
  /** Updates a single `Digiboard` using its globally unique id and a patch. */
  updateDigiboard?: Maybe<UpdateDigiboardPayload>;
  /** Updates a single `Digiboard` using a unique key and a patch. */
  updateDigiboardById?: Maybe<UpdateDigiboardPayload>;
  /** Updates a single `Email` using its globally unique id and a patch. */
  updateEmail?: Maybe<UpdateEmailPayload>;
  /** Updates a single `Email` using a unique key and a patch. */
  updateEmailById?: Maybe<UpdateEmailPayload>;
  /** Updates a single `Endofshift` using its globally unique id and a patch. */
  updateEndofshift?: Maybe<UpdateEndofshiftPayload>;
  /** Updates a single `Endofshift` using a unique key and a patch. */
  updateEndofshiftById?: Maybe<UpdateEndofshiftPayload>;
  /** Updates a single `Event` using its globally unique id and a patch. */
  updateEvent?: Maybe<UpdateEventPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEventById?: Maybe<UpdateEventPayload>;
  /** Updates a single `Fullfillment` using its globally unique id and a patch. */
  updateFullfillment?: Maybe<UpdateFullfillmentPayload>;
  /** Updates a single `Fullfillment` using a unique key and a patch. */
  updateFullfillmentById?: Maybe<UpdateFullfillmentPayload>;
  /** Updates a single `GiftCertificate` using its globally unique id and a patch. */
  updateGiftCertificate?: Maybe<UpdateGiftCertificatePayload>;
  /** Updates a single `GiftCertificate` using a unique key and a patch. */
  updateGiftCertificateById?: Maybe<UpdateGiftCertificatePayload>;
  /** Updates a single `Glossary` using its globally unique id and a patch. */
  updateGlossary?: Maybe<UpdateGlossaryPayload>;
  /** Updates a single `Glossary` using a unique key and a patch. */
  updateGlossaryById?: Maybe<UpdateGlossaryPayload>;
  /** Updates a single `Importm` using its globally unique id and a patch. */
  updateImportm?: Maybe<UpdateImportmPayload>;
  /** Updates a single `Importm` using a unique key and a patch. */
  updateImportmById?: Maybe<UpdateImportmPayload>;
  /** Updates a single `Integration` using its globally unique id and a patch. */
  updateIntegration?: Maybe<UpdateIntegrationPayload>;
  /** Updates a single `Integration` using a unique key and a patch. */
  updateIntegrationById?: Maybe<UpdateIntegrationPayload>;
  /** Updates a single `Internalization` using its globally unique id and a patch. */
  updateInternalization?: Maybe<UpdateInternalizationPayload>;
  /** Updates a single `Internalization` using a unique key and a patch. */
  updateInternalizationById?: Maybe<UpdateInternalizationPayload>;
  /** Updates a single `Invitation` using its globally unique id and a patch. */
  updateInvitation?: Maybe<UpdateInvitationPayload>;
  /** Updates a single `Invitation` using a unique key and a patch. */
  updateInvitationById?: Maybe<UpdateInvitationPayload>;
  /** Updates a single `Invoice` using its globally unique id and a patch. */
  updateInvoice?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `Invoice` using a unique key and a patch. */
  updateInvoiceById?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `Lead` using its globally unique id and a patch. */
  updateLead?: Maybe<UpdateLeadPayload>;
  /** Updates a single `Lead` using a unique key and a patch. */
  updateLeadById?: Maybe<UpdateLeadPayload>;
  /** Updates a single `Manufacturer` using its globally unique id and a patch. */
  updateManufacturer?: Maybe<UpdateManufacturerPayload>;
  /** Updates a single `Manufacturer` using a unique key and a patch. */
  updateManufacturerById?: Maybe<UpdateManufacturerPayload>;
  /** Updates a single `Mediamanager` using its globally unique id and a patch. */
  updateMediamanager?: Maybe<UpdateMediamanagerPayload>;
  /** Updates a single `Mediamanager` using a unique key and a patch. */
  updateMediamanagerById?: Maybe<UpdateMediamanagerPayload>;
  /** Updates a single `Meeting` using its globally unique id and a patch. */
  updateMeeting?: Maybe<UpdateMeetingPayload>;
  /** Updates a single `Meeting` using a unique key and a patch. */
  updateMeetingById?: Maybe<UpdateMeetingPayload>;
  /** Updates a single `Message` using its globally unique id and a patch. */
  updateMessage?: Maybe<UpdateMessagePayload>;
  /** Updates a single `Message` using a unique key and a patch. */
  updateMessageById?: Maybe<UpdateMessagePayload>;
  /** Updates a single `Newsletter` using its globally unique id and a patch. */
  updateNewsletter?: Maybe<UpdateNewsletterPayload>;
  /** Updates a single `Newsletter` using a unique key and a patch. */
  updateNewsletterById?: Maybe<UpdateNewsletterPayload>;
  /** Updates a single `Ooto` using its globally unique id and a patch. */
  updateOoto?: Maybe<UpdateOotoPayload>;
  /** Updates a single `Ooto` using a unique key and a patch. */
  updateOotoById?: Maybe<UpdateOotoPayload>;
  /** Updates a single `Opportunity` using its globally unique id and a patch. */
  updateOpportunity?: Maybe<UpdateOpportunityPayload>;
  /** Updates a single `Opportunity` using a unique key and a patch. */
  updateOpportunityById?: Maybe<UpdateOpportunityPayload>;
  /** Updates a single `Order` using its globally unique id and a patch. */
  updateOrder?: Maybe<UpdateOrderPayload>;
  /** Updates a single `Order` using a unique key and a patch. */
  updateOrderById?: Maybe<UpdateOrderPayload>;
  /** Updates a single `Page` using its globally unique id and a patch. */
  updatePage?: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePageById?: Maybe<UpdatePagePayload>;
  /** Updates a single `Partner` using its globally unique id and a patch. */
  updatePartner?: Maybe<UpdatePartnerPayload>;
  /** Updates a single `Partner` using a unique key and a patch. */
  updatePartnerById?: Maybe<UpdatePartnerPayload>;
  /** Updates a single `Payment` using its globally unique id and a patch. */
  updatePayment?: Maybe<UpdatePaymentPayload>;
  /** Updates a single `Payment` using a unique key and a patch. */
  updatePaymentById?: Maybe<UpdatePaymentPayload>;
  /** Updates a single `Permission` using its globally unique id and a patch. */
  updatePermission?: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Permission` using a unique key and a patch. */
  updatePermissionById?: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Plugin` using its globally unique id and a patch. */
  updatePlugin?: Maybe<UpdatePluginPayload>;
  /** Updates a single `Plugin` using a unique key and a patch. */
  updatePluginById?: Maybe<UpdatePluginPayload>;
  /** Updates a single `Poll` using its globally unique id and a patch. */
  updatePoll?: Maybe<UpdatePollPayload>;
  /** Updates a single `Poll` using a unique key and a patch. */
  updatePollById?: Maybe<UpdatePollPayload>;
  /** Updates a single `ProductType` using its globally unique id and a patch. */
  updateProductType?: Maybe<UpdateProductTypePayload>;
  /** Updates a single `ProductType` using a unique key and a patch. */
  updateProductTypeById?: Maybe<UpdateProductTypePayload>;
  /** Updates a single `Product` using its globally unique id and a patch. */
  updateProduct?: Maybe<UpdateProductPayload>;
  /** Updates a single `Product` using a unique key and a patch. */
  updateProductById?: Maybe<UpdateProductPayload>;
  /** Updates a single `Project` using its globally unique id and a patch. */
  updateProject?: Maybe<UpdateProjectPayload>;
  /** Updates a single `Project` using a unique key and a patch. */
  updateProjectById?: Maybe<UpdateProjectPayload>;
  /** Updates a single `Provider` using its globally unique id and a patch. */
  updateProvider?: Maybe<UpdateProviderPayload>;
  /** Updates a single `Provider` using a unique key and a patch. */
  updateProviderById?: Maybe<UpdateProviderPayload>;
  /** Updates a single `Quote` using its globally unique id and a patch. */
  updateQuote?: Maybe<UpdateQuotePayload>;
  /** Updates a single `Quote` using a unique key and a patch. */
  updateQuoteById?: Maybe<UpdateQuotePayload>;
  /** Updates a single `Rating` using its globally unique id and a patch. */
  updateRating?: Maybe<UpdateRatingPayload>;
  /** Updates a single `Rating` using a unique key and a patch. */
  updateRatingById?: Maybe<UpdateRatingPayload>;
  /** Updates a single `Report` using its globally unique id and a patch. */
  updateReport?: Maybe<UpdateReportPayload>;
  /** Updates a single `Report` using a unique key and a patch. */
  updateReportById?: Maybe<UpdateReportPayload>;
  /** Updates a single `Return` using its globally unique id and a patch. */
  updateReturn?: Maybe<UpdateReturnPayload>;
  /** Updates a single `Return` using a unique key and a patch. */
  updateReturnById?: Maybe<UpdateReturnPayload>;
  /** Updates a single `Review` using its globally unique id and a patch. */
  updateReview?: Maybe<UpdateReviewPayload>;
  /** Updates a single `Review` using a unique key and a patch. */
  updateReviewById?: Maybe<UpdateReviewPayload>;
  /** Updates a single `Reward` using its globally unique id and a patch. */
  updateReward?: Maybe<UpdateRewardPayload>;
  /** Updates a single `Reward` using a unique key and a patch. */
  updateRewardById?: Maybe<UpdateRewardPayload>;
  /** Updates a single `Role` using its globally unique id and a patch. */
  updateRole?: Maybe<UpdateRolePayload>;
  /** Updates a single `Role` using a unique key and a patch. */
  updateRoleById?: Maybe<UpdateRolePayload>;
  /** Updates a single `Scheduler` using its globally unique id and a patch. */
  updateScheduler?: Maybe<UpdateSchedulerPayload>;
  /** Updates a single `Scheduler` using a unique key and a patch. */
  updateSchedulerById?: Maybe<UpdateSchedulerPayload>;
  /** Updates a single `Segment` using its globally unique id and a patch. */
  updateSegment?: Maybe<UpdateSegmentPayload>;
  /** Updates a single `Segment` using a unique key and a patch. */
  updateSegmentById?: Maybe<UpdateSegmentPayload>;
  /** Updates a single `Setting` using its globally unique id and a patch. */
  updateSetting?: Maybe<UpdateSettingPayload>;
  /** Updates a single `Setting` using a unique key and a patch. */
  updateSettingById?: Maybe<UpdateSettingPayload>;
  /** Updates a single `Shipment` using its globally unique id and a patch. */
  updateShipment?: Maybe<UpdateShipmentPayload>;
  /** Updates a single `Shipment` using a unique key and a patch. */
  updateShipmentById?: Maybe<UpdateShipmentPayload>;
  /** Updates a single `SpecialDiscount` using its globally unique id and a patch. */
  updateSpecialDiscount?: Maybe<UpdateSpecialDiscountPayload>;
  /** Updates a single `SpecialDiscount` using a unique key and a patch. */
  updateSpecialDiscountById?: Maybe<UpdateSpecialDiscountPayload>;
  /** Updates a single `State` using its globally unique id and a patch. */
  updateState?: Maybe<UpdateStatePayload>;
  /** Updates a single `State` using a unique key and a patch. */
  updateStateById?: Maybe<UpdateStatePayload>;
  /** Updates a single `Statistic` using its globally unique id and a patch. */
  updateStatistic?: Maybe<UpdateStatisticPayload>;
  /** Updates a single `Statistic` using a unique key and a patch. */
  updateStatisticById?: Maybe<UpdateStatisticPayload>;
  /** Updates a single `Stock` using its globally unique id and a patch. */
  updateStock?: Maybe<UpdateStockPayload>;
  /** Updates a single `Stock` using a unique key and a patch. */
  updateStockById?: Maybe<UpdateStockPayload>;
  /** Updates a single `Survey` using its globally unique id and a patch. */
  updateSurvey?: Maybe<UpdateSurveyPayload>;
  /** Updates a single `Survey` using a unique key and a patch. */
  updateSurveyById?: Maybe<UpdateSurveyPayload>;
  /** Updates a single `Tag` using its globally unique id and a patch. */
  updateTag?: Maybe<UpdateTagPayload>;
  /** Updates a single `Tag` using a unique key and a patch. */
  updateTagById?: Maybe<UpdateTagPayload>;
  /** Updates a single `Target` using its globally unique id and a patch. */
  updateTarget?: Maybe<UpdateTargetPayload>;
  /** Updates a single `Target` using a unique key and a patch. */
  updateTargetById?: Maybe<UpdateTargetPayload>;
  /** Updates a single `TaxCategory` using its globally unique id and a patch. */
  updateTaxCategory?: Maybe<UpdateTaxCategoryPayload>;
  /** Updates a single `TaxCategory` using a unique key and a patch. */
  updateTaxCategoryById?: Maybe<UpdateTaxCategoryPayload>;
  /** Updates a single `TaxRate` using its globally unique id and a patch. */
  updateTaxRate?: Maybe<UpdateTaxRatePayload>;
  /** Updates a single `TaxRate` using a unique key and a patch. */
  updateTaxRateById?: Maybe<UpdateTaxRatePayload>;
  /** Updates a single `TaxRule` using its globally unique id and a patch. */
  updateTaxRule?: Maybe<UpdateTaxRulePayload>;
  /** Updates a single `TaxRule` using a unique key and a patch. */
  updateTaxRuleById?: Maybe<UpdateTaxRulePayload>;
  /** Updates a single `Template` using its globally unique id and a patch. */
  updateTemplate?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `Template` using a unique key and a patch. */
  updateTemplateById?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `Theme` using its globally unique id and a patch. */
  updateTheme?: Maybe<UpdateThemePayload>;
  /** Updates a single `Theme` using a unique key and a patch. */
  updateThemeById?: Maybe<UpdateThemePayload>;
  /** Updates a single `Ticketing` using its globally unique id and a patch. */
  updateTicketing?: Maybe<UpdateTicketingPayload>;
  /** Updates a single `Ticketing` using a unique key and a patch. */
  updateTicketingById?: Maybe<UpdateTicketingPayload>;
  /** Updates a single `Training` using its globally unique id and a patch. */
  updateTraining?: Maybe<UpdateTrainingPayload>;
  /** Updates a single `Training` using a unique key and a patch. */
  updateTrainingById?: Maybe<UpdateTrainingPayload>;
  /** Updates a single `Transaction` using its globally unique id and a patch. */
  updateTransaction?: Maybe<UpdateTransactionPayload>;
  /** Updates a single `Transaction` using a unique key and a patch. */
  updateTransactionById?: Maybe<UpdateTransactionPayload>;
  /** Updates a single `UploadFile` using its globally unique id and a patch. */
  updateUploadFile?: Maybe<UpdateUploadFilePayload>;
  /** Updates a single `UploadFile` using a unique key and a patch. */
  updateUploadFileById?: Maybe<UpdateUploadFilePayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserById?: Maybe<UpdateUserPayload>;
  /** Updates a single `Vendor` using its globally unique id and a patch. */
  updateVendor?: Maybe<UpdateVendorPayload>;
  /** Updates a single `Vendor` using a unique key and a patch. */
  updateVendorById?: Maybe<UpdateVendorPayload>;
  /** Updates a single `Visit` using its globally unique id and a patch. */
  updateVisit?: Maybe<UpdateVisitPayload>;
  /** Updates a single `Visit` using a unique key and a patch. */
  updateVisitById?: Maybe<UpdateVisitPayload>;
  /** Updates a single `Warehouse` using its globally unique id and a patch. */
  updateWarehouse?: Maybe<UpdateWarehousePayload>;
  /** Updates a single `Warehouse` using a unique key and a patch. */
  updateWarehouseById?: Maybe<UpdateWarehousePayload>;
  /** Updates a single `Webhook` using its globally unique id and a patch. */
  updateWebhook?: Maybe<UpdateWebhookPayload>;
  /** Updates a single `Webhook` using a unique key and a patch. */
  updateWebhookById?: Maybe<UpdateWebhookPayload>;
  /** Updates a single `Website` using its globally unique id and a patch. */
  updateWebsite?: Maybe<UpdateWebsitePayload>;
  /** Updates a single `Website` using a unique key and a patch. */
  updateWebsiteById?: Maybe<UpdateWebsitePayload>;
  /** Updates a single `Wishlist` using its globally unique id and a patch. */
  updateWishlist?: Maybe<UpdateWishlistPayload>;
  /** Updates a single `Wishlist` using a unique key and a patch. */
  updateWishlistById?: Maybe<UpdateWishlistPayload>;
  /** Updates a single `Workspace` using its globally unique id and a patch. */
  updateWorkspace?: Maybe<UpdateWorkspacePayload>;
  /** Updates a single `Workspace` using a unique key and a patch. */
  updateWorkspaceById?: Maybe<UpdateWorkspacePayload>;
  /** Updates a single `Zone` using its globally unique id and a patch. */
  updateZone?: Maybe<UpdateZonePayload>;
  /** Updates a single `Zone` using a unique key and a patch. */
  updateZoneById?: Maybe<UpdateZonePayload>;
  /** Deletes a single `Account` using its globally unique id. */
  deleteAccount?: Maybe<DeleteAccountPayload>;
  /** Deletes a single `Account` using a unique key. */
  deleteAccountById?: Maybe<DeleteAccountPayload>;
  /** Deletes a single `Agreement` using its globally unique id. */
  deleteAgreement?: Maybe<DeleteAgreementPayload>;
  /** Deletes a single `Agreement` using a unique key. */
  deleteAgreementById?: Maybe<DeleteAgreementPayload>;
  /** Deletes a single `Analytic` using its globally unique id. */
  deleteAnalytic?: Maybe<DeleteAnalyticPayload>;
  /** Deletes a single `Analytic` using a unique key. */
  deleteAnalyticById?: Maybe<DeleteAnalyticPayload>;
  /** Deletes a single `Apitoken` using its globally unique id. */
  deleteApitoken?: Maybe<DeleteApitokenPayload>;
  /** Deletes a single `Apitoken` using a unique key. */
  deleteApitokenById?: Maybe<DeleteApitokenPayload>;
  /** Deletes a single `Article` using its globally unique id. */
  deleteArticle?: Maybe<DeleteArticlePayload>;
  /** Deletes a single `Article` using a unique key. */
  deleteArticleById?: Maybe<DeleteArticlePayload>;
  /** Deletes a single `Attribute` using its globally unique id. */
  deleteAttribute?: Maybe<DeleteAttributePayload>;
  /** Deletes a single `Attribute` using a unique key. */
  deleteAttributeById?: Maybe<DeleteAttributePayload>;
  /** Deletes a single `Brand` using its globally unique id. */
  deleteBrand?: Maybe<DeleteBrandPayload>;
  /** Deletes a single `Brand` using a unique key. */
  deleteBrandById?: Maybe<DeleteBrandPayload>;
  /** Deletes a single `CartPriceRule` using its globally unique id. */
  deleteCartPriceRule?: Maybe<DeleteCartPriceRulePayload>;
  /** Deletes a single `CartPriceRule` using a unique key. */
  deleteCartPriceRuleById?: Maybe<DeleteCartPriceRulePayload>;
  /** Deletes a single `Case` using its globally unique id. */
  deleteCase?: Maybe<DeleteCasePayload>;
  /** Deletes a single `Case` using a unique key. */
  deleteCaseById?: Maybe<DeleteCasePayload>;
  /** Deletes a single `CatalogPriceRule` using its globally unique id. */
  deleteCatalogPriceRule?: Maybe<DeleteCatalogPriceRulePayload>;
  /** Deletes a single `CatalogPriceRule` using a unique key. */
  deleteCatalogPriceRuleById?: Maybe<DeleteCatalogPriceRulePayload>;
  /** Deletes a single `Category` using its globally unique id. */
  deleteCategory?: Maybe<DeleteCategoryPayload>;
  /** Deletes a single `Category` using a unique key. */
  deleteCategoryById?: Maybe<DeleteCategoryPayload>;
  /** Deletes a single `Channel` using its globally unique id. */
  deleteChannel?: Maybe<DeleteChannelPayload>;
  /** Deletes a single `Channel` using a unique key. */
  deleteChannelById?: Maybe<DeleteChannelPayload>;
  /** Deletes a single `Checklist` using its globally unique id. */
  deleteChecklist?: Maybe<DeleteChecklistPayload>;
  /** Deletes a single `Checklist` using a unique key. */
  deleteChecklistById?: Maybe<DeleteChecklistPayload>;
  /** Deletes a single `City` using its globally unique id. */
  deleteCity?: Maybe<DeleteCityPayload>;
  /** Deletes a single `City` using a unique key. */
  deleteCityById?: Maybe<DeleteCityPayload>;
  /** Deletes a single `Collection` using its globally unique id. */
  deleteCollection?: Maybe<DeleteCollectionPayload>;
  /** Deletes a single `Collection` using a unique key. */
  deleteCollectionById?: Maybe<DeleteCollectionPayload>;
  /** Deletes a single `Comment` using its globally unique id. */
  deleteComment?: Maybe<DeleteCommentPayload>;
  /** Deletes a single `Comment` using a unique key. */
  deleteCommentById?: Maybe<DeleteCommentPayload>;
  /** Deletes a single `ContentType` using its globally unique id. */
  deleteContentType?: Maybe<DeleteContentTypePayload>;
  /** Deletes a single `ContentType` using a unique key. */
  deleteContentTypeById?: Maybe<DeleteContentTypePayload>;
  /** Deletes a single `Contract` using its globally unique id. */
  deleteContract?: Maybe<DeleteContractPayload>;
  /** Deletes a single `Contract` using a unique key. */
  deleteContractById?: Maybe<DeleteContractPayload>;
  /** Deletes a single `Country` using its globally unique id. */
  deleteCountry?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Country` using a unique key. */
  deleteCountryById?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Coupon` using its globally unique id. */
  deleteCoupon?: Maybe<DeleteCouponPayload>;
  /** Deletes a single `Coupon` using a unique key. */
  deleteCouponById?: Maybe<DeleteCouponPayload>;
  /** Deletes a single `CreditMemo` using its globally unique id. */
  deleteCreditMemo?: Maybe<DeleteCreditMemoPayload>;
  /** Deletes a single `CreditMemo` using a unique key. */
  deleteCreditMemoByCreditMemoAndId?: Maybe<DeleteCreditMemoPayload>;
  /** Deletes a single `Currency` using its globally unique id. */
  deleteCurrency?: Maybe<DeleteCurrencyPayload>;
  /** Deletes a single `Currency` using a unique key. */
  deleteCurrencyById?: Maybe<DeleteCurrencyPayload>;
  /** Deletes a single `CurrencyRate` using its globally unique id. */
  deleteCurrencyRate?: Maybe<DeleteCurrencyRatePayload>;
  /** Deletes a single `CurrencyRate` using a unique key. */
  deleteCurrencyRateByImportService?: Maybe<DeleteCurrencyRatePayload>;
  /** Deletes a single `CurrencySymbol` using its globally unique id. */
  deleteCurrencySymbol?: Maybe<DeleteCurrencySymbolPayload>;
  /** Deletes a single `CurrencySymbol` using a unique key. */
  deleteCurrencySymbolBySymbol?: Maybe<DeleteCurrencySymbolPayload>;
  /** Deletes a single `CustomerGroup` using its globally unique id. */
  deleteCustomerGroup?: Maybe<DeleteCustomerGroupPayload>;
  /** Deletes a single `CustomerGroup` using a unique key. */
  deleteCustomerGroupById?: Maybe<DeleteCustomerGroupPayload>;
  /** Deletes a single `Customer` using its globally unique id. */
  deleteCustomer?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `Customer` using a unique key. */
  deleteCustomerById?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `Customization` using its globally unique id. */
  deleteCustomization?: Maybe<DeleteCustomizationPayload>;
  /** Deletes a single `Customization` using a unique key. */
  deleteCustomizationById?: Maybe<DeleteCustomizationPayload>;
  /** Deletes a single `Dashboard` using its globally unique id. */
  deleteDashboard?: Maybe<DeleteDashboardPayload>;
  /** Deletes a single `Dashboard` using a unique key. */
  deleteDashboardById?: Maybe<DeleteDashboardPayload>;
  /** Deletes a single `Deepdive` using its globally unique id. */
  deleteDeepdive?: Maybe<DeleteDeepdivePayload>;
  /** Deletes a single `Deepdive` using a unique key. */
  deleteDeepdiveById?: Maybe<DeleteDeepdivePayload>;
  /** Deletes a single `Digiboard` using its globally unique id. */
  deleteDigiboard?: Maybe<DeleteDigiboardPayload>;
  /** Deletes a single `Digiboard` using a unique key. */
  deleteDigiboardById?: Maybe<DeleteDigiboardPayload>;
  /** Deletes a single `Email` using its globally unique id. */
  deleteEmail?: Maybe<DeleteEmailPayload>;
  /** Deletes a single `Email` using a unique key. */
  deleteEmailById?: Maybe<DeleteEmailPayload>;
  /** Deletes a single `Endofshift` using its globally unique id. */
  deleteEndofshift?: Maybe<DeleteEndofshiftPayload>;
  /** Deletes a single `Endofshift` using a unique key. */
  deleteEndofshiftById?: Maybe<DeleteEndofshiftPayload>;
  /** Deletes a single `Event` using its globally unique id. */
  deleteEvent?: Maybe<DeleteEventPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEventById?: Maybe<DeleteEventPayload>;
  /** Deletes a single `Fullfillment` using its globally unique id. */
  deleteFullfillment?: Maybe<DeleteFullfillmentPayload>;
  /** Deletes a single `Fullfillment` using a unique key. */
  deleteFullfillmentById?: Maybe<DeleteFullfillmentPayload>;
  /** Deletes a single `GiftCertificate` using its globally unique id. */
  deleteGiftCertificate?: Maybe<DeleteGiftCertificatePayload>;
  /** Deletes a single `GiftCertificate` using a unique key. */
  deleteGiftCertificateById?: Maybe<DeleteGiftCertificatePayload>;
  /** Deletes a single `Glossary` using its globally unique id. */
  deleteGlossary?: Maybe<DeleteGlossaryPayload>;
  /** Deletes a single `Glossary` using a unique key. */
  deleteGlossaryById?: Maybe<DeleteGlossaryPayload>;
  /** Deletes a single `Importm` using its globally unique id. */
  deleteImportm?: Maybe<DeleteImportmPayload>;
  /** Deletes a single `Importm` using a unique key. */
  deleteImportmById?: Maybe<DeleteImportmPayload>;
  /** Deletes a single `Integration` using its globally unique id. */
  deleteIntegration?: Maybe<DeleteIntegrationPayload>;
  /** Deletes a single `Integration` using a unique key. */
  deleteIntegrationById?: Maybe<DeleteIntegrationPayload>;
  /** Deletes a single `Internalization` using its globally unique id. */
  deleteInternalization?: Maybe<DeleteInternalizationPayload>;
  /** Deletes a single `Internalization` using a unique key. */
  deleteInternalizationById?: Maybe<DeleteInternalizationPayload>;
  /** Deletes a single `Invitation` using its globally unique id. */
  deleteInvitation?: Maybe<DeleteInvitationPayload>;
  /** Deletes a single `Invitation` using a unique key. */
  deleteInvitationById?: Maybe<DeleteInvitationPayload>;
  /** Deletes a single `Invoice` using its globally unique id. */
  deleteInvoice?: Maybe<DeleteInvoicePayload>;
  /** Deletes a single `Invoice` using a unique key. */
  deleteInvoiceById?: Maybe<DeleteInvoicePayload>;
  /** Deletes a single `Lead` using its globally unique id. */
  deleteLead?: Maybe<DeleteLeadPayload>;
  /** Deletes a single `Lead` using a unique key. */
  deleteLeadById?: Maybe<DeleteLeadPayload>;
  /** Deletes a single `Manufacturer` using its globally unique id. */
  deleteManufacturer?: Maybe<DeleteManufacturerPayload>;
  /** Deletes a single `Manufacturer` using a unique key. */
  deleteManufacturerById?: Maybe<DeleteManufacturerPayload>;
  /** Deletes a single `Mediamanager` using its globally unique id. */
  deleteMediamanager?: Maybe<DeleteMediamanagerPayload>;
  /** Deletes a single `Mediamanager` using a unique key. */
  deleteMediamanagerById?: Maybe<DeleteMediamanagerPayload>;
  /** Deletes a single `Meeting` using its globally unique id. */
  deleteMeeting?: Maybe<DeleteMeetingPayload>;
  /** Deletes a single `Meeting` using a unique key. */
  deleteMeetingById?: Maybe<DeleteMeetingPayload>;
  /** Deletes a single `Message` using its globally unique id. */
  deleteMessage?: Maybe<DeleteMessagePayload>;
  /** Deletes a single `Message` using a unique key. */
  deleteMessageById?: Maybe<DeleteMessagePayload>;
  /** Deletes a single `Newsletter` using its globally unique id. */
  deleteNewsletter?: Maybe<DeleteNewsletterPayload>;
  /** Deletes a single `Newsletter` using a unique key. */
  deleteNewsletterById?: Maybe<DeleteNewsletterPayload>;
  /** Deletes a single `Ooto` using its globally unique id. */
  deleteOoto?: Maybe<DeleteOotoPayload>;
  /** Deletes a single `Ooto` using a unique key. */
  deleteOotoById?: Maybe<DeleteOotoPayload>;
  /** Deletes a single `Opportunity` using its globally unique id. */
  deleteOpportunity?: Maybe<DeleteOpportunityPayload>;
  /** Deletes a single `Opportunity` using a unique key. */
  deleteOpportunityById?: Maybe<DeleteOpportunityPayload>;
  /** Deletes a single `Order` using its globally unique id. */
  deleteOrder?: Maybe<DeleteOrderPayload>;
  /** Deletes a single `Order` using a unique key. */
  deleteOrderById?: Maybe<DeleteOrderPayload>;
  /** Deletes a single `Page` using its globally unique id. */
  deletePage?: Maybe<DeletePagePayload>;
  /** Deletes a single `Page` using a unique key. */
  deletePageById?: Maybe<DeletePagePayload>;
  /** Deletes a single `Partner` using its globally unique id. */
  deletePartner?: Maybe<DeletePartnerPayload>;
  /** Deletes a single `Partner` using a unique key. */
  deletePartnerById?: Maybe<DeletePartnerPayload>;
  /** Deletes a single `Payment` using its globally unique id. */
  deletePayment?: Maybe<DeletePaymentPayload>;
  /** Deletes a single `Payment` using a unique key. */
  deletePaymentById?: Maybe<DeletePaymentPayload>;
  /** Deletes a single `Permission` using its globally unique id. */
  deletePermission?: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Permission` using a unique key. */
  deletePermissionById?: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Plugin` using its globally unique id. */
  deletePlugin?: Maybe<DeletePluginPayload>;
  /** Deletes a single `Plugin` using a unique key. */
  deletePluginById?: Maybe<DeletePluginPayload>;
  /** Deletes a single `Poll` using its globally unique id. */
  deletePoll?: Maybe<DeletePollPayload>;
  /** Deletes a single `Poll` using a unique key. */
  deletePollById?: Maybe<DeletePollPayload>;
  /** Deletes a single `ProductType` using its globally unique id. */
  deleteProductType?: Maybe<DeleteProductTypePayload>;
  /** Deletes a single `ProductType` using a unique key. */
  deleteProductTypeById?: Maybe<DeleteProductTypePayload>;
  /** Deletes a single `Product` using its globally unique id. */
  deleteProduct?: Maybe<DeleteProductPayload>;
  /** Deletes a single `Product` using a unique key. */
  deleteProductById?: Maybe<DeleteProductPayload>;
  /** Deletes a single `Project` using its globally unique id. */
  deleteProject?: Maybe<DeleteProjectPayload>;
  /** Deletes a single `Project` using a unique key. */
  deleteProjectById?: Maybe<DeleteProjectPayload>;
  /** Deletes a single `Provider` using its globally unique id. */
  deleteProvider?: Maybe<DeleteProviderPayload>;
  /** Deletes a single `Provider` using a unique key. */
  deleteProviderById?: Maybe<DeleteProviderPayload>;
  /** Deletes a single `Quote` using its globally unique id. */
  deleteQuote?: Maybe<DeleteQuotePayload>;
  /** Deletes a single `Quote` using a unique key. */
  deleteQuoteById?: Maybe<DeleteQuotePayload>;
  /** Deletes a single `Rating` using its globally unique id. */
  deleteRating?: Maybe<DeleteRatingPayload>;
  /** Deletes a single `Rating` using a unique key. */
  deleteRatingById?: Maybe<DeleteRatingPayload>;
  /** Deletes a single `Report` using its globally unique id. */
  deleteReport?: Maybe<DeleteReportPayload>;
  /** Deletes a single `Report` using a unique key. */
  deleteReportById?: Maybe<DeleteReportPayload>;
  /** Deletes a single `Return` using its globally unique id. */
  deleteReturn?: Maybe<DeleteReturnPayload>;
  /** Deletes a single `Return` using a unique key. */
  deleteReturnById?: Maybe<DeleteReturnPayload>;
  /** Deletes a single `Review` using its globally unique id. */
  deleteReview?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `Review` using a unique key. */
  deleteReviewById?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `Reward` using its globally unique id. */
  deleteReward?: Maybe<DeleteRewardPayload>;
  /** Deletes a single `Reward` using a unique key. */
  deleteRewardById?: Maybe<DeleteRewardPayload>;
  /** Deletes a single `Role` using its globally unique id. */
  deleteRole?: Maybe<DeleteRolePayload>;
  /** Deletes a single `Role` using a unique key. */
  deleteRoleById?: Maybe<DeleteRolePayload>;
  /** Deletes a single `Scheduler` using its globally unique id. */
  deleteScheduler?: Maybe<DeleteSchedulerPayload>;
  /** Deletes a single `Scheduler` using a unique key. */
  deleteSchedulerById?: Maybe<DeleteSchedulerPayload>;
  /** Deletes a single `Segment` using its globally unique id. */
  deleteSegment?: Maybe<DeleteSegmentPayload>;
  /** Deletes a single `Segment` using a unique key. */
  deleteSegmentById?: Maybe<DeleteSegmentPayload>;
  /** Deletes a single `Setting` using its globally unique id. */
  deleteSetting?: Maybe<DeleteSettingPayload>;
  /** Deletes a single `Setting` using a unique key. */
  deleteSettingById?: Maybe<DeleteSettingPayload>;
  /** Deletes a single `Shipment` using its globally unique id. */
  deleteShipment?: Maybe<DeleteShipmentPayload>;
  /** Deletes a single `Shipment` using a unique key. */
  deleteShipmentById?: Maybe<DeleteShipmentPayload>;
  /** Deletes a single `SpecialDiscount` using its globally unique id. */
  deleteSpecialDiscount?: Maybe<DeleteSpecialDiscountPayload>;
  /** Deletes a single `SpecialDiscount` using a unique key. */
  deleteSpecialDiscountById?: Maybe<DeleteSpecialDiscountPayload>;
  /** Deletes a single `State` using its globally unique id. */
  deleteState?: Maybe<DeleteStatePayload>;
  /** Deletes a single `State` using a unique key. */
  deleteStateById?: Maybe<DeleteStatePayload>;
  /** Deletes a single `Statistic` using its globally unique id. */
  deleteStatistic?: Maybe<DeleteStatisticPayload>;
  /** Deletes a single `Statistic` using a unique key. */
  deleteStatisticById?: Maybe<DeleteStatisticPayload>;
  /** Deletes a single `Stock` using its globally unique id. */
  deleteStock?: Maybe<DeleteStockPayload>;
  /** Deletes a single `Stock` using a unique key. */
  deleteStockById?: Maybe<DeleteStockPayload>;
  /** Deletes a single `Survey` using its globally unique id. */
  deleteSurvey?: Maybe<DeleteSurveyPayload>;
  /** Deletes a single `Survey` using a unique key. */
  deleteSurveyById?: Maybe<DeleteSurveyPayload>;
  /** Deletes a single `Tag` using its globally unique id. */
  deleteTag?: Maybe<DeleteTagPayload>;
  /** Deletes a single `Tag` using a unique key. */
  deleteTagById?: Maybe<DeleteTagPayload>;
  /** Deletes a single `Target` using its globally unique id. */
  deleteTarget?: Maybe<DeleteTargetPayload>;
  /** Deletes a single `Target` using a unique key. */
  deleteTargetById?: Maybe<DeleteTargetPayload>;
  /** Deletes a single `TaxCategory` using its globally unique id. */
  deleteTaxCategory?: Maybe<DeleteTaxCategoryPayload>;
  /** Deletes a single `TaxCategory` using a unique key. */
  deleteTaxCategoryById?: Maybe<DeleteTaxCategoryPayload>;
  /** Deletes a single `TaxRate` using its globally unique id. */
  deleteTaxRate?: Maybe<DeleteTaxRatePayload>;
  /** Deletes a single `TaxRate` using a unique key. */
  deleteTaxRateById?: Maybe<DeleteTaxRatePayload>;
  /** Deletes a single `TaxRule` using its globally unique id. */
  deleteTaxRule?: Maybe<DeleteTaxRulePayload>;
  /** Deletes a single `TaxRule` using a unique key. */
  deleteTaxRuleById?: Maybe<DeleteTaxRulePayload>;
  /** Deletes a single `Template` using its globally unique id. */
  deleteTemplate?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `Template` using a unique key. */
  deleteTemplateById?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `Theme` using its globally unique id. */
  deleteTheme?: Maybe<DeleteThemePayload>;
  /** Deletes a single `Theme` using a unique key. */
  deleteThemeById?: Maybe<DeleteThemePayload>;
  /** Deletes a single `Ticketing` using its globally unique id. */
  deleteTicketing?: Maybe<DeleteTicketingPayload>;
  /** Deletes a single `Ticketing` using a unique key. */
  deleteTicketingById?: Maybe<DeleteTicketingPayload>;
  /** Deletes a single `Training` using its globally unique id. */
  deleteTraining?: Maybe<DeleteTrainingPayload>;
  /** Deletes a single `Training` using a unique key. */
  deleteTrainingById?: Maybe<DeleteTrainingPayload>;
  /** Deletes a single `Transaction` using its globally unique id. */
  deleteTransaction?: Maybe<DeleteTransactionPayload>;
  /** Deletes a single `Transaction` using a unique key. */
  deleteTransactionById?: Maybe<DeleteTransactionPayload>;
  /** Deletes a single `UploadFile` using its globally unique id. */
  deleteUploadFile?: Maybe<DeleteUploadFilePayload>;
  /** Deletes a single `UploadFile` using a unique key. */
  deleteUploadFileById?: Maybe<DeleteUploadFilePayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserById?: Maybe<DeleteUserPayload>;
  /** Deletes a single `Vendor` using its globally unique id. */
  deleteVendor?: Maybe<DeleteVendorPayload>;
  /** Deletes a single `Vendor` using a unique key. */
  deleteVendorById?: Maybe<DeleteVendorPayload>;
  /** Deletes a single `Visit` using its globally unique id. */
  deleteVisit?: Maybe<DeleteVisitPayload>;
  /** Deletes a single `Visit` using a unique key. */
  deleteVisitById?: Maybe<DeleteVisitPayload>;
  /** Deletes a single `Warehouse` using its globally unique id. */
  deleteWarehouse?: Maybe<DeleteWarehousePayload>;
  /** Deletes a single `Warehouse` using a unique key. */
  deleteWarehouseById?: Maybe<DeleteWarehousePayload>;
  /** Deletes a single `Webhook` using its globally unique id. */
  deleteWebhook?: Maybe<DeleteWebhookPayload>;
  /** Deletes a single `Webhook` using a unique key. */
  deleteWebhookById?: Maybe<DeleteWebhookPayload>;
  /** Deletes a single `Website` using its globally unique id. */
  deleteWebsite?: Maybe<DeleteWebsitePayload>;
  /** Deletes a single `Website` using a unique key. */
  deleteWebsiteById?: Maybe<DeleteWebsitePayload>;
  /** Deletes a single `Wishlist` using its globally unique id. */
  deleteWishlist?: Maybe<DeleteWishlistPayload>;
  /** Deletes a single `Wishlist` using a unique key. */
  deleteWishlistById?: Maybe<DeleteWishlistPayload>;
  /** Deletes a single `Workspace` using its globally unique id. */
  deleteWorkspace?: Maybe<DeleteWorkspacePayload>;
  /** Deletes a single `Workspace` using a unique key. */
  deleteWorkspaceById?: Maybe<DeleteWorkspacePayload>;
  /** Deletes a single `Zone` using its globally unique id. */
  deleteZone?: Maybe<DeleteZonePayload>;
  /** Deletes a single `Zone` using a unique key. */
  deleteZoneById?: Maybe<DeleteZonePayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateAccountArgs = {
  input: CreateAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateAgreementArgs = {
  input: CreateAgreementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateAnalyticArgs = {
  input: CreateAnalyticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateApitokenArgs = {
  input: CreateApitokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateArticleArgs = {
  input: CreateArticleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateAttributeArgs = {
  input: CreateAttributeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateBrandArgs = {
  input: CreateBrandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCartPriceRuleArgs = {
  input: CreateCartPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCaseArgs = {
  input: CreateCaseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCatalogPriceRuleArgs = {
  input: CreateCatalogPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCategoryArgs = {
  input: CreateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateChannelArgs = {
  input: CreateChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateChecklistArgs = {
  input: CreateChecklistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCityArgs = {
  input: CreateCityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCollectionArgs = {
  input: CreateCollectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCommentArgs = {
  input: CreateCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateContentTypeArgs = {
  input: CreateContentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateContractArgs = {
  input: CreateContractInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCountryArgs = {
  input: CreateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCouponArgs = {
  input: CreateCouponInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCreditMemoArgs = {
  input: CreateCreditMemoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCurrencyArgs = {
  input: CreateCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCurrencyRateArgs = {
  input: CreateCurrencyRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCurrencySymbolArgs = {
  input: CreateCurrencySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCustomerGroupArgs = {
  input: CreateCustomerGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCustomerArgs = {
  input: CreateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCustomizationArgs = {
  input: CreateCustomizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateDashboardArgs = {
  input: CreateDashboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateDeepdiveArgs = {
  input: CreateDeepdiveInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateDigiboardArgs = {
  input: CreateDigiboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateEmailArgs = {
  input: CreateEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateEndofshiftArgs = {
  input: CreateEndofshiftInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateFullfillmentArgs = {
  input: CreateFullfillmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateGiftCertificateArgs = {
  input: CreateGiftCertificateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateGlossaryArgs = {
  input: CreateGlossaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateImportmArgs = {
  input: CreateImportmInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateIntegrationArgs = {
  input: CreateIntegrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateInternalizationArgs = {
  input: CreateInternalizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateInvitationArgs = {
  input: CreateInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateInvoiceArgs = {
  input: CreateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateLeadArgs = {
  input: CreateLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateManufacturerArgs = {
  input: CreateManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMediamanagerArgs = {
  input: CreateMediamanagerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMeetingArgs = {
  input: CreateMeetingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMessageArgs = {
  input: CreateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateNewsletterArgs = {
  input: CreateNewsletterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateOotoArgs = {
  input: CreateOotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateOpportunityArgs = {
  input: CreateOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateOrderArgs = {
  input: CreateOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePartnerArgs = {
  input: CreatePartnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePaymentArgs = {
  input: CreatePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePermissionArgs = {
  input: CreatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePluginArgs = {
  input: CreatePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePollArgs = {
  input: CreatePollInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProductTypeArgs = {
  input: CreateProductTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProductArgs = {
  input: CreateProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProjectArgs = {
  input: CreateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProviderArgs = {
  input: CreateProviderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateQuoteArgs = {
  input: CreateQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateRatingArgs = {
  input: CreateRatingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateReportArgs = {
  input: CreateReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateReturnArgs = {
  input: CreateReturnInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateReviewArgs = {
  input: CreateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateRewardArgs = {
  input: CreateRewardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateRoleArgs = {
  input: CreateRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSchedulerArgs = {
  input: CreateSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSegmentArgs = {
  input: CreateSegmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSettingArgs = {
  input: CreateSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateShipmentArgs = {
  input: CreateShipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSpecialDiscountArgs = {
  input: CreateSpecialDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateStateArgs = {
  input: CreateStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateStatisticArgs = {
  input: CreateStatisticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateStockArgs = {
  input: CreateStockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSurveyArgs = {
  input: CreateSurveyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTagArgs = {
  input: CreateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTargetArgs = {
  input: CreateTargetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTaxCategoryArgs = {
  input: CreateTaxCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTaxRateArgs = {
  input: CreateTaxRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTaxRuleArgs = {
  input: CreateTaxRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTemplateArgs = {
  input: CreateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateThemeArgs = {
  input: CreateThemeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTicketingArgs = {
  input: CreateTicketingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTrainingArgs = {
  input: CreateTrainingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTransactionArgs = {
  input: CreateTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateUploadFileArgs = {
  input: CreateUploadFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateVendorArgs = {
  input: CreateVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateVisitArgs = {
  input: CreateVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWarehouseArgs = {
  input: CreateWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWebhookArgs = {
  input: CreateWebhookInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWebsiteArgs = {
  input: CreateWebsiteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWishlistArgs = {
  input: CreateWishlistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWorkspaceArgs = {
  input: CreateWorkspaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateZoneArgs = {
  input: CreateZoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAccountArgs = {
  input: UpdateAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAccountByIdArgs = {
  input: UpdateAccountByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAgreementArgs = {
  input: UpdateAgreementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAgreementByIdArgs = {
  input: UpdateAgreementByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAnalyticArgs = {
  input: UpdateAnalyticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAnalyticByIdArgs = {
  input: UpdateAnalyticByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateApitokenArgs = {
  input: UpdateApitokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateApitokenByIdArgs = {
  input: UpdateApitokenByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateArticleArgs = {
  input: UpdateArticleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateArticleByIdArgs = {
  input: UpdateArticleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAttributeArgs = {
  input: UpdateAttributeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAttributeByIdArgs = {
  input: UpdateAttributeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateBrandArgs = {
  input: UpdateBrandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateBrandByIdArgs = {
  input: UpdateBrandByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCartPriceRuleArgs = {
  input: UpdateCartPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCartPriceRuleByIdArgs = {
  input: UpdateCartPriceRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCaseArgs = {
  input: UpdateCaseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCaseByIdArgs = {
  input: UpdateCaseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCatalogPriceRuleArgs = {
  input: UpdateCatalogPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCatalogPriceRuleByIdArgs = {
  input: UpdateCatalogPriceRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCategoryArgs = {
  input: UpdateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCategoryByIdArgs = {
  input: UpdateCategoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateChannelArgs = {
  input: UpdateChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateChannelByIdArgs = {
  input: UpdateChannelByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateChecklistArgs = {
  input: UpdateChecklistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateChecklistByIdArgs = {
  input: UpdateChecklistByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCityArgs = {
  input: UpdateCityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCityByIdArgs = {
  input: UpdateCityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCollectionArgs = {
  input: UpdateCollectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCollectionByIdArgs = {
  input: UpdateCollectionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCommentArgs = {
  input: UpdateCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCommentByIdArgs = {
  input: UpdateCommentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateContentTypeArgs = {
  input: UpdateContentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateContentTypeByIdArgs = {
  input: UpdateContentTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateContractArgs = {
  input: UpdateContractInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateContractByIdArgs = {
  input: UpdateContractByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCountryArgs = {
  input: UpdateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCountryByIdArgs = {
  input: UpdateCountryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCouponArgs = {
  input: UpdateCouponInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCouponByIdArgs = {
  input: UpdateCouponByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCreditMemoArgs = {
  input: UpdateCreditMemoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCreditMemoByCreditMemoAndIdArgs = {
  input: UpdateCreditMemoByCreditMemoAndIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencyArgs = {
  input: UpdateCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencyByIdArgs = {
  input: UpdateCurrencyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencyRateArgs = {
  input: UpdateCurrencyRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencyRateByImportServiceArgs = {
  input: UpdateCurrencyRateByImportServiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencySymbolArgs = {
  input: UpdateCurrencySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencySymbolBySymbolArgs = {
  input: UpdateCurrencySymbolBySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomerGroupArgs = {
  input: UpdateCustomerGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomerGroupByIdArgs = {
  input: UpdateCustomerGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomerArgs = {
  input: UpdateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomerByIdArgs = {
  input: UpdateCustomerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomizationArgs = {
  input: UpdateCustomizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomizationByIdArgs = {
  input: UpdateCustomizationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDashboardArgs = {
  input: UpdateDashboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDashboardByIdArgs = {
  input: UpdateDashboardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDeepdiveArgs = {
  input: UpdateDeepdiveInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDeepdiveByIdArgs = {
  input: UpdateDeepdiveByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDigiboardArgs = {
  input: UpdateDigiboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDigiboardByIdArgs = {
  input: UpdateDigiboardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEmailArgs = {
  input: UpdateEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEmailByIdArgs = {
  input: UpdateEmailByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEndofshiftArgs = {
  input: UpdateEndofshiftInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEndofshiftByIdArgs = {
  input: UpdateEndofshiftByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEventByIdArgs = {
  input: UpdateEventByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateFullfillmentArgs = {
  input: UpdateFullfillmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateFullfillmentByIdArgs = {
  input: UpdateFullfillmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateGiftCertificateArgs = {
  input: UpdateGiftCertificateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateGiftCertificateByIdArgs = {
  input: UpdateGiftCertificateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateGlossaryArgs = {
  input: UpdateGlossaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateGlossaryByIdArgs = {
  input: UpdateGlossaryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateImportmArgs = {
  input: UpdateImportmInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateImportmByIdArgs = {
  input: UpdateImportmByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateIntegrationArgs = {
  input: UpdateIntegrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateIntegrationByIdArgs = {
  input: UpdateIntegrationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInternalizationArgs = {
  input: UpdateInternalizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInternalizationByIdArgs = {
  input: UpdateInternalizationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInvitationArgs = {
  input: UpdateInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInvitationByIdArgs = {
  input: UpdateInvitationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInvoiceArgs = {
  input: UpdateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInvoiceByIdArgs = {
  input: UpdateInvoiceByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateLeadArgs = {
  input: UpdateLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateLeadByIdArgs = {
  input: UpdateLeadByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateManufacturerArgs = {
  input: UpdateManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateManufacturerByIdArgs = {
  input: UpdateManufacturerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMediamanagerArgs = {
  input: UpdateMediamanagerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMediamanagerByIdArgs = {
  input: UpdateMediamanagerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMeetingArgs = {
  input: UpdateMeetingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMeetingByIdArgs = {
  input: UpdateMeetingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMessageArgs = {
  input: UpdateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMessageByIdArgs = {
  input: UpdateMessageByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateNewsletterArgs = {
  input: UpdateNewsletterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateNewsletterByIdArgs = {
  input: UpdateNewsletterByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOotoArgs = {
  input: UpdateOotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOotoByIdArgs = {
  input: UpdateOotoByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOpportunityArgs = {
  input: UpdateOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOpportunityByIdArgs = {
  input: UpdateOpportunityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOrderArgs = {
  input: UpdateOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOrderByIdArgs = {
  input: UpdateOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePageByIdArgs = {
  input: UpdatePageByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePartnerArgs = {
  input: UpdatePartnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePartnerByIdArgs = {
  input: UpdatePartnerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePaymentArgs = {
  input: UpdatePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePaymentByIdArgs = {
  input: UpdatePaymentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePermissionArgs = {
  input: UpdatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePermissionByIdArgs = {
  input: UpdatePermissionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePluginArgs = {
  input: UpdatePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePluginByIdArgs = {
  input: UpdatePluginByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePollArgs = {
  input: UpdatePollInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePollByIdArgs = {
  input: UpdatePollByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProductTypeArgs = {
  input: UpdateProductTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProductTypeByIdArgs = {
  input: UpdateProductTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProductArgs = {
  input: UpdateProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProductByIdArgs = {
  input: UpdateProductByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProjectArgs = {
  input: UpdateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProjectByIdArgs = {
  input: UpdateProjectByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProviderArgs = {
  input: UpdateProviderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProviderByIdArgs = {
  input: UpdateProviderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateQuoteArgs = {
  input: UpdateQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateQuoteByIdArgs = {
  input: UpdateQuoteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRatingArgs = {
  input: UpdateRatingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRatingByIdArgs = {
  input: UpdateRatingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReportArgs = {
  input: UpdateReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReportByIdArgs = {
  input: UpdateReportByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReturnArgs = {
  input: UpdateReturnInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReturnByIdArgs = {
  input: UpdateReturnByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReviewArgs = {
  input: UpdateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReviewByIdArgs = {
  input: UpdateReviewByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRewardArgs = {
  input: UpdateRewardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRewardByIdArgs = {
  input: UpdateRewardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRoleArgs = {
  input: UpdateRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRoleByIdArgs = {
  input: UpdateRoleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSchedulerArgs = {
  input: UpdateSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSchedulerByIdArgs = {
  input: UpdateSchedulerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSegmentArgs = {
  input: UpdateSegmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSegmentByIdArgs = {
  input: UpdateSegmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSettingArgs = {
  input: UpdateSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSettingByIdArgs = {
  input: UpdateSettingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateShipmentArgs = {
  input: UpdateShipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateShipmentByIdArgs = {
  input: UpdateShipmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSpecialDiscountArgs = {
  input: UpdateSpecialDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSpecialDiscountByIdArgs = {
  input: UpdateSpecialDiscountByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStateArgs = {
  input: UpdateStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStateByIdArgs = {
  input: UpdateStateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStatisticArgs = {
  input: UpdateStatisticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStatisticByIdArgs = {
  input: UpdateStatisticByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStockArgs = {
  input: UpdateStockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStockByIdArgs = {
  input: UpdateStockByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSurveyArgs = {
  input: UpdateSurveyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSurveyByIdArgs = {
  input: UpdateSurveyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTagArgs = {
  input: UpdateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTagByIdArgs = {
  input: UpdateTagByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTargetArgs = {
  input: UpdateTargetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTargetByIdArgs = {
  input: UpdateTargetByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxCategoryArgs = {
  input: UpdateTaxCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxCategoryByIdArgs = {
  input: UpdateTaxCategoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxRateArgs = {
  input: UpdateTaxRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxRateByIdArgs = {
  input: UpdateTaxRateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxRuleArgs = {
  input: UpdateTaxRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxRuleByIdArgs = {
  input: UpdateTaxRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTemplateArgs = {
  input: UpdateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTemplateByIdArgs = {
  input: UpdateTemplateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateThemeArgs = {
  input: UpdateThemeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateThemeByIdArgs = {
  input: UpdateThemeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTicketingArgs = {
  input: UpdateTicketingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTicketingByIdArgs = {
  input: UpdateTicketingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTrainingArgs = {
  input: UpdateTrainingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTrainingByIdArgs = {
  input: UpdateTrainingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTransactionArgs = {
  input: UpdateTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTransactionByIdArgs = {
  input: UpdateTransactionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUploadFileArgs = {
  input: UpdateUploadFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUploadFileByIdArgs = {
  input: UpdateUploadFileByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserByIdArgs = {
  input: UpdateUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateVendorArgs = {
  input: UpdateVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateVendorByIdArgs = {
  input: UpdateVendorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateVisitArgs = {
  input: UpdateVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateVisitByIdArgs = {
  input: UpdateVisitByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWarehouseArgs = {
  input: UpdateWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWarehouseByIdArgs = {
  input: UpdateWarehouseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWebhookArgs = {
  input: UpdateWebhookInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWebhookByIdArgs = {
  input: UpdateWebhookByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWebsiteArgs = {
  input: UpdateWebsiteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWebsiteByIdArgs = {
  input: UpdateWebsiteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWishlistArgs = {
  input: UpdateWishlistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWishlistByIdArgs = {
  input: UpdateWishlistByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWorkspaceArgs = {
  input: UpdateWorkspaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWorkspaceByIdArgs = {
  input: UpdateWorkspaceByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateZoneArgs = {
  input: UpdateZoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateZoneByIdArgs = {
  input: UpdateZoneByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAccountArgs = {
  input: DeleteAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAccountByIdArgs = {
  input: DeleteAccountByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAgreementArgs = {
  input: DeleteAgreementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAgreementByIdArgs = {
  input: DeleteAgreementByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAnalyticArgs = {
  input: DeleteAnalyticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAnalyticByIdArgs = {
  input: DeleteAnalyticByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteApitokenArgs = {
  input: DeleteApitokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteApitokenByIdArgs = {
  input: DeleteApitokenByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteArticleArgs = {
  input: DeleteArticleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteArticleByIdArgs = {
  input: DeleteArticleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAttributeArgs = {
  input: DeleteAttributeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAttributeByIdArgs = {
  input: DeleteAttributeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteBrandArgs = {
  input: DeleteBrandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteBrandByIdArgs = {
  input: DeleteBrandByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCartPriceRuleArgs = {
  input: DeleteCartPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCartPriceRuleByIdArgs = {
  input: DeleteCartPriceRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCaseArgs = {
  input: DeleteCaseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCaseByIdArgs = {
  input: DeleteCaseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCatalogPriceRuleArgs = {
  input: DeleteCatalogPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCatalogPriceRuleByIdArgs = {
  input: DeleteCatalogPriceRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCategoryArgs = {
  input: DeleteCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCategoryByIdArgs = {
  input: DeleteCategoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteChannelArgs = {
  input: DeleteChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteChannelByIdArgs = {
  input: DeleteChannelByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteChecklistArgs = {
  input: DeleteChecklistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteChecklistByIdArgs = {
  input: DeleteChecklistByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCityArgs = {
  input: DeleteCityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCityByIdArgs = {
  input: DeleteCityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCollectionArgs = {
  input: DeleteCollectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCollectionByIdArgs = {
  input: DeleteCollectionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCommentArgs = {
  input: DeleteCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCommentByIdArgs = {
  input: DeleteCommentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteContentTypeArgs = {
  input: DeleteContentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteContentTypeByIdArgs = {
  input: DeleteContentTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteContractArgs = {
  input: DeleteContractInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteContractByIdArgs = {
  input: DeleteContractByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCountryArgs = {
  input: DeleteCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCountryByIdArgs = {
  input: DeleteCountryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCouponArgs = {
  input: DeleteCouponInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCouponByIdArgs = {
  input: DeleteCouponByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCreditMemoArgs = {
  input: DeleteCreditMemoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCreditMemoByCreditMemoAndIdArgs = {
  input: DeleteCreditMemoByCreditMemoAndIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencyArgs = {
  input: DeleteCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencyByIdArgs = {
  input: DeleteCurrencyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencyRateArgs = {
  input: DeleteCurrencyRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencyRateByImportServiceArgs = {
  input: DeleteCurrencyRateByImportServiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencySymbolArgs = {
  input: DeleteCurrencySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencySymbolBySymbolArgs = {
  input: DeleteCurrencySymbolBySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomerGroupArgs = {
  input: DeleteCustomerGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomerGroupByIdArgs = {
  input: DeleteCustomerGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomerArgs = {
  input: DeleteCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomerByIdArgs = {
  input: DeleteCustomerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomizationArgs = {
  input: DeleteCustomizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomizationByIdArgs = {
  input: DeleteCustomizationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDashboardArgs = {
  input: DeleteDashboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDashboardByIdArgs = {
  input: DeleteDashboardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDeepdiveArgs = {
  input: DeleteDeepdiveInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDeepdiveByIdArgs = {
  input: DeleteDeepdiveByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDigiboardArgs = {
  input: DeleteDigiboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDigiboardByIdArgs = {
  input: DeleteDigiboardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEmailArgs = {
  input: DeleteEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEmailByIdArgs = {
  input: DeleteEmailByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEndofshiftArgs = {
  input: DeleteEndofshiftInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEndofshiftByIdArgs = {
  input: DeleteEndofshiftByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEventByIdArgs = {
  input: DeleteEventByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteFullfillmentArgs = {
  input: DeleteFullfillmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteFullfillmentByIdArgs = {
  input: DeleteFullfillmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteGiftCertificateArgs = {
  input: DeleteGiftCertificateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteGiftCertificateByIdArgs = {
  input: DeleteGiftCertificateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteGlossaryArgs = {
  input: DeleteGlossaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteGlossaryByIdArgs = {
  input: DeleteGlossaryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteImportmArgs = {
  input: DeleteImportmInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteImportmByIdArgs = {
  input: DeleteImportmByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteIntegrationArgs = {
  input: DeleteIntegrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteIntegrationByIdArgs = {
  input: DeleteIntegrationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInternalizationArgs = {
  input: DeleteInternalizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInternalizationByIdArgs = {
  input: DeleteInternalizationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInvitationArgs = {
  input: DeleteInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInvitationByIdArgs = {
  input: DeleteInvitationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInvoiceArgs = {
  input: DeleteInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInvoiceByIdArgs = {
  input: DeleteInvoiceByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteLeadArgs = {
  input: DeleteLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteLeadByIdArgs = {
  input: DeleteLeadByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteManufacturerArgs = {
  input: DeleteManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteManufacturerByIdArgs = {
  input: DeleteManufacturerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMediamanagerArgs = {
  input: DeleteMediamanagerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMediamanagerByIdArgs = {
  input: DeleteMediamanagerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMeetingArgs = {
  input: DeleteMeetingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMeetingByIdArgs = {
  input: DeleteMeetingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMessageArgs = {
  input: DeleteMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMessageByIdArgs = {
  input: DeleteMessageByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteNewsletterArgs = {
  input: DeleteNewsletterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteNewsletterByIdArgs = {
  input: DeleteNewsletterByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOotoArgs = {
  input: DeleteOotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOotoByIdArgs = {
  input: DeleteOotoByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOpportunityArgs = {
  input: DeleteOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOpportunityByIdArgs = {
  input: DeleteOpportunityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOrderArgs = {
  input: DeleteOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOrderByIdArgs = {
  input: DeleteOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePageArgs = {
  input: DeletePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePageByIdArgs = {
  input: DeletePageByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePartnerArgs = {
  input: DeletePartnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePartnerByIdArgs = {
  input: DeletePartnerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePaymentArgs = {
  input: DeletePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePaymentByIdArgs = {
  input: DeletePaymentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePermissionArgs = {
  input: DeletePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePermissionByIdArgs = {
  input: DeletePermissionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePluginArgs = {
  input: DeletePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePluginByIdArgs = {
  input: DeletePluginByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePollArgs = {
  input: DeletePollInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePollByIdArgs = {
  input: DeletePollByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProductTypeArgs = {
  input: DeleteProductTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProductTypeByIdArgs = {
  input: DeleteProductTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProductArgs = {
  input: DeleteProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProductByIdArgs = {
  input: DeleteProductByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProjectArgs = {
  input: DeleteProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProjectByIdArgs = {
  input: DeleteProjectByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProviderArgs = {
  input: DeleteProviderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProviderByIdArgs = {
  input: DeleteProviderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteQuoteArgs = {
  input: DeleteQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteQuoteByIdArgs = {
  input: DeleteQuoteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRatingArgs = {
  input: DeleteRatingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRatingByIdArgs = {
  input: DeleteRatingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReportArgs = {
  input: DeleteReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReportByIdArgs = {
  input: DeleteReportByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReturnArgs = {
  input: DeleteReturnInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReturnByIdArgs = {
  input: DeleteReturnByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReviewArgs = {
  input: DeleteReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReviewByIdArgs = {
  input: DeleteReviewByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRewardArgs = {
  input: DeleteRewardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRewardByIdArgs = {
  input: DeleteRewardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRoleArgs = {
  input: DeleteRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRoleByIdArgs = {
  input: DeleteRoleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSchedulerArgs = {
  input: DeleteSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSchedulerByIdArgs = {
  input: DeleteSchedulerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSegmentArgs = {
  input: DeleteSegmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSegmentByIdArgs = {
  input: DeleteSegmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSettingArgs = {
  input: DeleteSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSettingByIdArgs = {
  input: DeleteSettingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteShipmentArgs = {
  input: DeleteShipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteShipmentByIdArgs = {
  input: DeleteShipmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSpecialDiscountArgs = {
  input: DeleteSpecialDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSpecialDiscountByIdArgs = {
  input: DeleteSpecialDiscountByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStateArgs = {
  input: DeleteStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStateByIdArgs = {
  input: DeleteStateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStatisticArgs = {
  input: DeleteStatisticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStatisticByIdArgs = {
  input: DeleteStatisticByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStockArgs = {
  input: DeleteStockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStockByIdArgs = {
  input: DeleteStockByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSurveyArgs = {
  input: DeleteSurveyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSurveyByIdArgs = {
  input: DeleteSurveyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTagArgs = {
  input: DeleteTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTagByIdArgs = {
  input: DeleteTagByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTargetArgs = {
  input: DeleteTargetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTargetByIdArgs = {
  input: DeleteTargetByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxCategoryArgs = {
  input: DeleteTaxCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxCategoryByIdArgs = {
  input: DeleteTaxCategoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxRateArgs = {
  input: DeleteTaxRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxRateByIdArgs = {
  input: DeleteTaxRateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxRuleArgs = {
  input: DeleteTaxRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxRuleByIdArgs = {
  input: DeleteTaxRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTemplateArgs = {
  input: DeleteTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTemplateByIdArgs = {
  input: DeleteTemplateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteThemeArgs = {
  input: DeleteThemeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteThemeByIdArgs = {
  input: DeleteThemeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTicketingArgs = {
  input: DeleteTicketingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTicketingByIdArgs = {
  input: DeleteTicketingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTrainingArgs = {
  input: DeleteTrainingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTrainingByIdArgs = {
  input: DeleteTrainingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTransactionArgs = {
  input: DeleteTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTransactionByIdArgs = {
  input: DeleteTransactionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteUploadFileArgs = {
  input: DeleteUploadFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteUploadFileByIdArgs = {
  input: DeleteUploadFileByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteUserByIdArgs = {
  input: DeleteUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteVendorArgs = {
  input: DeleteVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteVendorByIdArgs = {
  input: DeleteVendorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteVisitArgs = {
  input: DeleteVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteVisitByIdArgs = {
  input: DeleteVisitByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWarehouseArgs = {
  input: DeleteWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWarehouseByIdArgs = {
  input: DeleteWarehouseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWebhookArgs = {
  input: DeleteWebhookInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWebhookByIdArgs = {
  input: DeleteWebhookByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWebsiteArgs = {
  input: DeleteWebsiteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWebsiteByIdArgs = {
  input: DeleteWebsiteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWishlistArgs = {
  input: DeleteWishlistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWishlistByIdArgs = {
  input: DeleteWishlistByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWorkspaceArgs = {
  input: DeleteWorkspaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWorkspaceByIdArgs = {
  input: DeleteWorkspaceByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteZoneArgs = {
  input: DeleteZoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteZoneByIdArgs = {
  input: DeleteZoneByIdInput;
};

/** The output of our create `Account` mutation. */
export type CreateAccountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was created by this mutation. */
  account?: Maybe<Account>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our create `Account` mutation. */
export type CreateAccountPayloadaccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the create `Account` mutation. */
export type CreateAccountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Account` to be created by this mutation. */
  account: AccountInput;
};

/** An input for mutations affecting `Account` */
export type AccountInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  industry?: InputMaybe<Scalars['String']>;
  employees?: InputMaybe<Scalars['String']>;
  annualRevenue?: InputMaybe<Scalars['String']>;
  memberOf?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Agreement` mutation. */
export type CreateAgreementPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agreement` that was created by this mutation. */
  agreement?: Maybe<Agreement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Agreement`. May be used by Relay 1. */
  agreementEdge?: Maybe<AgreementsEdge>;
};


/** The output of our create `Agreement` mutation. */
export type CreateAgreementPayloadagreementEdgeArgs = {
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
};

/** All input for the create `Agreement` mutation. */
export type CreateAgreementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Agreement` to be created by this mutation. */
  agreement: AgreementInput;
};

/** An input for mutations affecting `Agreement` */
export type AgreementInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  referenceId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  content?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['String']>;
  shopId?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Analytic` mutation. */
export type CreateAnalyticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Analytic` that was created by this mutation. */
  analytic?: Maybe<Analytic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Analytic`. May be used by Relay 1. */
  analyticEdge?: Maybe<AnalyticsEdge>;
};


/** The output of our create `Analytic` mutation. */
export type CreateAnalyticPayloadanalyticEdgeArgs = {
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
};

/** All input for the create `Analytic` mutation. */
export type CreateAnalyticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Analytic` to be created by this mutation. */
  analytic: AnalyticInput;
};

/** An input for mutations affecting `Analytic` */
export type AnalyticInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  shareData?: InputMaybe<Scalars['String']>;
  websiteName?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  trackingId?: InputMaybe<Scalars['String']>;
  propertyName?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  defaultView?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  propertyHit?: InputMaybe<Scalars['String']>;
  trackingCode?: InputMaybe<Scalars['String']>;
  dataCollection?: InputMaybe<Scalars['Boolean']>;
  dataRetention?: InputMaybe<Scalars['Boolean']>;
  searchAnalytics?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Apitoken` mutation. */
export type CreateApitokenPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Apitoken` that was created by this mutation. */
  apitoken?: Maybe<Apitoken>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Apitoken`. May be used by Relay 1. */
  apitokenEdge?: Maybe<ApitokensEdge>;
};


/** The output of our create `Apitoken` mutation. */
export type CreateApitokenPayloadapitokenEdgeArgs = {
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
};

/** All input for the create `Apitoken` mutation. */
export type CreateApitokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Apitoken` to be created by this mutation. */
  apitoken: ApitokenInput;
};

/** An input for mutations affecting `Apitoken` */
export type ApitokenInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name: Scalars['String'];
  tokenType?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  token: Scalars['BigInt'];
};

/** The output of our create `Article` mutation. */
export type CreateArticlePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Article` that was created by this mutation. */
  article?: Maybe<Article>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Article`. May be used by Relay 1. */
  articleEdge?: Maybe<ArticlesEdge>;
};


/** The output of our create `Article` mutation. */
export type CreateArticlePayloadarticleEdgeArgs = {
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
};

/** All input for the create `Article` mutation. */
export type CreateArticleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Article` to be created by this mutation. */
  article: ArticleInput;
};

/** An input for mutations affecting `Article` */
export type ArticleInput = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaName?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Attribute` mutation. */
export type CreateAttributePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Attribute` that was created by this mutation. */
  attribute?: Maybe<Attribute>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Attribute`. May be used by Relay 1. */
  attributeEdge?: Maybe<AttributesEdge>;
};


/** The output of our create `Attribute` mutation. */
export type CreateAttributePayloadattributeEdgeArgs = {
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
};

/** All input for the create `Attribute` mutation. */
export type CreateAttributeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Attribute` to be created by this mutation. */
  attribute: AttributeInput;
};

/** An input for mutations affecting `Attribute` */
export type AttributeInput = {
  id?: InputMaybe<Scalars['Int']>;
  defaultLabel?: InputMaybe<Scalars['String']>;
  attributeCode?: InputMaybe<Scalars['String']>;
  filterOptions?: InputMaybe<Scalars['String']>;
  useSearch?: InputMaybe<Scalars['String']>;
  layeredNavigation?: InputMaybe<Scalars['Boolean']>;
  searchResultsLayeredNavigation?: InputMaybe<Scalars['Boolean']>;
  position?: InputMaybe<Scalars['String']>;
  promoRuleConditions?: InputMaybe<Scalars['Boolean']>;
  allowHtmlTagsStorefront?: InputMaybe<Scalars['Boolean']>;
  visibleCatalogPagesStorefront?: InputMaybe<Scalars['Boolean']>;
  usedProductListing?: InputMaybe<Scalars['Boolean']>;
  usedSortingProductListing?: InputMaybe<Scalars['Boolean']>;
  prodId: Scalars['BigInt'];
  attributeClass?: InputMaybe<Scalars['String']>;
  attributeValue?: InputMaybe<Scalars['String']>;
  columnOptions?: InputMaybe<Scalars['String']>;
  facetedNavigation?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaName?: InputMaybe<Scalars['Boolean']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  productAttributeSet?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Brand` mutation. */
export type CreateBrandPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Brand` that was created by this mutation. */
  brand?: Maybe<Brand>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<BrandsEdge>;
};


/** The output of our create `Brand` mutation. */
export type CreateBrandPayloadbrandEdgeArgs = {
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
};

/** All input for the create `Brand` mutation. */
export type CreateBrandInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Brand` to be created by this mutation. */
  brand: BrandInput;
};

/** An input for mutations affecting `Brand` */
export type BrandInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `CartPriceRule` mutation. */
export type CreateCartPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CartPriceRule` that was created by this mutation. */
  cartPriceRule?: Maybe<CartPriceRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CartPriceRule`. May be used by Relay 1. */
  cartPriceRuleEdge?: Maybe<CartPriceRulesEdge>;
};


/** The output of our create `CartPriceRule` mutation. */
export type CreateCartPriceRulePayloadcartPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
};

/** All input for the create `CartPriceRule` mutation. */
export type CreateCartPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CartPriceRule` to be created by this mutation. */
  cartPriceRule: CartPriceRuleInput;
};

/** An input for mutations affecting `CartPriceRule` */
export type CartPriceRuleInput = {
  id?: InputMaybe<Scalars['Int']>;
  rule?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  coupon?: InputMaybe<Scalars['String']>;
  usesPerCustomer?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  actionsApply?: InputMaybe<Scalars['String']>;
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
  actionsMaxQtyDiscountIsAppliedTo?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscountQtyStep?: InputMaybe<Scalars['BigFloat']>;
  actionsApplyShippingAmount?: InputMaybe<Scalars['Boolean']>;
};

/** The output of our create `Case` mutation. */
export type CreateCasePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Case` that was created by this mutation. */
  case?: Maybe<Case>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Case`. May be used by Relay 1. */
  caseEdge?: Maybe<CasesEdge>;
};


/** The output of our create `Case` mutation. */
export type CreateCasePayloadcaseEdgeArgs = {
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
};

/** All input for the create `Case` mutation. */
export type CreateCaseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Case` to be created by this mutation. */
  case: CaseInput;
};

/** An input for mutations affecting `Case` */
export type CaseInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  caseNumber?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  resolution?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  dateModified?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `CatalogPriceRule` mutation. */
export type CreateCatalogPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CatalogPriceRule` that was created by this mutation. */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CatalogPriceRule`. May be used by Relay 1. */
  catalogPriceRuleEdge?: Maybe<CatalogPriceRulesEdge>;
};


/** The output of our create `CatalogPriceRule` mutation. */
export type CreateCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
};

/** All input for the create `CatalogPriceRule` mutation. */
export type CreateCatalogPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CatalogPriceRule` to be created by this mutation. */
  catalogPriceRule: CatalogPriceRuleInput;
};

/** An input for mutations affecting `CatalogPriceRule` */
export type CatalogPriceRuleInput = {
  id?: InputMaybe<Scalars['Int']>;
  rule?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  customerGroups?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  actionsApply?: InputMaybe<Scalars['String']>;
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
};

/** The output of our create `Category` mutation. */
export type CreateCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Category` that was created by this mutation. */
  category?: Maybe<Category>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<CategoriesEdge>;
};


/** The output of our create `Category` mutation. */
export type CreateCategoryPayloadcategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
};

/** All input for the create `Category` mutation. */
export type CreateCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Category` to be created by this mutation. */
  category: CategoryInput;
};

/** An input for mutations affecting `Category` */
export type CategoryInput = {
  id?: InputMaybe<Scalars['Int']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  visibility?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['Boolean']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Channel` mutation. */
export type CreateChannelPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Channel` that was created by this mutation. */
  channel?: Maybe<Channel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Channel`. May be used by Relay 1. */
  channelEdge?: Maybe<ChannelsEdge>;
};


/** The output of our create `Channel` mutation. */
export type CreateChannelPayloadchannelEdgeArgs = {
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
};

/** All input for the create `Channel` mutation. */
export type CreateChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Channel` to be created by this mutation. */
  channel: ChannelInput;
};

/** An input for mutations affecting `Channel` */
export type ChannelInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  defaultLang?: InputMaybe<Scalars['String']>;
  includeTax?: InputMaybe<Scalars['String']>;
  defaultZone?: InputMaybe<Scalars['String']>;
  defaultShipping?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Checklist` mutation. */
export type CreateChecklistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Checklist` that was created by this mutation. */
  checklist?: Maybe<Checklist>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Checklist`. May be used by Relay 1. */
  checklistEdge?: Maybe<ChecklistsEdge>;
};


/** The output of our create `Checklist` mutation. */
export type CreateChecklistPayloadchecklistEdgeArgs = {
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
};

/** All input for the create `Checklist` mutation. */
export type CreateChecklistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Checklist` to be created by this mutation. */
  checklist: ChecklistInput;
};

/** An input for mutations affecting `Checklist` */
export type ChecklistInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  username?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  regionalManager?: InputMaybe<Scalars['String']>;
  manager?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  ticket?: InputMaybe<Scalars['String']>;
  project?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** The output of our create `City` mutation. */
export type CreateCityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `City` that was created by this mutation. */
  city?: Maybe<City>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `City`. May be used by Relay 1. */
  cityEdge?: Maybe<CitiesEdge>;
};


/** The output of our create `City` mutation. */
export type CreateCityPayloadcityEdgeArgs = {
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
};

/** All input for the create `City` mutation. */
export type CreateCityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `City` to be created by this mutation. */
  city: CityInput;
};

/** An input for mutations affecting `City` */
export type CityInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postalCode?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Collection` mutation. */
export type CreateCollectionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Collection` that was created by this mutation. */
  collection?: Maybe<Collection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Collection`. May be used by Relay 1. */
  collectionEdge?: Maybe<CollectionsEdge>;
};


/** The output of our create `Collection` mutation. */
export type CreateCollectionPayloadcollectionEdgeArgs = {
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
};

/** All input for the create `Collection` mutation. */
export type CreateCollectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Collection` to be created by this mutation. */
  collection: CollectionInput;
};

/** An input for mutations affecting `Collection` */
export type CollectionInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Comment` mutation. */
export type CreateCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Comment` that was created by this mutation. */
  comment?: Maybe<Comment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  commentEdge?: Maybe<CommentsEdge>;
};


/** The output of our create `Comment` mutation. */
export type CreateCommentPayloadcommentEdgeArgs = {
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
};

/** All input for the create `Comment` mutation. */
export type CreateCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Comment` to be created by this mutation. */
  comment: CommentInput;
};

/** An input for mutations affecting `Comment` */
export type CommentInput = {
  id?: InputMaybe<Scalars['Int']>;
  customerName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  response?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  custId: Scalars['Int'];
  customers?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** The output of our create `ContentType` mutation. */
export type CreateContentTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContentType` that was created by this mutation. */
  contentType?: Maybe<ContentType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ContentType`. May be used by Relay 1. */
  contentTypeEdge?: Maybe<ContentTypesEdge>;
};


/** The output of our create `ContentType` mutation. */
export type CreateContentTypePayloadcontentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
};

/** All input for the create `ContentType` mutation. */
export type CreateContentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ContentType` to be created by this mutation. */
  contentType: ContentTypeInput;
};

/** An input for mutations affecting `ContentType` */
export type ContentTypeInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  text?: InputMaybe<Scalars['String']>;
  number?: InputMaybe<Scalars['BigFloat']>;
  json?: InputMaybe<Scalars['JSON']>;
  link?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  uid?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['Date']>;
  time?: InputMaybe<Scalars['Time']>;
  timestamp?: InputMaybe<Scalars['Datetime']>;
  boolean?: InputMaybe<Scalars['Boolean']>;
  richText?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  databaseName?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Contract` mutation. */
export type CreateContractPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Contract` that was created by this mutation. */
  contract?: Maybe<Contract>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Contract`. May be used by Relay 1. */
  contractEdge?: Maybe<ContractsEdge>;
};


/** The output of our create `Contract` mutation. */
export type CreateContractPayloadcontractEdgeArgs = {
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
};

/** All input for the create `Contract` mutation. */
export type CreateContractInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Contract` to be created by this mutation. */
  contract: ContractInput;
};

/** An input for mutations affecting `Contract` */
export type ContractInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  contractTitle?: InputMaybe<Scalars['String']>;
  contractValue?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  renewalReminder?: InputMaybe<Scalars['String']>;
  customerSignedDate?: InputMaybe<Scalars['String']>;
  companySignedDate?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  contractManager?: InputMaybe<Scalars['String']>;
  account?: InputMaybe<Scalars['String']>;
  contact?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  opportunity?: InputMaybe<Scalars['String']>;
  contractType?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  lineItems?: InputMaybe<Scalars['String']>;
  total?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  shipping?: InputMaybe<Scalars['String']>;
  shippingTax?: InputMaybe<Scalars['String']>;
  tax?: InputMaybe<Scalars['String']>;
  grandTotal?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `Country` mutation. */
export type CreateCountryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was created by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our create `Country` mutation. */
export type CreateCountryPayloadcountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the create `Country` mutation. */
export type CreateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Country` to be created by this mutation. */
  country: CountryInput;
};

/** An input for mutations affecting `Country` */
export type CountryInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Coupon` mutation. */
export type CreateCouponPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Coupon` that was created by this mutation. */
  coupon?: Maybe<Coupon>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Coupon`. May be used by Relay 1. */
  couponEdge?: Maybe<CouponsEdge>;
};


/** The output of our create `Coupon` mutation. */
export type CreateCouponPayloadcouponEdgeArgs = {
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
};

/** All input for the create `Coupon` mutation. */
export type CreateCouponInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Coupon` to be created by this mutation. */
  coupon: CouponInput;
};

/** An input for mutations affecting `Coupon` */
export type CouponInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  productsCouponsToproducts?: InputMaybe<Scalars['String']>;
};

/** The output of our create `CreditMemo` mutation. */
export type CreateCreditMemoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CreditMemo` that was created by this mutation. */
  creditMemo?: Maybe<CreditMemo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CreditMemo`. May be used by Relay 1. */
  creditMemoEdge?: Maybe<CreditMemosEdge>;
};


/** The output of our create `CreditMemo` mutation. */
export type CreateCreditMemoPayloadcreditMemoEdgeArgs = {
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
};

/** All input for the create `CreditMemo` mutation. */
export type CreateCreditMemoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CreditMemo` to be created by this mutation. */
  creditMemo: CreditMemoInput;
};

/** An input for mutations affecting `CreditMemo` */
export type CreditMemoInput = {
  creditMemo: Scalars['String'];
  orderNumber: Scalars['Int'];
  created?: InputMaybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  status?: InputMaybe<Scalars['String']>;
  refunded?: InputMaybe<Scalars['String']>;
  action?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Currency` mutation. */
export type CreateCurrencyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Currency` that was created by this mutation. */
  currency?: Maybe<Currency>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Currency`. May be used by Relay 1. */
  currencyEdge?: Maybe<CurrenciesEdge>;
};


/** The output of our create `Currency` mutation. */
export type CreateCurrencyPayloadcurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
};

/** All input for the create `Currency` mutation. */
export type CreateCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Currency` to be created by this mutation. */
  currency: CurrencyInput;
};

/** An input for mutations affecting `Currency` */
export type CurrencyInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
};

/** The output of our create `CurrencyRate` mutation. */
export type CreateCurrencyRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencyRate` that was created by this mutation. */
  currencyRate?: Maybe<CurrencyRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencyRate`. May be used by Relay 1. */
  currencyRateEdge?: Maybe<CurrencyRatesEdge>;
};


/** The output of our create `CurrencyRate` mutation. */
export type CreateCurrencyRatePayloadcurrencyRateEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
};

/** All input for the create `CurrencyRate` mutation. */
export type CreateCurrencyRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CurrencyRate` to be created by this mutation. */
  currencyRate: CurrencyRateInput;
};

/** An input for mutations affecting `CurrencyRate` */
export type CurrencyRateInput = {
  importService: Scalars['String'];
  usd?: InputMaybe<Scalars['BigFloat']>;
  id: Scalars['BigInt'];
};

/** The output of our create `CurrencySymbol` mutation. */
export type CreateCurrencySymbolPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencySymbol` that was created by this mutation. */
  currencySymbol?: Maybe<CurrencySymbol>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencySymbol`. May be used by Relay 1. */
  currencySymbolEdge?: Maybe<CurrencySymbolsEdge>;
};


/** The output of our create `CurrencySymbol` mutation. */
export type CreateCurrencySymbolPayloadcurrencySymbolEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
};

/** All input for the create `CurrencySymbol` mutation. */
export type CreateCurrencySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CurrencySymbol` to be created by this mutation. */
  currencySymbol: CurrencySymbolInput;
};

/** An input for mutations affecting `CurrencySymbol` */
export type CurrencySymbolInput = {
  symbol: Scalars['String'];
  useStandard?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** The output of our create `CustomerGroup` mutation. */
export type CreateCustomerGroupPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerGroup` that was created by this mutation. */
  customerGroup?: Maybe<CustomerGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerGroup`. May be used by Relay 1. */
  customerGroupEdge?: Maybe<CustomerGroupsEdge>;
};


/** The output of our create `CustomerGroup` mutation. */
export type CreateCustomerGroupPayloadcustomerGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
};

/** All input for the create `CustomerGroup` mutation. */
export type CreateCustomerGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CustomerGroup` to be created by this mutation. */
  customerGroup: CustomerGroupInput;
};

/** An input for mutations affecting `CustomerGroup` */
export type CustomerGroupInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  taxClass?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  customers?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  coverPhoto?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Customer` mutation. */
export type CreateCustomerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was created by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our create `Customer` mutation. */
export type CreateCustomerPayloadcustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the create `Customer` mutation. */
export type CreateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Customer` to be created by this mutation. */
  customer: CustomerInput;
};

/** An input for mutations affecting `Customer` */
export type CustomerInput = {
  id?: InputMaybe<Scalars['Int']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  namePrefix?: InputMaybe<Scalars['String']>;
  firstName: Scalars['String'];
  middleName?: InputMaybe<Scalars['String']>;
  lastName: Scalars['String'];
  email: Scalars['String'];
  customerGroup?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  nameSuffix?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  customerSince?: InputMaybe<Scalars['Datetime']>;
  confirmedEmail?: InputMaybe<Scalars['String']>;
  dateOfBirth?: InputMaybe<Scalars['String']>;
  taxVatNumber?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  shortDescription?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  paymentType?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  creditMemos?: InputMaybe<Scalars['String']>;
  customerPayment?: InputMaybe<Scalars['String']>;
  emails?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  messages?: InputMaybe<Scalars['String']>;
  newsletterSubscribers?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  returns?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Customization` mutation. */
export type CreateCustomizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customization` that was created by this mutation. */
  customization?: Maybe<Customization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customization`. May be used by Relay 1. */
  customizationEdge?: Maybe<CustomizationsEdge>;
};


/** The output of our create `Customization` mutation. */
export type CreateCustomizationPayloadcustomizationEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
};

/** All input for the create `Customization` mutation. */
export type CreateCustomizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Customization` to be created by this mutation. */
  customization: CustomizationInput;
};

/** An input for mutations affecting `Customization` */
export type CustomizationInput = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  siteName?: InputMaybe<Scalars['String']>;
  navLink?: InputMaybe<Scalars['String']>;
  notification?: InputMaybe<Scalars['String']>;
  banner?: InputMaybe<Scalars['String']>;
  footerLink?: InputMaybe<Scalars['String']>;
  announcement?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  siteUrl?: InputMaybe<Scalars['String']>;
  allowSignup?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Dashboard` mutation. */
export type CreateDashboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Dashboard` that was created by this mutation. */
  dashboard?: Maybe<Dashboard>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Dashboard`. May be used by Relay 1. */
  dashboardEdge?: Maybe<DashboardsEdge>;
};


/** The output of our create `Dashboard` mutation. */
export type CreateDashboardPayloaddashboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
};

/** All input for the create `Dashboard` mutation. */
export type CreateDashboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Dashboard` to be created by this mutation. */
  dashboard: DashboardInput;
};

/** An input for mutations affecting `Dashboard` */
export type DashboardInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  privacy?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  checklists?: InputMaybe<Scalars['String']>;
  visits?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  sales?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Deepdive` mutation. */
export type CreateDeepdivePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Deepdive` that was created by this mutation. */
  deepdive?: Maybe<Deepdive>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Deepdive`. May be used by Relay 1. */
  deepdiveEdge?: Maybe<DeepdivesEdge>;
};


/** The output of our create `Deepdive` mutation. */
export type CreateDeepdivePayloaddeepdiveEdgeArgs = {
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
};

/** All input for the create `Deepdive` mutation. */
export type CreateDeepdiveInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Deepdive` to be created by this mutation. */
  deepdive: DeepdiveInput;
};

/** An input for mutations affecting `Deepdive` */
export type DeepdiveInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  endDate?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  attendees?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Digiboard` mutation. */
export type CreateDigiboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Digiboard` that was created by this mutation. */
  digiboard?: Maybe<Digiboard>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Digiboard`. May be used by Relay 1. */
  digiboardEdge?: Maybe<DigiboardsEdge>;
};


/** The output of our create `Digiboard` mutation. */
export type CreateDigiboardPayloaddigiboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
};

/** All input for the create `Digiboard` mutation. */
export type CreateDigiboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Digiboard` to be created by this mutation. */
  digiboard: DigiboardInput;
};

/** An input for mutations affecting `Digiboard` */
export type DigiboardInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  board?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  student?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Email` mutation. */
export type CreateEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was created by this mutation. */
  email?: Maybe<Email>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our create `Email` mutation. */
export type CreateEmailPayloademailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the create `Email` mutation. */
export type CreateEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Email` to be created by this mutation. */
  email: EmailInput;
};

/** An input for mutations affecting `Email` */
export type EmailInput = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  bcc?: InputMaybe<Scalars['String']>;
  cc?: InputMaybe<Scalars['String']>;
  from?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Endofshift` mutation. */
export type CreateEndofshiftPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Endofshift` that was created by this mutation. */
  endofshift?: Maybe<Endofshift>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Endofshift`. May be used by Relay 1. */
  endofshiftEdge?: Maybe<EndofshiftsEdge>;
};


/** The output of our create `Endofshift` mutation. */
export type CreateEndofshiftPayloadendofshiftEdgeArgs = {
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
};

/** All input for the create `Endofshift` mutation. */
export type CreateEndofshiftInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Endofshift` to be created by this mutation. */
  endofshift: EndofshiftInput;
};

/** An input for mutations affecting `Endofshift` */
export type EndofshiftInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  content?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  mcms?: InputMaybe<Scalars['String']>;
  nextShift?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` that was created by this mutation. */
  event?: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadeventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  start?: InputMaybe<Scalars['String']>;
  end?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Fullfillment` mutation. */
export type CreateFullfillmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Fullfillment` that was created by this mutation. */
  fullfillment?: Maybe<Fullfillment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Fullfillment`. May be used by Relay 1. */
  fullfillmentEdge?: Maybe<FullfillmentsEdge>;
};


/** The output of our create `Fullfillment` mutation. */
export type CreateFullfillmentPayloadfullfillmentEdgeArgs = {
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
};

/** All input for the create `Fullfillment` mutation. */
export type CreateFullfillmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Fullfillment` to be created by this mutation. */
  fullfillment: FullfillmentInput;
};

/** An input for mutations affecting `Fullfillment` */
export type FullfillmentInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  shippingZones?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  countryArea?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  pickup?: InputMaybe<Scalars['String']>;
  stock?: InputMaybe<Scalars['String']>;
};

/** The output of our create `GiftCertificate` mutation. */
export type CreateGiftCertificatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GiftCertificate` that was created by this mutation. */
  giftCertificate?: Maybe<GiftCertificate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `GiftCertificate`. May be used by Relay 1. */
  giftCertificateEdge?: Maybe<GiftCertificatesEdge>;
};


/** The output of our create `GiftCertificate` mutation. */
export type CreateGiftCertificatePayloadgiftCertificateEdgeArgs = {
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
};

/** All input for the create `GiftCertificate` mutation. */
export type CreateGiftCertificateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GiftCertificate` to be created by this mutation. */
  giftCertificate: GiftCertificateInput;
};

/** An input for mutations affecting `GiftCertificate` */
export type GiftCertificateInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  specialOffers?: InputMaybe<Scalars['String']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Glossary` mutation. */
export type CreateGlossaryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Glossary` that was created by this mutation. */
  glossary?: Maybe<Glossary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Glossary`. May be used by Relay 1. */
  glossaryEdge?: Maybe<GlossariesEdge>;
};


/** The output of our create `Glossary` mutation. */
export type CreateGlossaryPayloadglossaryEdgeArgs = {
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
};

/** All input for the create `Glossary` mutation. */
export type CreateGlossaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Glossary` to be created by this mutation. */
  glossary: GlossaryInput;
};

/** An input for mutations affecting `Glossary` */
export type GlossaryInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `Importm` mutation. */
export type CreateImportmPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Importm` that was created by this mutation. */
  importm?: Maybe<Importm>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Importm`. May be used by Relay 1. */
  importmEdge?: Maybe<ImportmsEdge>;
};


/** The output of our create `Importm` mutation. */
export type CreateImportmPayloadimportmEdgeArgs = {
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
};

/** All input for the create `Importm` mutation. */
export type CreateImportmInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Importm` to be created by this mutation. */
  importm: ImportmInput;
};

/** An input for mutations affecting `Importm` */
export type ImportmInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Integration` mutation. */
export type CreateIntegrationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Integration` that was created by this mutation. */
  integration?: Maybe<Integration>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Integration`. May be used by Relay 1. */
  integrationEdge?: Maybe<IntegrationsEdge>;
};


/** The output of our create `Integration` mutation. */
export type CreateIntegrationPayloadintegrationEdgeArgs = {
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
};

/** All input for the create `Integration` mutation. */
export type CreateIntegrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Integration` to be created by this mutation. */
  integration: IntegrationInput;
};

/** An input for mutations affecting `Integration` */
export type IntegrationInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Internalization` mutation. */
export type CreateInternalizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Internalization` that was created by this mutation. */
  internalization?: Maybe<Internalization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Internalization`. May be used by Relay 1. */
  internalizationEdge?: Maybe<InternalizationsEdge>;
};


/** The output of our create `Internalization` mutation. */
export type CreateInternalizationPayloadinternalizationEdgeArgs = {
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
};

/** All input for the create `Internalization` mutation. */
export type CreateInternalizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Internalization` to be created by this mutation. */
  internalization: InternalizationInput;
};

/** An input for mutations affecting `Internalization` */
export type InternalizationInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Invitation` mutation. */
export type CreateInvitationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invitation` that was created by this mutation. */
  invitation?: Maybe<Invitation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invitation`. May be used by Relay 1. */
  invitationEdge?: Maybe<InvitationsEdge>;
};


/** The output of our create `Invitation` mutation. */
export type CreateInvitationPayloadinvitationEdgeArgs = {
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
};

/** All input for the create `Invitation` mutation. */
export type CreateInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Invitation` to be created by this mutation. */
  invitation: InvitationInput;
};

/** An input for mutations affecting `Invitation` */
export type InvitationInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  email?: InputMaybe<Scalars['String']>;
  billingAddress?: InputMaybe<Scalars['String']>;
  shippingAddress?: InputMaybe<Scalars['String']>;
  orderNumber?: InputMaybe<Scalars['String']>;
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was created by this mutation. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayloadinvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the create `Invoice` mutation. */
export type CreateInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Invoice` to be created by this mutation. */
  invoice: InvoiceInput;
};

/** An input for mutations affecting `Invoice` */
export type InvoiceInput = {
  invoice: Scalars['Int'];
  orderNumber: Scalars['BigInt'];
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  billingAddress?: InputMaybe<Scalars['String']>;
  grandTotalBase?: InputMaybe<Scalars['String']>;
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  shippingAddress?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  customerGroup?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  shippingInformation?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  shippingAndHandling?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** The output of our create `Lead` mutation. */
export type CreateLeadPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lead` that was created by this mutation. */
  lead?: Maybe<Lead>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
};


/** The output of our create `Lead` mutation. */
export type CreateLeadPayloadleadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the create `Lead` mutation. */
export type CreateLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Lead` to be created by this mutation. */
  lead: LeadInput;
};

/** An input for mutations affecting `Lead` */
export type LeadInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  prefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  mobile?: InputMaybe<Scalars['String']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  statusDescription?: InputMaybe<Scalars['String']>;
  opportunityAmount?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
  leadSource?: InputMaybe<Scalars['String']>;
  leadSourceDescription?: InputMaybe<Scalars['String']>;
  referredBy?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Manufacturer` mutation. */
export type CreateManufacturerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Manufacturer` that was created by this mutation. */
  manufacturer?: Maybe<Manufacturer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Manufacturer`. May be used by Relay 1. */
  manufacturerEdge?: Maybe<ManufacturersEdge>;
};


/** The output of our create `Manufacturer` mutation. */
export type CreateManufacturerPayloadmanufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
};

/** All input for the create `Manufacturer` mutation. */
export type CreateManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Manufacturer` to be created by this mutation. */
  manufacturer: ManufacturerInput;
};

/** An input for mutations affecting `Manufacturer` */
export type ManufacturerInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Mediamanager` mutation. */
export type CreateMediamanagerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Mediamanager` that was created by this mutation. */
  mediamanager?: Maybe<Mediamanager>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Mediamanager`. May be used by Relay 1. */
  mediamanagerEdge?: Maybe<MediamanagersEdge>;
};


/** The output of our create `Mediamanager` mutation. */
export type CreateMediamanagerPayloadmediamanagerEdgeArgs = {
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
};

/** All input for the create `Mediamanager` mutation. */
export type CreateMediamanagerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Mediamanager` to be created by this mutation. */
  mediamanager: MediamanagerInput;
};

/** An input for mutations affecting `Mediamanager` */
export type MediamanagerInput = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  keywords?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  brands?: InputMaybe<Scalars['BigInt']>;
  status?: InputMaybe<Scalars['String']>;
  expirationDate?: InputMaybe<Scalars['String']>;
  copyright?: InputMaybe<Scalars['String']>;
  dimensions?: InputMaybe<Scalars['String']>;
  author?: InputMaybe<Scalars['Int']>;
  contentType?: InputMaybe<Scalars['String']>;
  versions?: InputMaybe<Scalars['String']>;
  watermarkName?: InputMaybe<Scalars['String']>;
  watermarkDescription?: InputMaybe<Scalars['String']>;
  watermarkMedia?: InputMaybe<Scalars['String']>;
  agreements?: InputMaybe<Scalars['Int']>;
  albums?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['Int']>;
  workspace?: InputMaybe<Scalars['String']>;
  taskName?: InputMaybe<Scalars['BigInt']>;
  taskDescription?: InputMaybe<Scalars['String']>;
  taskType?: InputMaybe<Scalars['String']>;
  members?: InputMaybe<Scalars['Int']>;
  products?: InputMaybe<Scalars['BigInt']>;
  agreementsAgreementsTomediamanager?: InputMaybe<Scalars['String']>;
  brandsBrandsTomediamanager?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  productsMediamanagerToproducts?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Meeting` mutation. */
export type CreateMeetingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Meeting` that was created by this mutation. */
  meeting?: Maybe<Meeting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Meeting`. May be used by Relay 1. */
  meetingEdge?: Maybe<MeetingsEdge>;
};


/** The output of our create `Meeting` mutation. */
export type CreateMeetingPayloadmeetingEdgeArgs = {
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
};

/** All input for the create `Meeting` mutation. */
export type CreateMeetingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Meeting` to be created by this mutation. */
  meeting: MeetingInput;
};

/** An input for mutations affecting `Meeting` */
export type MeetingInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  duration?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  relatedTo?: InputMaybe<Scalars['String']>;
  reminders?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  invitees?: InputMaybe<Scalars['String']>;
  scheduling?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Message` mutation. */
export type CreateMessagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was created by this mutation. */
  message?: Maybe<Message>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
};


/** The output of our create `Message` mutation. */
export type CreateMessagePayloadmessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the create `Message` mutation. */
export type CreateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Message` to be created by this mutation. */
  message: MessageInput;
};

/** An input for mutations affecting `Message` */
export type MessageInput = {
  id?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  media?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Newsletter` mutation. */
export type CreateNewsletterPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Newsletter` that was created by this mutation. */
  newsletter?: Maybe<Newsletter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Newsletter`. May be used by Relay 1. */
  newsletterEdge?: Maybe<NewslettersEdge>;
};


/** The output of our create `Newsletter` mutation. */
export type CreateNewsletterPayloadnewsletterEdgeArgs = {
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
};

/** All input for the create `Newsletter` mutation. */
export type CreateNewsletterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Newsletter` to be created by this mutation. */
  newsletter: NewsletterInput;
};

/** An input for mutations affecting `Newsletter` */
export type NewsletterInput = {
  id?: InputMaybe<Scalars['Int']>;
  email: Scalars['String'];
  customerFirstName?: InputMaybe<Scalars['String']>;
  customerLastName?: InputMaybe<Scalars['String']>;
  store?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  custId: Scalars['Int'];
  customers?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Ooto` mutation. */
export type CreateOotoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ooto` that was created by this mutation. */
  ooto?: Maybe<Ooto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ooto`. May be used by Relay 1. */
  ootoEdge?: Maybe<OotosEdge>;
};


/** The output of our create `Ooto` mutation. */
export type CreateOotoPayloadootoEdgeArgs = {
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
};

/** All input for the create `Ooto` mutation. */
export type CreateOotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Ooto` to be created by this mutation. */
  ooto: OotoInput;
};

/** An input for mutations affecting `Ooto` */
export type OotoInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  login?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  note?: InputMaybe<Scalars['String']>;
  usingTime?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Opportunity` mutation. */
export type CreateOpportunityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Opportunity` that was created by this mutation. */
  opportunity?: Maybe<Opportunity>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
};


/** The output of our create `Opportunity` mutation. */
export type CreateOpportunityPayloadopportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the create `Opportunity` mutation. */
export type CreateOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Opportunity` to be created by this mutation. */
  opportunity: OpportunityInput;
};

/** An input for mutations affecting `Opportunity` */
export type OpportunityInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  amount?: InputMaybe<Scalars['String']>;
  salesStage?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  probability?: InputMaybe<Scalars['String']>;
  nextStep?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  leadSource?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  expectedCloseDate?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Order` mutation. */
export type CreateOrderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Order` that was created by this mutation. */
  order?: Maybe<Order>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Order`. May be used by Relay 1. */
  orderEdge?: Maybe<OrdersEdge>;
};


/** The output of our create `Order` mutation. */
export type CreateOrderPayloadorderEdgeArgs = {
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
};

/** All input for the create `Order` mutation. */
export type CreateOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Order` to be created by this mutation. */
  order: OrderInput;
};

/** An input for mutations affecting `Order` */
export type OrderInput = {
  id?: InputMaybe<Scalars['Int']>;
  purchasePoint?: InputMaybe<Scalars['Int']>;
  purchaseDate?: InputMaybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  shipToName?: InputMaybe<Scalars['String']>;
  grandTotalBase?: InputMaybe<Scalars['Int']>;
  grandTotalPurchased?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<Scalars['Boolean']>;
  action?: InputMaybe<Scalars['Boolean']>;
  allocatedSources?: InputMaybe<Scalars['String']>;
  braintreeTransactionSource?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  transactions?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` that was created by this mutation. */
  page?: Maybe<Page>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge?: Maybe<PagesEdge>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadpageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  id?: InputMaybe<Scalars['Int']>;
  enablePage?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  contentTitle?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  urlKey?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Partner` mutation. */
export type CreatePartnerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Partner` that was created by this mutation. */
  partner?: Maybe<Partner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Partner`. May be used by Relay 1. */
  partnerEdge?: Maybe<PartnersEdge>;
};


/** The output of our create `Partner` mutation. */
export type CreatePartnerPayloadpartnerEdgeArgs = {
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
};

/** All input for the create `Partner` mutation. */
export type CreatePartnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Partner` to be created by this mutation. */
  partner: PartnerInput;
};

/** An input for mutations affecting `Partner` */
export type PartnerInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  businessType?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Payment` mutation. */
export type CreatePaymentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was created by this mutation. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our create `Payment` mutation. */
export type CreatePaymentPayloadpaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the create `Payment` mutation. */
export type CreatePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Payment` to be created by this mutation. */
  payment: PaymentInput;
};

/** An input for mutations affecting `Payment` */
export type PaymentInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  hostUri?: InputMaybe<Scalars['String']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  active?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Permission` mutation. */
export type CreatePermissionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Permission` that was created by this mutation. */
  permission?: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
};


/** The output of our create `Permission` mutation. */
export type CreatePermissionPayloadpermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the create `Permission` mutation. */
export type CreatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Permission` to be created by this mutation. */
  permission: PermissionInput;
};

/** An input for mutations affecting `Permission` */
export type PermissionInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  create?: InputMaybe<Scalars['String']>;
  delete?: InputMaybe<Scalars['String']>;
  read?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Plugin` mutation. */
export type CreatePluginPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Plugin` that was created by this mutation. */
  plugin?: Maybe<Plugin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Plugin`. May be used by Relay 1. */
  pluginEdge?: Maybe<PluginsEdge>;
};


/** The output of our create `Plugin` mutation. */
export type CreatePluginPayloadpluginEdgeArgs = {
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
};

/** All input for the create `Plugin` mutation. */
export type CreatePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Plugin` to be created by this mutation. */
  plugin: PluginInput;
};

/** An input for mutations affecting `Plugin` */
export type PluginInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  githubLink?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  logo?: InputMaybe<Scalars['String']>;
  screenshots?: InputMaybe<Scalars['String']>;
  lastUpdated?: InputMaybe<Scalars['Datetime']>;
  publisherName?: InputMaybe<Scalars['String']>;
  agreeTerms?: InputMaybe<Scalars['Boolean']>;
  publisherEmail?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Poll` mutation. */
export type CreatePollPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Poll` that was created by this mutation. */
  poll?: Maybe<Poll>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Poll`. May be used by Relay 1. */
  pollEdge?: Maybe<PollsEdge>;
};


/** The output of our create `Poll` mutation. */
export type CreatePollPayloadpollEdgeArgs = {
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
};

/** All input for the create `Poll` mutation. */
export type CreatePollInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Poll` to be created by this mutation. */
  poll: PollInput;
};

/** An input for mutations affecting `Poll` */
export type PollInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  question?: InputMaybe<Scalars['String']>;
  response?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `ProductType` mutation. */
export type CreateProductTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductType` that was created by this mutation. */
  productType?: Maybe<ProductType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductType`. May be used by Relay 1. */
  productTypeEdge?: Maybe<ProductTypesEdge>;
};


/** The output of our create `ProductType` mutation. */
export type CreateProductTypePayloadproductTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
};

/** All input for the create `ProductType` mutation. */
export type CreateProductTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ProductType` to be created by this mutation. */
  productType: ProductTypeInput;
};

/** An input for mutations affecting `ProductType` */
export type ProductTypeInput = {
  id?: InputMaybe<Scalars['Int']>;
  typeName?: InputMaybe<Scalars['String']>;
  taxes?: InputMaybe<Scalars['String']>;
  isShippable?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  filterOptions?: InputMaybe<Scalars['String']>;
  productType?: InputMaybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Product` mutation. */
export type CreateProductPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Product` that was created by this mutation. */
  product?: Maybe<Product>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Product`. May be used by Relay 1. */
  productEdge?: Maybe<ProductsEdge>;
};


/** The output of our create `Product` mutation. */
export type CreateProductPayloadproductEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
};

/** All input for the create `Product` mutation. */
export type CreateProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Product` to be created by this mutation. */
  product: ProductInput;
};

/** An input for mutations affecting `Product` */
export type ProductInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  sku: Scalars['BigInt'];
  thumbnail?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  price?: InputMaybe<Scalars['String']>;
  quantityPerSource?: InputMaybe<Scalars['String']>;
  salableQuantity?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['Boolean']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  taxClass?: InputMaybe<Scalars['String']>;
  stockStatus?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  country?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['String']>;
  format?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  shortDescription?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
  manufacture?: InputMaybe<Scalars['String']>;
  attributes?: InputMaybe<Scalars['String']>;
  brand?: InputMaybe<Scalars['String']>;
  contract?: InputMaybe<Scalars['String']>;
  costString?: InputMaybe<Scalars['String']>;
  customerType?: InputMaybe<Scalars['String']>;
  family?: InputMaybe<Scalars['String']>;
  manufacturerPartNumber?: InputMaybe<Scalars['String']>;
  occassions?: InputMaybe<Scalars['String']>;
  partNumber?: InputMaybe<Scalars['String']>;
  relatedProduct?: InputMaybe<Scalars['BigInt']>;
  tags?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Scalars['String']>;
  variants?: InputMaybe<Scalars['String']>;
  zone?: InputMaybe<Scalars['String']>;
  brands?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  creditMemos?: InputMaybe<Scalars['String']>;
  manufacturer?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  occassionsOccassionsToproducts?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  otherProducts?: InputMaybe<Scalars['String']>;
  productAttribute?: InputMaybe<Scalars['String']>;
  productTypes?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  returns?: InputMaybe<Scalars['String']>;
  taxRate?: InputMaybe<Scalars['String']>;
  taxRule?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Project` mutation. */
export type CreateProjectPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Project` that was created by this mutation. */
  project?: Maybe<Project>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
};


/** The output of our create `Project` mutation. */
export type CreateProjectPayloadprojectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the create `Project` mutation. */
export type CreateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Project` to be created by this mutation. */
  project: ProjectInput;
};

/** An input for mutations affecting `Project` */
export type ProjectInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  projectManager?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  resource?: InputMaybe<Scalars['String']>;
  considerworkingdays?: InputMaybe<Scalars['String']>;
  projectTemplate?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  assignee?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  doing?: InputMaybe<Scalars['String']>;
  done?: InputMaybe<Scalars['String']>;
  goalCollaborators?: InputMaybe<Scalars['String']>;
  goalMeasurement?: InputMaybe<Scalars['String']>;
  goalName?: InputMaybe<Scalars['String']>;
  goalPrivacy?: InputMaybe<Scalars['String']>;
  goalProgressSource?: InputMaybe<Scalars['String']>;
  goalTimeperiod?: InputMaybe<Scalars['String']>;
  goalUpdatemethod?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  sectionRule?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  taskId?: InputMaybe<Scalars['BigInt']>;
  ticketId?: InputMaybe<Scalars['BigInt']>;
  customers?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  ticketing?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  method?: InputMaybe<Scalars['String']>;
  zone?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  team?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Provider` mutation. */
export type CreateProviderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Provider` that was created by this mutation. */
  provider?: Maybe<Provider>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Provider`. May be used by Relay 1. */
  providerEdge?: Maybe<ProvidersEdge>;
};


/** The output of our create `Provider` mutation. */
export type CreateProviderPayloadproviderEdgeArgs = {
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
};

/** All input for the create `Provider` mutation. */
export type CreateProviderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Provider` to be created by this mutation. */
  provider: ProviderInput;
};

/** An input for mutations affecting `Provider` */
export type ProviderInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  hostUri?: InputMaybe<Scalars['String']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  active?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Quote` mutation. */
export type CreateQuotePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was created by this mutation. */
  quote?: Maybe<Quote>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our create `Quote` mutation. */
export type CreateQuotePayloadquoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the create `Quote` mutation. */
export type CreateQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Quote` to be created by this mutation. */
  quote: QuoteInput;
};

/** An input for mutations affecting `Quote` */
export type QuoteInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  grandTotal?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  categories?: InputMaybe<Scalars['String']>;
  validUntil?: InputMaybe<Scalars['String']>;
  quoteStage?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  orderId: Scalars['Int'];
  account?: InputMaybe<Scalars['String']>;
  approvalIssues?: InputMaybe<Scalars['String']>;
  approvalStatus?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  billingCity?: InputMaybe<Scalars['String']>;
  billingCountry?: InputMaybe<Scalars['String']>;
  billingPostal?: InputMaybe<Scalars['String']>;
  billingState?: InputMaybe<Scalars['String']>;
  billingStreet?: InputMaybe<Scalars['String']>;
  contact?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  invoiceStatus?: InputMaybe<Scalars['String']>;
  lineItemDiscount?: InputMaybe<Scalars['String']>;
  lineItemGroupTotal?: InputMaybe<Scalars['String']>;
  lineItemName?: InputMaybe<Scalars['String']>;
  lineItemSubtotal?: InputMaybe<Scalars['String']>;
  lineItemTax?: InputMaybe<Scalars['String']>;
  lineItemTotal?: InputMaybe<Scalars['String']>;
  paymentTerms?: InputMaybe<Scalars['String']>;
  shipping?: InputMaybe<Scalars['String']>;
  shippingCity?: InputMaybe<Scalars['String']>;
  shippingCountry?: InputMaybe<Scalars['String']>;
  shippingPostal?: InputMaybe<Scalars['String']>;
  shippingState?: InputMaybe<Scalars['String']>;
  shippingStreet?: InputMaybe<Scalars['String']>;
  shippingTax?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  tax?: InputMaybe<Scalars['String']>;
  total?: InputMaybe<Scalars['String']>;
  customersCustomersToquotes?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  productsProductsToquotes?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Rating` mutation. */
export type CreateRatingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Rating` that was created by this mutation. */
  rating?: Maybe<Rating>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Rating`. May be used by Relay 1. */
  ratingEdge?: Maybe<RatingsEdge>;
};


/** The output of our create `Rating` mutation. */
export type CreateRatingPayloadratingEdgeArgs = {
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
};

/** All input for the create `Rating` mutation. */
export type CreateRatingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Rating` to be created by this mutation. */
  rating: RatingInput;
};

/** An input for mutations affecting `Rating` */
export type RatingInput = {
  id?: InputMaybe<Scalars['Int']>;
  defaultValue?: InputMaybe<Scalars['String']>;
  defaultStoreView?: InputMaybe<Scalars['String']>;
  ratingVisibility?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  sortOrder?: InputMaybe<Scalars['BigFloat']>;
  prodId: Scalars['BigInt'];
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Report` mutation. */
export type CreateReportPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Report` that was created by this mutation. */
  report?: Maybe<Report>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
};


/** The output of our create `Report` mutation. */
export type CreateReportPayloadreportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the create `Report` mutation. */
export type CreateReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Report` to be created by this mutation. */
  report: ReportInput;
};

/** An input for mutations affecting `Report` */
export type ReportInput = {
  id?: InputMaybe<Scalars['Int']>;
  customer?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['BigFloat']>;
  subtotal?: InputMaybe<Scalars['String']>;
  appliedCoupon?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  ipAddress?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Return` mutation. */
export type CreateReturnPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Return` that was created by this mutation. */
  return?: Maybe<Return>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Return`. May be used by Relay 1. */
  returnEdge?: Maybe<ReturnsEdge>;
};


/** The output of our create `Return` mutation. */
export type CreateReturnPayloadreturnEdgeArgs = {
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
};

/** All input for the create `Return` mutation. */
export type CreateReturnInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Return` to be created by this mutation. */
  return: ReturnInput;
};

/** An input for mutations affecting `Return` */
export type ReturnInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  validity?: InputMaybe<Scalars['String']>;
  returnPrefix?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  shippingNumber?: InputMaybe<Scalars['String']>;
  shippingDescription?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  liquidationReason?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['String']>;
  howShipped?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  shipTo?: InputMaybe<Scalars['String']>;
  caseId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Review` mutation. */
export type CreateReviewPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was created by this mutation. */
  review?: Maybe<Review>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our create `Review` mutation. */
export type CreateReviewPayloadreviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the create `Review` mutation. */
export type CreateReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Review` to be created by this mutation. */
  review: ReviewInput;
};

/** An input for mutations affecting `Review` */
export type ReviewInput = {
  id?: InputMaybe<Scalars['Int']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  shopId: Scalars['Int'];
  commentId: Scalars['Int'];
};

/** The output of our create `Reward` mutation. */
export type CreateRewardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reward` that was created by this mutation. */
  reward?: Maybe<Reward>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Reward`. May be used by Relay 1. */
  rewardEdge?: Maybe<RewardsEdge>;
};


/** The output of our create `Reward` mutation. */
export type CreateRewardPayloadrewardEdgeArgs = {
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
};

/** All input for the create `Reward` mutation. */
export type CreateRewardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Reward` to be created by this mutation. */
  reward: RewardInput;
};

/** An input for mutations affecting `Reward` */
export type RewardInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  slug?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Role` mutation. */
export type CreateRolePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Role` that was created by this mutation. */
  role?: Maybe<Role>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our create `Role` mutation. */
export type CreateRolePayloadroleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the create `Role` mutation. */
export type CreateRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Role` to be created by this mutation. */
  role: RoleInput;
};

/** An input for mutations affecting `Role` */
export type RoleInput = {
  id?: InputMaybe<Scalars['Int']>;
  roleName: Scalars['String'];
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `Scheduler` mutation. */
export type CreateSchedulerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Scheduler` that was created by this mutation. */
  scheduler?: Maybe<Scheduler>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
};


/** The output of our create `Scheduler` mutation. */
export type CreateSchedulerPayloadschedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the create `Scheduler` mutation. */
export type CreateSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Scheduler` to be created by this mutation. */
  scheduler: SchedulerInput;
};

/** An input for mutations affecting `Scheduler` */
export type SchedulerInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  endDate?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  notes?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Segment` mutation. */
export type CreateSegmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Segment` that was created by this mutation. */
  segment?: Maybe<Segment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Segment`. May be used by Relay 1. */
  segmentEdge?: Maybe<SegmentsEdge>;
};


/** The output of our create `Segment` mutation. */
export type CreateSegmentPayloadsegmentEdgeArgs = {
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
};

/** All input for the create `Segment` mutation. */
export type CreateSegmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Segment` to be created by this mutation. */
  segment: SegmentInput;
};

/** An input for mutations affecting `Segment` */
export type SegmentInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  applyTo?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Setting` mutation. */
export type CreateSettingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Setting` that was created by this mutation. */
  setting?: Maybe<Setting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our create `Setting` mutation. */
export type CreateSettingPayloadsettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the create `Setting` mutation. */
export type CreateSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Setting` to be created by this mutation. */
  setting: SettingInput;
};

/** An input for mutations affecting `Setting` */
export type SettingInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  storeName?: InputMaybe<Scalars['String']>;
  storePhone?: InputMaybe<Scalars['String']>;
  storeHours?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  vatNumber?: InputMaybe<Scalars['String']>;
  allowState?: InputMaybe<Scalars['String']>;
  stateRequiredFor?: InputMaybe<Scalars['String']>;
  allowCountries?: InputMaybe<Scalars['String']>;
  defaultCountry?: InputMaybe<Scalars['String']>;
  optionalZip?: InputMaybe<Scalars['String']>;
  europeanUnionCountries?: InputMaybe<Scalars['String']>;
  topDestinations?: InputMaybe<Scalars['String']>;
  baseCurrency?: InputMaybe<Scalars['String']>;
  defaultCurrency?: InputMaybe<Scalars['String']>;
  allowedCurrency?: InputMaybe<Scalars['String']>;
  siteName?: InputMaybe<Scalars['String']>;
  siteWebsite?: InputMaybe<Scalars['String']>;
  sentryDsn?: InputMaybe<Scalars['String']>;
  awsS3?: InputMaybe<Scalars['String']>;
  databaseUrl?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  googleAnalytics?: InputMaybe<Scalars['String']>;
  searchSetting?: InputMaybe<Scalars['String']>;
  mailServer?: InputMaybe<Scalars['String']>;
  youtubeVideos?: InputMaybe<Scalars['String']>;
  siteTagline?: InputMaybe<Scalars['String']>;
  googleDrive?: InputMaybe<Scalars['String']>;
  disqusKey?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Shipment` mutation. */
export type CreateShipmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipment` that was created by this mutation. */
  shipment?: Maybe<Shipment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Shipment`. May be used by Relay 1. */
  shipmentEdge?: Maybe<ShipmentsEdge>;
};


/** The output of our create `Shipment` mutation. */
export type CreateShipmentPayloadshipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
};

/** All input for the create `Shipment` mutation. */
export type CreateShipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Shipment` to be created by this mutation. */
  shipment: ShipmentInput;
};

/** An input for mutations affecting `Shipment` */
export type ShipmentInput = {
  product?: InputMaybe<Scalars['String']>;
  speedGrade?: InputMaybe<Scalars['String']>;
  shipDate?: InputMaybe<Scalars['Datetime']>;
  carrierName: Scalars['String'];
  transitTime?: InputMaybe<Scalars['String']>;
  trackingUrl?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
};

/** The output of our create `SpecialDiscount` mutation. */
export type CreateSpecialDiscountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpecialDiscount` that was created by this mutation. */
  specialDiscount?: Maybe<SpecialDiscount>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SpecialDiscount`. May be used by Relay 1. */
  specialDiscountEdge?: Maybe<SpecialDiscountsEdge>;
};


/** The output of our create `SpecialDiscount` mutation. */
export type CreateSpecialDiscountPayloadspecialDiscountEdgeArgs = {
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
};

/** All input for the create `SpecialDiscount` mutation. */
export type CreateSpecialDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `SpecialDiscount` to be created by this mutation. */
  specialDiscount: SpecialDiscountInput;
};

/** An input for mutations affecting `SpecialDiscount` */
export type SpecialDiscountInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['BigFloat']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['Date']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `State` mutation. */
export type CreateStatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `State` that was created by this mutation. */
  state?: Maybe<State>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `State`. May be used by Relay 1. */
  stateEdge?: Maybe<StatesEdge>;
};


/** The output of our create `State` mutation. */
export type CreateStatePayloadstateEdgeArgs = {
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
};

/** All input for the create `State` mutation. */
export type CreateStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `State` to be created by this mutation. */
  state: StateInput;
};

/** An input for mutations affecting `State` */
export type StateInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Statistic` mutation. */
export type CreateStatisticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Statistic` that was created by this mutation. */
  statistic?: Maybe<Statistic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Statistic`. May be used by Relay 1. */
  statisticEdge?: Maybe<StatisticsEdge>;
};


/** The output of our create `Statistic` mutation. */
export type CreateStatisticPayloadstatisticEdgeArgs = {
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
};

/** All input for the create `Statistic` mutation. */
export type CreateStatisticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Statistic` to be created by this mutation. */
  statistic: StatisticInput;
};

/** An input for mutations affecting `Statistic` */
export type StatisticInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  specialOffers?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['Date']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Stock` mutation. */
export type CreateStockPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Stock` that was created by this mutation. */
  stock?: Maybe<Stock>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Stock`. May be used by Relay 1. */
  stockEdge?: Maybe<StocksEdge>;
};


/** The output of our create `Stock` mutation. */
export type CreateStockPayloadstockEdgeArgs = {
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
};

/** All input for the create `Stock` mutation. */
export type CreateStockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Stock` to be created by this mutation. */
  stock: StockInput;
};

/** An input for mutations affecting `Stock` */
export type StockInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  enabled?: InputMaybe<Scalars['Boolean']>;
  description?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  sources?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Survey` mutation. */
export type CreateSurveyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Survey` that was created by this mutation. */
  survey?: Maybe<Survey>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Survey`. May be used by Relay 1. */
  surveyEdge?: Maybe<SurveysEdge>;
};


/** The output of our create `Survey` mutation. */
export type CreateSurveyPayloadsurveyEdgeArgs = {
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
};

/** All input for the create `Survey` mutation. */
export type CreateSurveyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Survey` to be created by this mutation. */
  survey: SurveyInput;
};

/** An input for mutations affecting `Survey` */
export type SurveyInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  question?: InputMaybe<Scalars['String']>;
  answer?: InputMaybe<Scalars['String']>;
  submitText?: InputMaybe<Scalars['String']>;
  satisfiedText?: InputMaybe<Scalars['String']>;
  neitherText?: InputMaybe<Scalars['String']>;
  dissatisfiedText?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Tag` mutation. */
export type CreateTagPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Tag` that was created by this mutation. */
  tag?: Maybe<Tag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our create `Tag` mutation. */
export type CreateTagPayloadtagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the create `Tag` mutation. */
export type CreateTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Tag` to be created by this mutation. */
  tag: TagInput;
};

/** An input for mutations affecting `Tag` */
export type TagInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Target` mutation. */
export type CreateTargetPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Target` that was created by this mutation. */
  target?: Maybe<Target>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Target`. May be used by Relay 1. */
  targetEdge?: Maybe<TargetsEdge>;
};


/** The output of our create `Target` mutation. */
export type CreateTargetPayloadtargetEdgeArgs = {
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
};

/** All input for the create `Target` mutation. */
export type CreateTargetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Target` to be created by this mutation. */
  target: TargetInput;
};

/** An input for mutations affecting `Target` */
export type TargetInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  prefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  mobile?: InputMaybe<Scalars['String']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
  emailOptOut?: InputMaybe<Scalars['String']>;
  donotcall?: InputMaybe<Scalars['String']>;
};

/** The output of our create `TaxCategory` mutation. */
export type CreateTaxCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxCategory` that was created by this mutation. */
  taxCategory?: Maybe<TaxCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxCategory`. May be used by Relay 1. */
  taxCategoryEdge?: Maybe<TaxCategoriesEdge>;
};


/** The output of our create `TaxCategory` mutation. */
export type CreateTaxCategoryPayloadtaxCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
};

/** All input for the create `TaxCategory` mutation. */
export type CreateTaxCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TaxCategory` to be created by this mutation. */
  taxCategory: TaxCategoryInput;
};

/** An input for mutations affecting `TaxCategory` */
export type TaxCategoryInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
};

/** The output of our create `TaxRate` mutation. */
export type CreateTaxRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRate` that was created by this mutation. */
  taxRate?: Maybe<TaxRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRate`. May be used by Relay 1. */
  taxRateEdge?: Maybe<TaxRatesEdge>;
};


/** The output of our create `TaxRate` mutation. */
export type CreateTaxRatePayloadtaxRateEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
};

/** All input for the create `TaxRate` mutation. */
export type CreateTaxRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TaxRate` to be created by this mutation. */
  taxRate: TaxRateInput;
};

/** An input for mutations affecting `TaxRate` */
export type TaxRateInput = {
  id?: InputMaybe<Scalars['Int']>;
  taxIdentifier: Scalars['String'];
  zipPostIsRange?: InputMaybe<Scalars['Boolean']>;
  postcode?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  ratePercent?: InputMaybe<Scalars['String']>;
  defaultStoreView?: InputMaybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `TaxRule` mutation. */
export type CreateTaxRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRule` that was created by this mutation. */
  taxRule?: Maybe<TaxRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRule`. May be used by Relay 1. */
  taxRuleEdge?: Maybe<TaxRulesEdge>;
};


/** The output of our create `TaxRule` mutation. */
export type CreateTaxRulePayloadtaxRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
};

/** All input for the create `TaxRule` mutation. */
export type CreateTaxRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TaxRule` to be created by this mutation. */
  taxRule: TaxRuleInput;
};

/** An input for mutations affecting `TaxRule` */
export type TaxRuleInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  taxRate?: InputMaybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Template` mutation. */
export type CreateTemplatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was created by this mutation. */
  template?: Maybe<Template>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our create `Template` mutation. */
export type CreateTemplatePayloadtemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the create `Template` mutation. */
export type CreateTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Template` to be created by this mutation. */
  template: TemplateInput;
};

/** An input for mutations affecting `Template` */
export type TemplateInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['String']>;
  pageSize?: InputMaybe<Scalars['String']>;
  orientation?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  header?: InputMaybe<Scalars['String']>;
  footer?: InputMaybe<Scalars['String']>;
  marginLeft?: InputMaybe<Scalars['String']>;
  marginRight?: InputMaybe<Scalars['String']>;
  marginTop?: InputMaybe<Scalars['String']>;
  marginBottom?: InputMaybe<Scalars['String']>;
  marginHeader?: InputMaybe<Scalars['String']>;
  marginFooter?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Theme` mutation. */
export type CreateThemePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Theme` that was created by this mutation. */
  theme?: Maybe<Theme>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Theme`. May be used by Relay 1. */
  themeEdge?: Maybe<ThemesEdge>;
};


/** The output of our create `Theme` mutation. */
export type CreateThemePayloadthemeEdgeArgs = {
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
};

/** All input for the create `Theme` mutation. */
export type CreateThemeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Theme` to be created by this mutation. */
  theme: ThemeInput;
};

/** An input for mutations affecting `Theme` */
export type ThemeInput = {
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  parentTheme?: InputMaybe<Scalars['String']>;
  themePath?: InputMaybe<Scalars['String']>;
  action?: InputMaybe<Scalars['String']>;
  websiteId: Scalars['BigInt'];
  websites: Scalars['String'];
};

/** The output of our create `Ticketing` mutation. */
export type CreateTicketingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ticketing` that was created by this mutation. */
  ticketing?: Maybe<Ticketing>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ticketing`. May be used by Relay 1. */
  ticketingEdge?: Maybe<TicketingsEdge>;
};


/** The output of our create `Ticketing` mutation. */
export type CreateTicketingPayloadticketingEdgeArgs = {
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
};

/** All input for the create `Ticketing` mutation. */
export type CreateTicketingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Ticketing` to be created by this mutation. */
  ticketing: TicketingInput;
};

/** An input for mutations affecting `Ticketing` */
export type TicketingInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['String']>;
  severity?: InputMaybe<Scalars['String']>;
  team?: InputMaybe<Scalars['String']>;
  requester?: InputMaybe<Scalars['String']>;
  requesterEmail?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  ticketType?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  resolution?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  dateModified?: InputMaybe<Scalars['Datetime']>;
  accountName?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  projectsProjectsToticketing?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Training` mutation. */
export type CreateTrainingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Training` that was created by this mutation. */
  training?: Maybe<Training>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Training`. May be used by Relay 1. */
  trainingEdge?: Maybe<TrainingsEdge>;
};


/** The output of our create `Training` mutation. */
export type CreateTrainingPayloadtrainingEdgeArgs = {
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
};

/** All input for the create `Training` mutation. */
export type CreateTrainingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Training` to be created by this mutation. */
  training: TrainingInput;
};

/** An input for mutations affecting `Training` */
export type TrainingInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  link?: InputMaybe<Scalars['String']>;
  steps?: InputMaybe<Scalars['String']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  analytics?: InputMaybe<Scalars['String']>;
  competency?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Scalars['String']>;
  grade?: InputMaybe<Scalars['String']>;
  school?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['Int']>;
  address?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['Int']>;
  postal?: InputMaybe<Scalars['String']>;
  teacher?: InputMaybe<Scalars['String']>;
  student?: InputMaybe<Scalars['String']>;
  announcement?: InputMaybe<Scalars['String']>;
  resource?: InputMaybe<Scalars['String']>;
  badges?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  isCompleted?: InputMaybe<Scalars['String']>;
  speakers?: InputMaybe<Scalars['String']>;
  fieldTrips?: InputMaybe<Scalars['String']>;
  assignments?: InputMaybe<Scalars['String']>;
  assignmentsDueDate?: InputMaybe<Scalars['String']>;
  origanalityReport?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['BigInt']>;
  faqs?: InputMaybe<Scalars['String']>;
  languages?: InputMaybe<Scalars['String']>;
  checklists?: InputMaybe<Scalars['BigInt']>;
  city?: InputMaybe<Scalars['String']>;
  meetups?: InputMaybe<Scalars['String']>;
  lab?: InputMaybe<Scalars['String']>;
  digiboards?: InputMaybe<Scalars['String']>;
  countries?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Transaction` mutation. */
export type CreateTransactionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was created by this mutation. */
  transaction?: Maybe<Transaction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our create `Transaction` mutation. */
export type CreateTransactionPayloadtransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the create `Transaction` mutation. */
export type CreateTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Transaction` to be created by this mutation. */
  transaction: TransactionInput;
};

/** An input for mutations affecting `Transaction` */
export type TransactionInput = {
  id?: InputMaybe<Scalars['Int']>;
  orderId: Scalars['Int'];
  transactionId: Scalars['Int'];
  parentTransactionId: Scalars['Int'];
  created?: InputMaybe<Scalars['Datetime']>;
  paymentMethod: Scalars['BigInt'];
  closed?: InputMaybe<Scalars['String']>;
  customerPayment?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
};

/** The output of our create `UploadFile` mutation. */
export type CreateUploadFilePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UploadFile` that was created by this mutation. */
  uploadFile?: Maybe<UploadFile>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `UploadFile`. May be used by Relay 1. */
  uploadFileEdge?: Maybe<UploadFilesEdge>;
};


/** The output of our create `UploadFile` mutation. */
export type CreateUploadFilePayloaduploadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
};

/** All input for the create `UploadFile` mutation. */
export type CreateUploadFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `UploadFile` to be created by this mutation. */
  uploadFile: UploadFileInput;
};

/** An input for mutations affecting `UploadFile` */
export type UploadFileInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  alternativeText?: InputMaybe<Scalars['String']>;
  caption?: InputMaybe<Scalars['String']>;
  width?: InputMaybe<Scalars['Int']>;
  height?: InputMaybe<Scalars['Int']>;
  formats?: InputMaybe<Scalars['JSON']>;
  hash: Scalars['String'];
  ext?: InputMaybe<Scalars['String']>;
  mime: Scalars['String'];
  size: Scalars['BigFloat'];
  url: Scalars['String'];
  previewUrl?: InputMaybe<Scalars['String']>;
  provider: Scalars['String'];
  providerMetadata?: InputMaybe<Scalars['JSON']>;
  createdBy?: InputMaybe<Scalars['Int']>;
  updatedBy?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloaduserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  username: Scalars['String'];
  firstName: Scalars['String'];
  lastName?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
  interfaceLocale?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
  permissions?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  emails?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  messages?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Vendor` mutation. */
export type CreateVendorPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was created by this mutation. */
  vendor?: Maybe<Vendor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our create `Vendor` mutation. */
export type CreateVendorPayloadvendorEdgeArgs = {
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
};

/** All input for the create `Vendor` mutation. */
export type CreateVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Vendor` to be created by this mutation. */
  vendor: VendorInput;
};

/** An input for mutations affecting `Vendor` */
export type VendorInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  polls?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  reviews?: InputMaybe<Scalars['String']>;
  giftCertificates?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  invoices?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  rewardPoints?: InputMaybe<Scalars['String']>;
  specialDiscounts?: InputMaybe<Scalars['String']>;
  statistics?: InputMaybe<Scalars['String']>;
  stocks?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  physicalStore?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Visit` mutation. */
export type CreateVisitPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Visit` that was created by this mutation. */
  visit?: Maybe<Visit>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Visit`. May be used by Relay 1. */
  visitEdge?: Maybe<VisitsEdge>;
};


/** The output of our create `Visit` mutation. */
export type CreateVisitPayloadvisitEdgeArgs = {
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
};

/** All input for the create `Visit` mutation. */
export type CreateVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Visit` to be created by this mutation. */
  visit: VisitInput;
};

/** An input for mutations affecting `Visit` */
export type VisitInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  location?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  reason?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  emergency?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  meeting?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Warehouse` mutation. */
export type CreateWarehousePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was created by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our create `Warehouse` mutation. */
export type CreateWarehousePayloadwarehouseEdgeArgs = {
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
};

/** All input for the create `Warehouse` mutation. */
export type CreateWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Warehouse` to be created by this mutation. */
  warehouse: WarehouseInput;
};

/** An input for mutations affecting `Warehouse` */
export type WarehouseInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postal?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Webhook` mutation. */
export type CreateWebhookPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Webhook` that was created by this mutation. */
  webhook?: Maybe<Webhook>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Webhook`. May be used by Relay 1. */
  webhookEdge?: Maybe<WebhooksEdge>;
};


/** The output of our create `Webhook` mutation. */
export type CreateWebhookPayloadwebhookEdgeArgs = {
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
};

/** All input for the create `Webhook` mutation. */
export type CreateWebhookInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Webhook` to be created by this mutation. */
  webhook: WebhookInput;
};

/** An input for mutations affecting `Webhook` */
export type WebhookInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name: Scalars['String'];
  url: Scalars['String'];
  headers?: InputMaybe<Scalars['String']>;
  create?: InputMaybe<Scalars['String']>;
  retrieve?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['String']>;
  delete?: InputMaybe<Scalars['String']>;
  publish?: InputMaybe<Scalars['String']>;
  unpublish?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Website` mutation. */
export type CreateWebsitePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Website` that was created by this mutation. */
  website?: Maybe<Website>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Website`. May be used by Relay 1. */
  websiteEdge?: Maybe<WebsitesEdge>;
};


/** The output of our create `Website` mutation. */
export type CreateWebsitePayloadwebsiteEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
};

/** All input for the create `Website` mutation. */
export type CreateWebsiteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Website` to be created by this mutation. */
  website: WebsiteInput;
};

/** An input for mutations affecting `Website` */
export type WebsiteInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  shop?: InputMaybe<Scalars['String']>;
  store?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  themes: Scalars['String'];
};

/** The output of our create `Wishlist` mutation. */
export type CreateWishlistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Wishlist` that was created by this mutation. */
  wishlist?: Maybe<Wishlist>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Wishlist`. May be used by Relay 1. */
  wishlistEdge?: Maybe<WishlistsEdge>;
};


/** The output of our create `Wishlist` mutation. */
export type CreateWishlistPayloadwishlistEdgeArgs = {
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
};

/** All input for the create `Wishlist` mutation. */
export type CreateWishlistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Wishlist` to be created by this mutation. */
  wishlist: WishlistInput;
};

/** An input for mutations affecting `Wishlist` */
export type WishlistInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['String']>;
  occassions?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Workspace` mutation. */
export type CreateWorkspacePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Workspace` that was created by this mutation. */
  workspace?: Maybe<Workspace>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Workspace`. May be used by Relay 1. */
  workspaceEdge?: Maybe<WorkspacesEdge>;
};


/** The output of our create `Workspace` mutation. */
export type CreateWorkspacePayloadworkspaceEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
};

/** All input for the create `Workspace` mutation. */
export type CreateWorkspaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Workspace` to be created by this mutation. */
  workspace: WorkspaceInput;
};

/** An input for mutations affecting `Workspace` */
export type WorkspaceInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['Int']>;
  users?: InputMaybe<Scalars['Int']>;
  products?: InputMaybe<Scalars['BigInt']>;
  tasks?: InputMaybe<Scalars['BigInt']>;
  brands?: InputMaybe<Scalars['BigInt']>;
  shops?: InputMaybe<Scalars['Int']>;
  category?: InputMaybe<Scalars['Int']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  projects?: InputMaybe<Scalars['BigInt']>;
  author?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  brandsBrandsToworkspaces?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  customersCustomersToworkspaces?: InputMaybe<Scalars['String']>;
  productsProductsToworkspaces?: InputMaybe<Scalars['String']>;
  projectsProjectsToworkspaces?: InputMaybe<Scalars['String']>;
  shopsShopsToworkspaces?: InputMaybe<Scalars['String']>;
  tasksTasksToworkspaces?: InputMaybe<Scalars['String']>;
  usersUsersToworkspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Zone` mutation. */
export type CreateZonePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Zone` that was created by this mutation. */
  zone?: Maybe<Zone>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Zone`. May be used by Relay 1. */
  zoneEdge?: Maybe<ZonesEdge>;
};


/** The output of our create `Zone` mutation. */
export type CreateZonePayloadzoneEdgeArgs = {
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
};

/** All input for the create `Zone` mutation. */
export type CreateZoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Zone` to be created by this mutation. */
  zone: ZoneInput;
};

/** An input for mutations affecting `Zone` */
export type ZoneInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  scope?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  code?: InputMaybe<Scalars['String']>;
};

/** The output of our update `Account` mutation. */
export type UpdateAccountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was updated by this mutation. */
  account?: Maybe<Account>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our update `Account` mutation. */
export type UpdateAccountPayloadaccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the `updateAccount` mutation. */
export type UpdateAccountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Account` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Account` being updated. */
  accountPatch: AccountPatch;
};

/** Represents an update to a `Account`. Fields that are set will be updated. */
export type AccountPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  industry?: InputMaybe<Scalars['String']>;
  employees?: InputMaybe<Scalars['String']>;
  annualRevenue?: InputMaybe<Scalars['String']>;
  memberOf?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateAccountById` mutation. */
export type UpdateAccountByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Account` being updated. */
  accountPatch: AccountPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Agreement` mutation. */
export type UpdateAgreementPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agreement` that was updated by this mutation. */
  agreement?: Maybe<Agreement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Agreement`. May be used by Relay 1. */
  agreementEdge?: Maybe<AgreementsEdge>;
};


/** The output of our update `Agreement` mutation. */
export type UpdateAgreementPayloadagreementEdgeArgs = {
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
};

/** All input for the `updateAgreement` mutation. */
export type UpdateAgreementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Agreement` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Agreement` being updated. */
  agreementPatch: AgreementPatch;
};

/** Represents an update to a `Agreement`. Fields that are set will be updated. */
export type AgreementPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  referenceId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  content?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['String']>;
  shopId?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateAgreementById` mutation. */
export type UpdateAgreementByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Agreement` being updated. */
  agreementPatch: AgreementPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Analytic` mutation. */
export type UpdateAnalyticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Analytic` that was updated by this mutation. */
  analytic?: Maybe<Analytic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Analytic`. May be used by Relay 1. */
  analyticEdge?: Maybe<AnalyticsEdge>;
};


/** The output of our update `Analytic` mutation. */
export type UpdateAnalyticPayloadanalyticEdgeArgs = {
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
};

/** All input for the `updateAnalytic` mutation. */
export type UpdateAnalyticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Analytic` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Analytic` being updated. */
  analyticPatch: AnalyticPatch;
};

/** Represents an update to a `Analytic`. Fields that are set will be updated. */
export type AnalyticPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  shareData?: InputMaybe<Scalars['String']>;
  websiteName?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  trackingId?: InputMaybe<Scalars['String']>;
  propertyName?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  defaultView?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  propertyHit?: InputMaybe<Scalars['String']>;
  trackingCode?: InputMaybe<Scalars['String']>;
  dataCollection?: InputMaybe<Scalars['Boolean']>;
  dataRetention?: InputMaybe<Scalars['Boolean']>;
  searchAnalytics?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateAnalyticById` mutation. */
export type UpdateAnalyticByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Analytic` being updated. */
  analyticPatch: AnalyticPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Apitoken` mutation. */
export type UpdateApitokenPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Apitoken` that was updated by this mutation. */
  apitoken?: Maybe<Apitoken>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Apitoken`. May be used by Relay 1. */
  apitokenEdge?: Maybe<ApitokensEdge>;
};


/** The output of our update `Apitoken` mutation. */
export type UpdateApitokenPayloadapitokenEdgeArgs = {
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
};

/** All input for the `updateApitoken` mutation. */
export type UpdateApitokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Apitoken` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Apitoken` being updated. */
  apitokenPatch: ApitokenPatch;
};

/** Represents an update to a `Apitoken`. Fields that are set will be updated. */
export type ApitokenPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  tokenType?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the `updateApitokenById` mutation. */
export type UpdateApitokenByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Apitoken` being updated. */
  apitokenPatch: ApitokenPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Article` mutation. */
export type UpdateArticlePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Article` that was updated by this mutation. */
  article?: Maybe<Article>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Article`. May be used by Relay 1. */
  articleEdge?: Maybe<ArticlesEdge>;
};


/** The output of our update `Article` mutation. */
export type UpdateArticlePayloadarticleEdgeArgs = {
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
};

/** All input for the `updateArticle` mutation. */
export type UpdateArticleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Article` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Article` being updated. */
  articlePatch: ArticlePatch;
};

/** Represents an update to a `Article`. Fields that are set will be updated. */
export type ArticlePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaName?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateArticleById` mutation. */
export type UpdateArticleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Article` being updated. */
  articlePatch: ArticlePatch;
  id: Scalars['Int'];
};

/** The output of our update `Attribute` mutation. */
export type UpdateAttributePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Attribute` that was updated by this mutation. */
  attribute?: Maybe<Attribute>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Attribute`. May be used by Relay 1. */
  attributeEdge?: Maybe<AttributesEdge>;
};


/** The output of our update `Attribute` mutation. */
export type UpdateAttributePayloadattributeEdgeArgs = {
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
};

/** All input for the `updateAttribute` mutation. */
export type UpdateAttributeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Attribute` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Attribute` being updated. */
  attributePatch: AttributePatch;
};

/** Represents an update to a `Attribute`. Fields that are set will be updated. */
export type AttributePatch = {
  id?: InputMaybe<Scalars['Int']>;
  defaultLabel?: InputMaybe<Scalars['String']>;
  attributeCode?: InputMaybe<Scalars['String']>;
  filterOptions?: InputMaybe<Scalars['String']>;
  useSearch?: InputMaybe<Scalars['String']>;
  layeredNavigation?: InputMaybe<Scalars['Boolean']>;
  searchResultsLayeredNavigation?: InputMaybe<Scalars['Boolean']>;
  position?: InputMaybe<Scalars['String']>;
  promoRuleConditions?: InputMaybe<Scalars['Boolean']>;
  allowHtmlTagsStorefront?: InputMaybe<Scalars['Boolean']>;
  visibleCatalogPagesStorefront?: InputMaybe<Scalars['Boolean']>;
  usedProductListing?: InputMaybe<Scalars['Boolean']>;
  usedSortingProductListing?: InputMaybe<Scalars['Boolean']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  attributeClass?: InputMaybe<Scalars['String']>;
  attributeValue?: InputMaybe<Scalars['String']>;
  columnOptions?: InputMaybe<Scalars['String']>;
  facetedNavigation?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaName?: InputMaybe<Scalars['Boolean']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  productAttributeSet?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateAttributeById` mutation. */
export type UpdateAttributeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Attribute` being updated. */
  attributePatch: AttributePatch;
  id: Scalars['Int'];
};

/** The output of our update `Brand` mutation. */
export type UpdateBrandPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Brand` that was updated by this mutation. */
  brand?: Maybe<Brand>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<BrandsEdge>;
};


/** The output of our update `Brand` mutation. */
export type UpdateBrandPayloadbrandEdgeArgs = {
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
};

/** All input for the `updateBrand` mutation. */
export type UpdateBrandInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Brand` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Brand` being updated. */
  brandPatch: BrandPatch;
};

/** Represents an update to a `Brand`. Fields that are set will be updated. */
export type BrandPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateBrandById` mutation. */
export type UpdateBrandByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Brand` being updated. */
  brandPatch: BrandPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CartPriceRule` mutation. */
export type UpdateCartPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CartPriceRule` that was updated by this mutation. */
  cartPriceRule?: Maybe<CartPriceRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CartPriceRule`. May be used by Relay 1. */
  cartPriceRuleEdge?: Maybe<CartPriceRulesEdge>;
};


/** The output of our update `CartPriceRule` mutation. */
export type UpdateCartPriceRulePayloadcartPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
};

/** All input for the `updateCartPriceRule` mutation. */
export type UpdateCartPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CartPriceRule` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CartPriceRule` being updated. */
  cartPriceRulePatch: CartPriceRulePatch;
};

/** Represents an update to a `CartPriceRule`. Fields that are set will be updated. */
export type CartPriceRulePatch = {
  id?: InputMaybe<Scalars['Int']>;
  rule?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  coupon?: InputMaybe<Scalars['String']>;
  usesPerCustomer?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  actionsApply?: InputMaybe<Scalars['String']>;
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
  actionsMaxQtyDiscountIsAppliedTo?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscountQtyStep?: InputMaybe<Scalars['BigFloat']>;
  actionsApplyShippingAmount?: InputMaybe<Scalars['Boolean']>;
};

/** All input for the `updateCartPriceRuleById` mutation. */
export type UpdateCartPriceRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CartPriceRule` being updated. */
  cartPriceRulePatch: CartPriceRulePatch;
  id: Scalars['Int'];
};

/** The output of our update `Case` mutation. */
export type UpdateCasePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Case` that was updated by this mutation. */
  case?: Maybe<Case>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Case`. May be used by Relay 1. */
  caseEdge?: Maybe<CasesEdge>;
};


/** The output of our update `Case` mutation. */
export type UpdateCasePayloadcaseEdgeArgs = {
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
};

/** All input for the `updateCase` mutation. */
export type UpdateCaseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Case` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Case` being updated. */
  casePatch: CasePatch;
};

/** Represents an update to a `Case`. Fields that are set will be updated. */
export type CasePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  caseNumber?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  resolution?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  dateModified?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateCaseById` mutation. */
export type UpdateCaseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Case` being updated. */
  casePatch: CasePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CatalogPriceRule` mutation. */
export type UpdateCatalogPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CatalogPriceRule` that was updated by this mutation. */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CatalogPriceRule`. May be used by Relay 1. */
  catalogPriceRuleEdge?: Maybe<CatalogPriceRulesEdge>;
};


/** The output of our update `CatalogPriceRule` mutation. */
export type UpdateCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
};

/** All input for the `updateCatalogPriceRule` mutation. */
export type UpdateCatalogPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CatalogPriceRule` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CatalogPriceRule` being updated. */
  catalogPriceRulePatch: CatalogPriceRulePatch;
};

/** Represents an update to a `CatalogPriceRule`. Fields that are set will be updated. */
export type CatalogPriceRulePatch = {
  id?: InputMaybe<Scalars['Int']>;
  rule?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  customerGroups?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  actionsApply?: InputMaybe<Scalars['String']>;
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
};

/** All input for the `updateCatalogPriceRuleById` mutation. */
export type UpdateCatalogPriceRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CatalogPriceRule` being updated. */
  catalogPriceRulePatch: CatalogPriceRulePatch;
  id: Scalars['Int'];
};

/** The output of our update `Category` mutation. */
export type UpdateCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Category` that was updated by this mutation. */
  category?: Maybe<Category>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<CategoriesEdge>;
};


/** The output of our update `Category` mutation. */
export type UpdateCategoryPayloadcategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
};

/** All input for the `updateCategory` mutation. */
export type UpdateCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Category` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Category` being updated. */
  categoryPatch: CategoryPatch;
};

/** Represents an update to a `Category`. Fields that are set will be updated. */
export type CategoryPatch = {
  id?: InputMaybe<Scalars['Int']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['Boolean']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCategoryById` mutation. */
export type UpdateCategoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Category` being updated. */
  categoryPatch: CategoryPatch;
  id: Scalars['Int'];
};

/** The output of our update `Channel` mutation. */
export type UpdateChannelPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Channel` that was updated by this mutation. */
  channel?: Maybe<Channel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Channel`. May be used by Relay 1. */
  channelEdge?: Maybe<ChannelsEdge>;
};


/** The output of our update `Channel` mutation. */
export type UpdateChannelPayloadchannelEdgeArgs = {
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
};

/** All input for the `updateChannel` mutation. */
export type UpdateChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Channel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Channel` being updated. */
  channelPatch: ChannelPatch;
};

/** Represents an update to a `Channel`. Fields that are set will be updated. */
export type ChannelPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  defaultLang?: InputMaybe<Scalars['String']>;
  includeTax?: InputMaybe<Scalars['String']>;
  defaultZone?: InputMaybe<Scalars['String']>;
  defaultShipping?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateChannelById` mutation. */
export type UpdateChannelByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Channel` being updated. */
  channelPatch: ChannelPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Checklist` mutation. */
export type UpdateChecklistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Checklist` that was updated by this mutation. */
  checklist?: Maybe<Checklist>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Checklist`. May be used by Relay 1. */
  checklistEdge?: Maybe<ChecklistsEdge>;
};


/** The output of our update `Checklist` mutation. */
export type UpdateChecklistPayloadchecklistEdgeArgs = {
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
};

/** All input for the `updateChecklist` mutation. */
export type UpdateChecklistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Checklist` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Checklist` being updated. */
  checklistPatch: ChecklistPatch;
};

/** Represents an update to a `Checklist`. Fields that are set will be updated. */
export type ChecklistPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  username?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  regionalManager?: InputMaybe<Scalars['String']>;
  manager?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  ticket?: InputMaybe<Scalars['String']>;
  project?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateChecklistById` mutation. */
export type UpdateChecklistByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Checklist` being updated. */
  checklistPatch: ChecklistPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `City` mutation. */
export type UpdateCityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `City` that was updated by this mutation. */
  city?: Maybe<City>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `City`. May be used by Relay 1. */
  cityEdge?: Maybe<CitiesEdge>;
};


/** The output of our update `City` mutation. */
export type UpdateCityPayloadcityEdgeArgs = {
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
};

/** All input for the `updateCity` mutation. */
export type UpdateCityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `City` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `City` being updated. */
  cityPatch: CityPatch;
};

/** Represents an update to a `City`. Fields that are set will be updated. */
export type CityPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postalCode?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCityById` mutation. */
export type UpdateCityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `City` being updated. */
  cityPatch: CityPatch;
  id: Scalars['Int'];
};

/** The output of our update `Collection` mutation. */
export type UpdateCollectionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Collection` that was updated by this mutation. */
  collection?: Maybe<Collection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Collection`. May be used by Relay 1. */
  collectionEdge?: Maybe<CollectionsEdge>;
};


/** The output of our update `Collection` mutation. */
export type UpdateCollectionPayloadcollectionEdgeArgs = {
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
};

/** All input for the `updateCollection` mutation. */
export type UpdateCollectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Collection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Collection` being updated. */
  collectionPatch: CollectionPatch;
};

/** Represents an update to a `Collection`. Fields that are set will be updated. */
export type CollectionPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCollectionById` mutation. */
export type UpdateCollectionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Collection` being updated. */
  collectionPatch: CollectionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Comment` mutation. */
export type UpdateCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Comment` that was updated by this mutation. */
  comment?: Maybe<Comment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  commentEdge?: Maybe<CommentsEdge>;
};


/** The output of our update `Comment` mutation. */
export type UpdateCommentPayloadcommentEdgeArgs = {
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
};

/** All input for the `updateComment` mutation. */
export type UpdateCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Comment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Comment` being updated. */
  commentPatch: CommentPatch;
};

/** Represents an update to a `Comment`. Fields that are set will be updated. */
export type CommentPatch = {
  id?: InputMaybe<Scalars['Int']>;
  customerName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  response?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  custId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCommentById` mutation. */
export type UpdateCommentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Comment` being updated. */
  commentPatch: CommentPatch;
  id: Scalars['Int'];
};

/** The output of our update `ContentType` mutation. */
export type UpdateContentTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContentType` that was updated by this mutation. */
  contentType?: Maybe<ContentType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ContentType`. May be used by Relay 1. */
  contentTypeEdge?: Maybe<ContentTypesEdge>;
};


/** The output of our update `ContentType` mutation. */
export type UpdateContentTypePayloadcontentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
};

/** All input for the `updateContentType` mutation. */
export type UpdateContentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContentType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ContentType` being updated. */
  contentTypePatch: ContentTypePatch;
};

/** Represents an update to a `ContentType`. Fields that are set will be updated. */
export type ContentTypePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  text?: InputMaybe<Scalars['String']>;
  number?: InputMaybe<Scalars['BigFloat']>;
  json?: InputMaybe<Scalars['JSON']>;
  link?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  uid?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['Date']>;
  time?: InputMaybe<Scalars['Time']>;
  timestamp?: InputMaybe<Scalars['Datetime']>;
  boolean?: InputMaybe<Scalars['Boolean']>;
  richText?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  databaseName?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateContentTypeById` mutation. */
export type UpdateContentTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ContentType` being updated. */
  contentTypePatch: ContentTypePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Contract` mutation. */
export type UpdateContractPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Contract` that was updated by this mutation. */
  contract?: Maybe<Contract>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Contract`. May be used by Relay 1. */
  contractEdge?: Maybe<ContractsEdge>;
};


/** The output of our update `Contract` mutation. */
export type UpdateContractPayloadcontractEdgeArgs = {
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
};

/** All input for the `updateContract` mutation. */
export type UpdateContractInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Contract` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Contract` being updated. */
  contractPatch: ContractPatch;
};

/** Represents an update to a `Contract`. Fields that are set will be updated. */
export type ContractPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  contractTitle?: InputMaybe<Scalars['String']>;
  contractValue?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  renewalReminder?: InputMaybe<Scalars['String']>;
  customerSignedDate?: InputMaybe<Scalars['String']>;
  companySignedDate?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  contractManager?: InputMaybe<Scalars['String']>;
  account?: InputMaybe<Scalars['String']>;
  contact?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  opportunity?: InputMaybe<Scalars['String']>;
  contractType?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  lineItems?: InputMaybe<Scalars['String']>;
  total?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  shipping?: InputMaybe<Scalars['String']>;
  shippingTax?: InputMaybe<Scalars['String']>;
  tax?: InputMaybe<Scalars['String']>;
  grandTotal?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateContractById` mutation. */
export type UpdateContractByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Contract` being updated. */
  contractPatch: ContractPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Country` mutation. */
export type UpdateCountryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was updated by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our update `Country` mutation. */
export type UpdateCountryPayloadcountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the `updateCountry` mutation. */
export type UpdateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Country` being updated. */
  countryPatch: CountryPatch;
};

/** Represents an update to a `Country`. Fields that are set will be updated. */
export type CountryPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCountryById` mutation. */
export type UpdateCountryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Country` being updated. */
  countryPatch: CountryPatch;
  id: Scalars['Int'];
};

/** The output of our update `Coupon` mutation. */
export type UpdateCouponPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Coupon` that was updated by this mutation. */
  coupon?: Maybe<Coupon>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Coupon`. May be used by Relay 1. */
  couponEdge?: Maybe<CouponsEdge>;
};


/** The output of our update `Coupon` mutation. */
export type UpdateCouponPayloadcouponEdgeArgs = {
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
};

/** All input for the `updateCoupon` mutation. */
export type UpdateCouponInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Coupon` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Coupon` being updated. */
  couponPatch: CouponPatch;
};

/** Represents an update to a `Coupon`. Fields that are set will be updated. */
export type CouponPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  productsCouponsToproducts?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCouponById` mutation. */
export type UpdateCouponByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Coupon` being updated. */
  couponPatch: CouponPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CreditMemo` mutation. */
export type UpdateCreditMemoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CreditMemo` that was updated by this mutation. */
  creditMemo?: Maybe<CreditMemo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CreditMemo`. May be used by Relay 1. */
  creditMemoEdge?: Maybe<CreditMemosEdge>;
};


/** The output of our update `CreditMemo` mutation. */
export type UpdateCreditMemoPayloadcreditMemoEdgeArgs = {
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
};

/** All input for the `updateCreditMemo` mutation. */
export type UpdateCreditMemoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CreditMemo` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CreditMemo` being updated. */
  creditMemoPatch: CreditMemoPatch;
};

/** Represents an update to a `CreditMemo`. Fields that are set will be updated. */
export type CreditMemoPatch = {
  creditMemo?: InputMaybe<Scalars['String']>;
  orderNumber?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['Datetime']>;
  billToName?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  refunded?: InputMaybe<Scalars['String']>;
  action?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  custId?: InputMaybe<Scalars['Int']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCreditMemoByCreditMemoAndId` mutation. */
export type UpdateCreditMemoByCreditMemoAndIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CreditMemo` being updated. */
  creditMemoPatch: CreditMemoPatch;
  creditMemo: Scalars['String'];
  id: Scalars['BigInt'];
};

/** The output of our update `Currency` mutation. */
export type UpdateCurrencyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Currency` that was updated by this mutation. */
  currency?: Maybe<Currency>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Currency`. May be used by Relay 1. */
  currencyEdge?: Maybe<CurrenciesEdge>;
};


/** The output of our update `Currency` mutation. */
export type UpdateCurrencyPayloadcurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
};

/** All input for the `updateCurrency` mutation. */
export type UpdateCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Currency` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Currency` being updated. */
  currencyPatch: CurrencyPatch;
};

/** Represents an update to a `Currency`. Fields that are set will be updated. */
export type CurrencyPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCurrencyById` mutation. */
export type UpdateCurrencyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Currency` being updated. */
  currencyPatch: CurrencyPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CurrencyRate` mutation. */
export type UpdateCurrencyRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencyRate` that was updated by this mutation. */
  currencyRate?: Maybe<CurrencyRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencyRate`. May be used by Relay 1. */
  currencyRateEdge?: Maybe<CurrencyRatesEdge>;
};


/** The output of our update `CurrencyRate` mutation. */
export type UpdateCurrencyRatePayloadcurrencyRateEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
};

/** All input for the `updateCurrencyRate` mutation. */
export type UpdateCurrencyRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CurrencyRate` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CurrencyRate` being updated. */
  currencyRatePatch: CurrencyRatePatch;
};

/** Represents an update to a `CurrencyRate`. Fields that are set will be updated. */
export type CurrencyRatePatch = {
  importService?: InputMaybe<Scalars['String']>;
  usd?: InputMaybe<Scalars['BigFloat']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the `updateCurrencyRateByImportService` mutation. */
export type UpdateCurrencyRateByImportServiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CurrencyRate` being updated. */
  currencyRatePatch: CurrencyRatePatch;
  importService: Scalars['String'];
};

/** The output of our update `CurrencySymbol` mutation. */
export type UpdateCurrencySymbolPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencySymbol` that was updated by this mutation. */
  currencySymbol?: Maybe<CurrencySymbol>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencySymbol`. May be used by Relay 1. */
  currencySymbolEdge?: Maybe<CurrencySymbolsEdge>;
};


/** The output of our update `CurrencySymbol` mutation. */
export type UpdateCurrencySymbolPayloadcurrencySymbolEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
};

/** All input for the `updateCurrencySymbol` mutation. */
export type UpdateCurrencySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CurrencySymbol` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CurrencySymbol` being updated. */
  currencySymbolPatch: CurrencySymbolPatch;
};

/** Represents an update to a `CurrencySymbol`. Fields that are set will be updated. */
export type CurrencySymbolPatch = {
  symbol?: InputMaybe<Scalars['String']>;
  useStandard?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the `updateCurrencySymbolBySymbol` mutation. */
export type UpdateCurrencySymbolBySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CurrencySymbol` being updated. */
  currencySymbolPatch: CurrencySymbolPatch;
  symbol: Scalars['String'];
};

/** The output of our update `CustomerGroup` mutation. */
export type UpdateCustomerGroupPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerGroup` that was updated by this mutation. */
  customerGroup?: Maybe<CustomerGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerGroup`. May be used by Relay 1. */
  customerGroupEdge?: Maybe<CustomerGroupsEdge>;
};


/** The output of our update `CustomerGroup` mutation. */
export type UpdateCustomerGroupPayloadcustomerGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
};

/** All input for the `updateCustomerGroup` mutation. */
export type UpdateCustomerGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerGroup` being updated. */
  customerGroupPatch: CustomerGroupPatch;
};

/** Represents an update to a `CustomerGroup`. Fields that are set will be updated. */
export type CustomerGroupPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  taxClass?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  coverPhoto?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCustomerGroupById` mutation. */
export type UpdateCustomerGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerGroup` being updated. */
  customerGroupPatch: CustomerGroupPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was updated by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayloadcustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the `updateCustomer` mutation. */
export type UpdateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Customer` being updated. */
  customerPatch: CustomerPatch;
};

/** Represents an update to a `Customer`. Fields that are set will be updated. */
export type CustomerPatch = {
  id?: InputMaybe<Scalars['Int']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  namePrefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  middleName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  customerGroup?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  nameSuffix?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  customerSince?: InputMaybe<Scalars['Datetime']>;
  confirmedEmail?: InputMaybe<Scalars['String']>;
  dateOfBirth?: InputMaybe<Scalars['String']>;
  taxVatNumber?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  shortDescription?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  paymentType?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  creditMemos?: InputMaybe<Scalars['String']>;
  customerPayment?: InputMaybe<Scalars['String']>;
  emails?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  messages?: InputMaybe<Scalars['String']>;
  newsletterSubscribers?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  returns?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCustomerById` mutation. */
export type UpdateCustomerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Customer` being updated. */
  customerPatch: CustomerPatch;
  id: Scalars['Int'];
};

/** The output of our update `Customization` mutation. */
export type UpdateCustomizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customization` that was updated by this mutation. */
  customization?: Maybe<Customization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customization`. May be used by Relay 1. */
  customizationEdge?: Maybe<CustomizationsEdge>;
};


/** The output of our update `Customization` mutation. */
export type UpdateCustomizationPayloadcustomizationEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
};

/** All input for the `updateCustomization` mutation. */
export type UpdateCustomizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customization` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Customization` being updated. */
  customizationPatch: CustomizationPatch;
};

/** Represents an update to a `Customization`. Fields that are set will be updated. */
export type CustomizationPatch = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  siteName?: InputMaybe<Scalars['String']>;
  navLink?: InputMaybe<Scalars['String']>;
  notification?: InputMaybe<Scalars['String']>;
  banner?: InputMaybe<Scalars['String']>;
  footerLink?: InputMaybe<Scalars['String']>;
  announcement?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  siteUrl?: InputMaybe<Scalars['String']>;
  allowSignup?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCustomizationById` mutation. */
export type UpdateCustomizationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Customization` being updated. */
  customizationPatch: CustomizationPatch;
  id: Scalars['Int'];
};

/** The output of our update `Dashboard` mutation. */
export type UpdateDashboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Dashboard` that was updated by this mutation. */
  dashboard?: Maybe<Dashboard>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Dashboard`. May be used by Relay 1. */
  dashboardEdge?: Maybe<DashboardsEdge>;
};


/** The output of our update `Dashboard` mutation. */
export type UpdateDashboardPayloaddashboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
};

/** All input for the `updateDashboard` mutation. */
export type UpdateDashboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dashboard` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Dashboard` being updated. */
  dashboardPatch: DashboardPatch;
};

/** Represents an update to a `Dashboard`. Fields that are set will be updated. */
export type DashboardPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  privacy?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  checklists?: InputMaybe<Scalars['String']>;
  visits?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  sales?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateDashboardById` mutation. */
export type UpdateDashboardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Dashboard` being updated. */
  dashboardPatch: DashboardPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Deepdive` mutation. */
export type UpdateDeepdivePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Deepdive` that was updated by this mutation. */
  deepdive?: Maybe<Deepdive>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Deepdive`. May be used by Relay 1. */
  deepdiveEdge?: Maybe<DeepdivesEdge>;
};


/** The output of our update `Deepdive` mutation. */
export type UpdateDeepdivePayloaddeepdiveEdgeArgs = {
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
};

/** All input for the `updateDeepdive` mutation. */
export type UpdateDeepdiveInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Deepdive` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Deepdive` being updated. */
  deepdivePatch: DeepdivePatch;
};

/** Represents an update to a `Deepdive`. Fields that are set will be updated. */
export type DeepdivePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  endDate?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  attendees?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateDeepdiveById` mutation. */
export type UpdateDeepdiveByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Deepdive` being updated. */
  deepdivePatch: DeepdivePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Digiboard` mutation. */
export type UpdateDigiboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Digiboard` that was updated by this mutation. */
  digiboard?: Maybe<Digiboard>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Digiboard`. May be used by Relay 1. */
  digiboardEdge?: Maybe<DigiboardsEdge>;
};


/** The output of our update `Digiboard` mutation. */
export type UpdateDigiboardPayloaddigiboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
};

/** All input for the `updateDigiboard` mutation. */
export type UpdateDigiboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Digiboard` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Digiboard` being updated. */
  digiboardPatch: DigiboardPatch;
};

/** Represents an update to a `Digiboard`. Fields that are set will be updated. */
export type DigiboardPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  board?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  student?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateDigiboardById` mutation. */
export type UpdateDigiboardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Digiboard` being updated. */
  digiboardPatch: DigiboardPatch;
  id: Scalars['Int'];
};

/** The output of our update `Email` mutation. */
export type UpdateEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was updated by this mutation. */
  email?: Maybe<Email>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our update `Email` mutation. */
export type UpdateEmailPayloademailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the `updateEmail` mutation. */
export type UpdateEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Email` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Email` being updated. */
  emailPatch: EmailPatch;
};

/** Represents an update to a `Email`. Fields that are set will be updated. */
export type EmailPatch = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  bcc?: InputMaybe<Scalars['String']>;
  cc?: InputMaybe<Scalars['String']>;
  from?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateEmailById` mutation. */
export type UpdateEmailByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Email` being updated. */
  emailPatch: EmailPatch;
  id: Scalars['Int'];
};

/** The output of our update `Endofshift` mutation. */
export type UpdateEndofshiftPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Endofshift` that was updated by this mutation. */
  endofshift?: Maybe<Endofshift>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Endofshift`. May be used by Relay 1. */
  endofshiftEdge?: Maybe<EndofshiftsEdge>;
};


/** The output of our update `Endofshift` mutation. */
export type UpdateEndofshiftPayloadendofshiftEdgeArgs = {
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
};

/** All input for the `updateEndofshift` mutation. */
export type UpdateEndofshiftInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Endofshift` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Endofshift` being updated. */
  endofshiftPatch: EndofshiftPatch;
};

/** Represents an update to a `Endofshift`. Fields that are set will be updated. */
export type EndofshiftPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  content?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  mcms?: InputMaybe<Scalars['String']>;
  nextShift?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateEndofshiftById` mutation. */
export type UpdateEndofshiftByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Endofshift` being updated. */
  endofshiftPatch: EndofshiftPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` that was updated by this mutation. */
  event?: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadeventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Event` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  eventPatch: EventPatch;
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  start?: InputMaybe<Scalars['String']>;
  end?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateEventById` mutation. */
export type UpdateEventByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Event` being updated. */
  eventPatch: EventPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Fullfillment` mutation. */
export type UpdateFullfillmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Fullfillment` that was updated by this mutation. */
  fullfillment?: Maybe<Fullfillment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Fullfillment`. May be used by Relay 1. */
  fullfillmentEdge?: Maybe<FullfillmentsEdge>;
};


/** The output of our update `Fullfillment` mutation. */
export type UpdateFullfillmentPayloadfullfillmentEdgeArgs = {
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
};

/** All input for the `updateFullfillment` mutation. */
export type UpdateFullfillmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Fullfillment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Fullfillment` being updated. */
  fullfillmentPatch: FullfillmentPatch;
};

/** Represents an update to a `Fullfillment`. Fields that are set will be updated. */
export type FullfillmentPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  shippingZones?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  countryArea?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  pickup?: InputMaybe<Scalars['String']>;
  stock?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateFullfillmentById` mutation. */
export type UpdateFullfillmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Fullfillment` being updated. */
  fullfillmentPatch: FullfillmentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `GiftCertificate` mutation. */
export type UpdateGiftCertificatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GiftCertificate` that was updated by this mutation. */
  giftCertificate?: Maybe<GiftCertificate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `GiftCertificate`. May be used by Relay 1. */
  giftCertificateEdge?: Maybe<GiftCertificatesEdge>;
};


/** The output of our update `GiftCertificate` mutation. */
export type UpdateGiftCertificatePayloadgiftCertificateEdgeArgs = {
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
};

/** All input for the `updateGiftCertificate` mutation. */
export type UpdateGiftCertificateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GiftCertificate` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GiftCertificate` being updated. */
  giftCertificatePatch: GiftCertificatePatch;
};

/** Represents an update to a `GiftCertificate`. Fields that are set will be updated. */
export type GiftCertificatePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  specialOffers?: InputMaybe<Scalars['String']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateGiftCertificateById` mutation. */
export type UpdateGiftCertificateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GiftCertificate` being updated. */
  giftCertificatePatch: GiftCertificatePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Glossary` mutation. */
export type UpdateGlossaryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Glossary` that was updated by this mutation. */
  glossary?: Maybe<Glossary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Glossary`. May be used by Relay 1. */
  glossaryEdge?: Maybe<GlossariesEdge>;
};


/** The output of our update `Glossary` mutation. */
export type UpdateGlossaryPayloadglossaryEdgeArgs = {
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
};

/** All input for the `updateGlossary` mutation. */
export type UpdateGlossaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Glossary` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Glossary` being updated. */
  glossaryPatch: GlossaryPatch;
};

/** Represents an update to a `Glossary`. Fields that are set will be updated. */
export type GlossaryPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateGlossaryById` mutation. */
export type UpdateGlossaryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Glossary` being updated. */
  glossaryPatch: GlossaryPatch;
  id: Scalars['Int'];
};

/** The output of our update `Importm` mutation. */
export type UpdateImportmPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Importm` that was updated by this mutation. */
  importm?: Maybe<Importm>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Importm`. May be used by Relay 1. */
  importmEdge?: Maybe<ImportmsEdge>;
};


/** The output of our update `Importm` mutation. */
export type UpdateImportmPayloadimportmEdgeArgs = {
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
};

/** All input for the `updateImportm` mutation. */
export type UpdateImportmInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Importm` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Importm` being updated. */
  importmPatch: ImportmPatch;
};

/** Represents an update to a `Importm`. Fields that are set will be updated. */
export type ImportmPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateImportmById` mutation. */
export type UpdateImportmByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Importm` being updated. */
  importmPatch: ImportmPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Integration` mutation. */
export type UpdateIntegrationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Integration` that was updated by this mutation. */
  integration?: Maybe<Integration>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Integration`. May be used by Relay 1. */
  integrationEdge?: Maybe<IntegrationsEdge>;
};


/** The output of our update `Integration` mutation. */
export type UpdateIntegrationPayloadintegrationEdgeArgs = {
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
};

/** All input for the `updateIntegration` mutation. */
export type UpdateIntegrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Integration` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Integration` being updated. */
  integrationPatch: IntegrationPatch;
};

/** Represents an update to a `Integration`. Fields that are set will be updated. */
export type IntegrationPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateIntegrationById` mutation. */
export type UpdateIntegrationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Integration` being updated. */
  integrationPatch: IntegrationPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Internalization` mutation. */
export type UpdateInternalizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Internalization` that was updated by this mutation. */
  internalization?: Maybe<Internalization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Internalization`. May be used by Relay 1. */
  internalizationEdge?: Maybe<InternalizationsEdge>;
};


/** The output of our update `Internalization` mutation. */
export type UpdateInternalizationPayloadinternalizationEdgeArgs = {
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
};

/** All input for the `updateInternalization` mutation. */
export type UpdateInternalizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Internalization` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Internalization` being updated. */
  internalizationPatch: InternalizationPatch;
};

/** Represents an update to a `Internalization`. Fields that are set will be updated. */
export type InternalizationPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateInternalizationById` mutation. */
export type UpdateInternalizationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Internalization` being updated. */
  internalizationPatch: InternalizationPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Invitation` mutation. */
export type UpdateInvitationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invitation` that was updated by this mutation. */
  invitation?: Maybe<Invitation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invitation`. May be used by Relay 1. */
  invitationEdge?: Maybe<InvitationsEdge>;
};


/** The output of our update `Invitation` mutation. */
export type UpdateInvitationPayloadinvitationEdgeArgs = {
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
};

/** All input for the `updateInvitation` mutation. */
export type UpdateInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invitation` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Invitation` being updated. */
  invitationPatch: InvitationPatch;
};

/** Represents an update to a `Invitation`. Fields that are set will be updated. */
export type InvitationPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  email?: InputMaybe<Scalars['String']>;
  billingAddress?: InputMaybe<Scalars['String']>;
  shippingAddress?: InputMaybe<Scalars['String']>;
  orderNumber?: InputMaybe<Scalars['String']>;
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateInvitationById` mutation. */
export type UpdateInvitationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Invitation` being updated. */
  invitationPatch: InvitationPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was updated by this mutation. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayloadinvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the `updateInvoice` mutation. */
export type UpdateInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invoice` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  invoicePatch: InvoicePatch;
};

/** Represents an update to a `Invoice`. Fields that are set will be updated. */
export type InvoicePatch = {
  invoice?: InputMaybe<Scalars['Int']>;
  orderNumber?: InputMaybe<Scalars['BigInt']>;
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  billToName?: InputMaybe<Scalars['String']>;
  billingAddress?: InputMaybe<Scalars['String']>;
  grandTotalBase?: InputMaybe<Scalars['String']>;
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  shippingAddress?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  customerGroup?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  shippingInformation?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  shippingAndHandling?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the `updateInvoiceById` mutation. */
export type UpdateInvoiceByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  invoicePatch: InvoicePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Lead` mutation. */
export type UpdateLeadPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lead` that was updated by this mutation. */
  lead?: Maybe<Lead>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
};


/** The output of our update `Lead` mutation. */
export type UpdateLeadPayloadleadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the `updateLead` mutation. */
export type UpdateLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lead` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Lead` being updated. */
  leadPatch: LeadPatch;
};

/** Represents an update to a `Lead`. Fields that are set will be updated. */
export type LeadPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  prefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  mobile?: InputMaybe<Scalars['String']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  statusDescription?: InputMaybe<Scalars['String']>;
  opportunityAmount?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
  leadSource?: InputMaybe<Scalars['String']>;
  leadSourceDescription?: InputMaybe<Scalars['String']>;
  referredBy?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateLeadById` mutation. */
export type UpdateLeadByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Lead` being updated. */
  leadPatch: LeadPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Manufacturer` mutation. */
export type UpdateManufacturerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Manufacturer` that was updated by this mutation. */
  manufacturer?: Maybe<Manufacturer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Manufacturer`. May be used by Relay 1. */
  manufacturerEdge?: Maybe<ManufacturersEdge>;
};


/** The output of our update `Manufacturer` mutation. */
export type UpdateManufacturerPayloadmanufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
};

/** All input for the `updateManufacturer` mutation. */
export type UpdateManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Manufacturer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Manufacturer` being updated. */
  manufacturerPatch: ManufacturerPatch;
};

/** Represents an update to a `Manufacturer`. Fields that are set will be updated. */
export type ManufacturerPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateManufacturerById` mutation. */
export type UpdateManufacturerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Manufacturer` being updated. */
  manufacturerPatch: ManufacturerPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Mediamanager` mutation. */
export type UpdateMediamanagerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Mediamanager` that was updated by this mutation. */
  mediamanager?: Maybe<Mediamanager>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Mediamanager`. May be used by Relay 1. */
  mediamanagerEdge?: Maybe<MediamanagersEdge>;
};


/** The output of our update `Mediamanager` mutation. */
export type UpdateMediamanagerPayloadmediamanagerEdgeArgs = {
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
};

/** All input for the `updateMediamanager` mutation. */
export type UpdateMediamanagerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Mediamanager` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Mediamanager` being updated. */
  mediamanagerPatch: MediamanagerPatch;
};

/** Represents an update to a `Mediamanager`. Fields that are set will be updated. */
export type MediamanagerPatch = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  keywords?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  brands?: InputMaybe<Scalars['BigInt']>;
  status?: InputMaybe<Scalars['String']>;
  expirationDate?: InputMaybe<Scalars['String']>;
  copyright?: InputMaybe<Scalars['String']>;
  dimensions?: InputMaybe<Scalars['String']>;
  author?: InputMaybe<Scalars['Int']>;
  contentType?: InputMaybe<Scalars['String']>;
  versions?: InputMaybe<Scalars['String']>;
  watermarkName?: InputMaybe<Scalars['String']>;
  watermarkDescription?: InputMaybe<Scalars['String']>;
  watermarkMedia?: InputMaybe<Scalars['String']>;
  agreements?: InputMaybe<Scalars['Int']>;
  albums?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['Int']>;
  workspace?: InputMaybe<Scalars['String']>;
  taskName?: InputMaybe<Scalars['BigInt']>;
  taskDescription?: InputMaybe<Scalars['String']>;
  taskType?: InputMaybe<Scalars['String']>;
  members?: InputMaybe<Scalars['Int']>;
  products?: InputMaybe<Scalars['BigInt']>;
  agreementsAgreementsTomediamanager?: InputMaybe<Scalars['String']>;
  brandsBrandsTomediamanager?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  productsMediamanagerToproducts?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateMediamanagerById` mutation. */
export type UpdateMediamanagerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Mediamanager` being updated. */
  mediamanagerPatch: MediamanagerPatch;
  id: Scalars['Int'];
};

/** The output of our update `Meeting` mutation. */
export type UpdateMeetingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Meeting` that was updated by this mutation. */
  meeting?: Maybe<Meeting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Meeting`. May be used by Relay 1. */
  meetingEdge?: Maybe<MeetingsEdge>;
};


/** The output of our update `Meeting` mutation. */
export type UpdateMeetingPayloadmeetingEdgeArgs = {
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
};

/** All input for the `updateMeeting` mutation. */
export type UpdateMeetingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Meeting` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Meeting` being updated. */
  meetingPatch: MeetingPatch;
};

/** Represents an update to a `Meeting`. Fields that are set will be updated. */
export type MeetingPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  duration?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  relatedTo?: InputMaybe<Scalars['String']>;
  reminders?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  invitees?: InputMaybe<Scalars['String']>;
  scheduling?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateMeetingById` mutation. */
export type UpdateMeetingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Meeting` being updated. */
  meetingPatch: MeetingPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Message` mutation. */
export type UpdateMessagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was updated by this mutation. */
  message?: Maybe<Message>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
};


/** The output of our update `Message` mutation. */
export type UpdateMessagePayloadmessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the `updateMessage` mutation. */
export type UpdateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Message` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Message` being updated. */
  messagePatch: MessagePatch;
};

/** Represents an update to a `Message`. Fields that are set will be updated. */
export type MessagePatch = {
  id?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  media?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateMessageById` mutation. */
export type UpdateMessageByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Message` being updated. */
  messagePatch: MessagePatch;
  id: Scalars['Int'];
};

/** The output of our update `Newsletter` mutation. */
export type UpdateNewsletterPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Newsletter` that was updated by this mutation. */
  newsletter?: Maybe<Newsletter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Newsletter`. May be used by Relay 1. */
  newsletterEdge?: Maybe<NewslettersEdge>;
};


/** The output of our update `Newsletter` mutation. */
export type UpdateNewsletterPayloadnewsletterEdgeArgs = {
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
};

/** All input for the `updateNewsletter` mutation. */
export type UpdateNewsletterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Newsletter` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Newsletter` being updated. */
  newsletterPatch: NewsletterPatch;
};

/** Represents an update to a `Newsletter`. Fields that are set will be updated. */
export type NewsletterPatch = {
  id?: InputMaybe<Scalars['Int']>;
  email?: InputMaybe<Scalars['String']>;
  customerFirstName?: InputMaybe<Scalars['String']>;
  customerLastName?: InputMaybe<Scalars['String']>;
  store?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  custId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateNewsletterById` mutation. */
export type UpdateNewsletterByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Newsletter` being updated. */
  newsletterPatch: NewsletterPatch;
  id: Scalars['Int'];
};

/** The output of our update `Ooto` mutation. */
export type UpdateOotoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ooto` that was updated by this mutation. */
  ooto?: Maybe<Ooto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ooto`. May be used by Relay 1. */
  ootoEdge?: Maybe<OotosEdge>;
};


/** The output of our update `Ooto` mutation. */
export type UpdateOotoPayloadootoEdgeArgs = {
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
};

/** All input for the `updateOoto` mutation. */
export type UpdateOotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Ooto` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Ooto` being updated. */
  ootoPatch: OotoPatch;
};

/** Represents an update to a `Ooto`. Fields that are set will be updated. */
export type OotoPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  login?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  note?: InputMaybe<Scalars['String']>;
  usingTime?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateOotoById` mutation. */
export type UpdateOotoByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Ooto` being updated. */
  ootoPatch: OotoPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Opportunity` mutation. */
export type UpdateOpportunityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Opportunity` that was updated by this mutation. */
  opportunity?: Maybe<Opportunity>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
};


/** The output of our update `Opportunity` mutation. */
export type UpdateOpportunityPayloadopportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the `updateOpportunity` mutation. */
export type UpdateOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Opportunity` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Opportunity` being updated. */
  opportunityPatch: OpportunityPatch;
};

/** Represents an update to a `Opportunity`. Fields that are set will be updated. */
export type OpportunityPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  amount?: InputMaybe<Scalars['String']>;
  salesStage?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  probability?: InputMaybe<Scalars['String']>;
  nextStep?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  leadSource?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  expectedCloseDate?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateOpportunityById` mutation. */
export type UpdateOpportunityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Opportunity` being updated. */
  opportunityPatch: OpportunityPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Order` mutation. */
export type UpdateOrderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Order` that was updated by this mutation. */
  order?: Maybe<Order>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Order`. May be used by Relay 1. */
  orderEdge?: Maybe<OrdersEdge>;
};


/** The output of our update `Order` mutation. */
export type UpdateOrderPayloadorderEdgeArgs = {
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
};

/** All input for the `updateOrder` mutation. */
export type UpdateOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Order` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Order` being updated. */
  orderPatch: OrderPatch;
};

/** Represents an update to a `Order`. Fields that are set will be updated. */
export type OrderPatch = {
  id?: InputMaybe<Scalars['Int']>;
  purchasePoint?: InputMaybe<Scalars['Int']>;
  purchaseDate?: InputMaybe<Scalars['Datetime']>;
  billToName?: InputMaybe<Scalars['String']>;
  shipToName?: InputMaybe<Scalars['String']>;
  grandTotalBase?: InputMaybe<Scalars['Int']>;
  grandTotalPurchased?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<Scalars['Boolean']>;
  action?: InputMaybe<Scalars['Boolean']>;
  allocatedSources?: InputMaybe<Scalars['String']>;
  braintreeTransactionSource?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  transactions?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateOrderById` mutation. */
export type UpdateOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Order` being updated. */
  orderPatch: OrderPatch;
  id: Scalars['Int'];
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` that was updated by this mutation. */
  page?: Maybe<Page>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge?: Maybe<PagesEdge>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadpageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Page` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  pagePatch: PagePatch;
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  id?: InputMaybe<Scalars['Int']>;
  enablePage?: InputMaybe<Scalars['Boolean']>;
  title?: InputMaybe<Scalars['String']>;
  contentTitle?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  urlKey?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePageById` mutation. */
export type UpdatePageByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Page` being updated. */
  pagePatch: PagePatch;
  id: Scalars['Int'];
};

/** The output of our update `Partner` mutation. */
export type UpdatePartnerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Partner` that was updated by this mutation. */
  partner?: Maybe<Partner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Partner`. May be used by Relay 1. */
  partnerEdge?: Maybe<PartnersEdge>;
};


/** The output of our update `Partner` mutation. */
export type UpdatePartnerPayloadpartnerEdgeArgs = {
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
};

/** All input for the `updatePartner` mutation. */
export type UpdatePartnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Partner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Partner` being updated. */
  partnerPatch: PartnerPatch;
};

/** Represents an update to a `Partner`. Fields that are set will be updated. */
export type PartnerPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  businessType?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePartnerById` mutation. */
export type UpdatePartnerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Partner` being updated. */
  partnerPatch: PartnerPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Payment` mutation. */
export type UpdatePaymentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was updated by this mutation. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our update `Payment` mutation. */
export type UpdatePaymentPayloadpaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the `updatePayment` mutation. */
export type UpdatePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Payment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Payment` being updated. */
  paymentPatch: PaymentPatch;
};

/** Represents an update to a `Payment`. Fields that are set will be updated. */
export type PaymentPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  hostUri?: InputMaybe<Scalars['String']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePaymentById` mutation. */
export type UpdatePaymentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Payment` being updated. */
  paymentPatch: PaymentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Permission` that was updated by this mutation. */
  permission?: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
};


/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayloadpermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `updatePermission` mutation. */
export type UpdatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Permission` being updated. */
  permissionPatch: PermissionPatch;
};

/** Represents an update to a `Permission`. Fields that are set will be updated. */
export type PermissionPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  create?: InputMaybe<Scalars['String']>;
  delete?: InputMaybe<Scalars['String']>;
  read?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePermissionById` mutation. */
export type UpdatePermissionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Permission` being updated. */
  permissionPatch: PermissionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Plugin` mutation. */
export type UpdatePluginPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Plugin` that was updated by this mutation. */
  plugin?: Maybe<Plugin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Plugin`. May be used by Relay 1. */
  pluginEdge?: Maybe<PluginsEdge>;
};


/** The output of our update `Plugin` mutation. */
export type UpdatePluginPayloadpluginEdgeArgs = {
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
};

/** All input for the `updatePlugin` mutation. */
export type UpdatePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Plugin` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Plugin` being updated. */
  pluginPatch: PluginPatch;
};

/** Represents an update to a `Plugin`. Fields that are set will be updated. */
export type PluginPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  githubLink?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  logo?: InputMaybe<Scalars['String']>;
  screenshots?: InputMaybe<Scalars['String']>;
  lastUpdated?: InputMaybe<Scalars['Datetime']>;
  publisherName?: InputMaybe<Scalars['String']>;
  agreeTerms?: InputMaybe<Scalars['Boolean']>;
  publisherEmail?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePluginById` mutation. */
export type UpdatePluginByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Plugin` being updated. */
  pluginPatch: PluginPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Poll` mutation. */
export type UpdatePollPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Poll` that was updated by this mutation. */
  poll?: Maybe<Poll>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Poll`. May be used by Relay 1. */
  pollEdge?: Maybe<PollsEdge>;
};


/** The output of our update `Poll` mutation. */
export type UpdatePollPayloadpollEdgeArgs = {
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
};

/** All input for the `updatePoll` mutation. */
export type UpdatePollInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Poll` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Poll` being updated. */
  pollPatch: PollPatch;
};

/** Represents an update to a `Poll`. Fields that are set will be updated. */
export type PollPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  question?: InputMaybe<Scalars['String']>;
  response?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePollById` mutation. */
export type UpdatePollByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Poll` being updated. */
  pollPatch: PollPatch;
  id: Scalars['Int'];
};

/** The output of our update `ProductType` mutation. */
export type UpdateProductTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductType` that was updated by this mutation. */
  productType?: Maybe<ProductType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductType`. May be used by Relay 1. */
  productTypeEdge?: Maybe<ProductTypesEdge>;
};


/** The output of our update `ProductType` mutation. */
export type UpdateProductTypePayloadproductTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
};

/** All input for the `updateProductType` mutation. */
export type UpdateProductTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductType` being updated. */
  productTypePatch: ProductTypePatch;
};

/** Represents an update to a `ProductType`. Fields that are set will be updated. */
export type ProductTypePatch = {
  id?: InputMaybe<Scalars['Int']>;
  typeName?: InputMaybe<Scalars['String']>;
  taxes?: InputMaybe<Scalars['String']>;
  isShippable?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  filterOptions?: InputMaybe<Scalars['String']>;
  productType?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateProductTypeById` mutation. */
export type UpdateProductTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductType` being updated. */
  productTypePatch: ProductTypePatch;
  id: Scalars['Int'];
};

/** The output of our update `Product` mutation. */
export type UpdateProductPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Product` that was updated by this mutation. */
  product?: Maybe<Product>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Product`. May be used by Relay 1. */
  productEdge?: Maybe<ProductsEdge>;
};


/** The output of our update `Product` mutation. */
export type UpdateProductPayloadproductEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
};

/** All input for the `updateProduct` mutation. */
export type UpdateProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Product` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Product` being updated. */
  productPatch: ProductPatch;
};

/** Represents an update to a `Product`. Fields that are set will be updated. */
export type ProductPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  sku?: InputMaybe<Scalars['BigInt']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  price?: InputMaybe<Scalars['String']>;
  quantityPerSource?: InputMaybe<Scalars['String']>;
  salableQuantity?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['Boolean']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  taxClass?: InputMaybe<Scalars['String']>;
  stockStatus?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  country?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['String']>;
  format?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  shortDescription?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
  manufacture?: InputMaybe<Scalars['String']>;
  attributes?: InputMaybe<Scalars['String']>;
  brand?: InputMaybe<Scalars['String']>;
  contract?: InputMaybe<Scalars['String']>;
  costString?: InputMaybe<Scalars['String']>;
  customerType?: InputMaybe<Scalars['String']>;
  family?: InputMaybe<Scalars['String']>;
  manufacturerPartNumber?: InputMaybe<Scalars['String']>;
  occassions?: InputMaybe<Scalars['String']>;
  partNumber?: InputMaybe<Scalars['String']>;
  relatedProduct?: InputMaybe<Scalars['BigInt']>;
  tags?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Scalars['String']>;
  variants?: InputMaybe<Scalars['String']>;
  zone?: InputMaybe<Scalars['String']>;
  brands?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  creditMemos?: InputMaybe<Scalars['String']>;
  manufacturer?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  occassionsOccassionsToproducts?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  otherProducts?: InputMaybe<Scalars['String']>;
  productAttribute?: InputMaybe<Scalars['String']>;
  productTypes?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  returns?: InputMaybe<Scalars['String']>;
  taxRate?: InputMaybe<Scalars['String']>;
  taxRule?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateProductById` mutation. */
export type UpdateProductByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Product` being updated. */
  productPatch: ProductPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Project` mutation. */
export type UpdateProjectPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Project` that was updated by this mutation. */
  project?: Maybe<Project>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
};


/** The output of our update `Project` mutation. */
export type UpdateProjectPayloadprojectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the `updateProject` mutation. */
export type UpdateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Project` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Project` being updated. */
  projectPatch: ProjectPatch;
};

/** Represents an update to a `Project`. Fields that are set will be updated. */
export type ProjectPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  projectManager?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  resource?: InputMaybe<Scalars['String']>;
  considerworkingdays?: InputMaybe<Scalars['String']>;
  projectTemplate?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  assignee?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  doing?: InputMaybe<Scalars['String']>;
  done?: InputMaybe<Scalars['String']>;
  goalCollaborators?: InputMaybe<Scalars['String']>;
  goalMeasurement?: InputMaybe<Scalars['String']>;
  goalName?: InputMaybe<Scalars['String']>;
  goalPrivacy?: InputMaybe<Scalars['String']>;
  goalProgressSource?: InputMaybe<Scalars['String']>;
  goalTimeperiod?: InputMaybe<Scalars['String']>;
  goalUpdatemethod?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  sectionRule?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  taskId?: InputMaybe<Scalars['BigInt']>;
  ticketId?: InputMaybe<Scalars['BigInt']>;
  customers?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  ticketing?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  method?: InputMaybe<Scalars['String']>;
  zone?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  team?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateProjectById` mutation. */
export type UpdateProjectByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Project` being updated. */
  projectPatch: ProjectPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Provider` mutation. */
export type UpdateProviderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Provider` that was updated by this mutation. */
  provider?: Maybe<Provider>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Provider`. May be used by Relay 1. */
  providerEdge?: Maybe<ProvidersEdge>;
};


/** The output of our update `Provider` mutation. */
export type UpdateProviderPayloadproviderEdgeArgs = {
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
};

/** All input for the `updateProvider` mutation. */
export type UpdateProviderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Provider` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Provider` being updated. */
  providerPatch: ProviderPatch;
};

/** Represents an update to a `Provider`. Fields that are set will be updated. */
export type ProviderPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  hostUri?: InputMaybe<Scalars['String']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateProviderById` mutation. */
export type UpdateProviderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Provider` being updated. */
  providerPatch: ProviderPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Quote` mutation. */
export type UpdateQuotePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was updated by this mutation. */
  quote?: Maybe<Quote>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our update `Quote` mutation. */
export type UpdateQuotePayloadquoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the `updateQuote` mutation. */
export type UpdateQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Quote` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Quote` being updated. */
  quotePatch: QuotePatch;
};

/** Represents an update to a `Quote`. Fields that are set will be updated. */
export type QuotePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  grandTotal?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  categories?: InputMaybe<Scalars['String']>;
  validUntil?: InputMaybe<Scalars['String']>;
  quoteStage?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  orderId?: InputMaybe<Scalars['Int']>;
  account?: InputMaybe<Scalars['String']>;
  approvalIssues?: InputMaybe<Scalars['String']>;
  approvalStatus?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  billingCity?: InputMaybe<Scalars['String']>;
  billingCountry?: InputMaybe<Scalars['String']>;
  billingPostal?: InputMaybe<Scalars['String']>;
  billingState?: InputMaybe<Scalars['String']>;
  billingStreet?: InputMaybe<Scalars['String']>;
  contact?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  invoiceStatus?: InputMaybe<Scalars['String']>;
  lineItemDiscount?: InputMaybe<Scalars['String']>;
  lineItemGroupTotal?: InputMaybe<Scalars['String']>;
  lineItemName?: InputMaybe<Scalars['String']>;
  lineItemSubtotal?: InputMaybe<Scalars['String']>;
  lineItemTax?: InputMaybe<Scalars['String']>;
  lineItemTotal?: InputMaybe<Scalars['String']>;
  paymentTerms?: InputMaybe<Scalars['String']>;
  shipping?: InputMaybe<Scalars['String']>;
  shippingCity?: InputMaybe<Scalars['String']>;
  shippingCountry?: InputMaybe<Scalars['String']>;
  shippingPostal?: InputMaybe<Scalars['String']>;
  shippingState?: InputMaybe<Scalars['String']>;
  shippingStreet?: InputMaybe<Scalars['String']>;
  shippingTax?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  tax?: InputMaybe<Scalars['String']>;
  total?: InputMaybe<Scalars['String']>;
  customersCustomersToquotes?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  productsProductsToquotes?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateQuoteById` mutation. */
export type UpdateQuoteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Quote` being updated. */
  quotePatch: QuotePatch;
  id: Scalars['Int'];
};

/** The output of our update `Rating` mutation. */
export type UpdateRatingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Rating` that was updated by this mutation. */
  rating?: Maybe<Rating>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Rating`. May be used by Relay 1. */
  ratingEdge?: Maybe<RatingsEdge>;
};


/** The output of our update `Rating` mutation. */
export type UpdateRatingPayloadratingEdgeArgs = {
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
};

/** All input for the `updateRating` mutation. */
export type UpdateRatingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rating` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Rating` being updated. */
  ratingPatch: RatingPatch;
};

/** Represents an update to a `Rating`. Fields that are set will be updated. */
export type RatingPatch = {
  id?: InputMaybe<Scalars['Int']>;
  defaultValue?: InputMaybe<Scalars['String']>;
  defaultStoreView?: InputMaybe<Scalars['String']>;
  ratingVisibility?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  sortOrder?: InputMaybe<Scalars['BigFloat']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateRatingById` mutation. */
export type UpdateRatingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Rating` being updated. */
  ratingPatch: RatingPatch;
  id: Scalars['Int'];
};

/** The output of our update `Report` mutation. */
export type UpdateReportPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Report` that was updated by this mutation. */
  report?: Maybe<Report>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
};


/** The output of our update `Report` mutation. */
export type UpdateReportPayloadreportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the `updateReport` mutation. */
export type UpdateReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Report` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Report` being updated. */
  reportPatch: ReportPatch;
};

/** Represents an update to a `Report`. Fields that are set will be updated. */
export type ReportPatch = {
  id?: InputMaybe<Scalars['Int']>;
  customer?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['BigFloat']>;
  subtotal?: InputMaybe<Scalars['String']>;
  appliedCoupon?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  ipAddress?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateReportById` mutation. */
export type UpdateReportByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Report` being updated. */
  reportPatch: ReportPatch;
  id: Scalars['Int'];
};

/** The output of our update `Return` mutation. */
export type UpdateReturnPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Return` that was updated by this mutation. */
  return?: Maybe<Return>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Return`. May be used by Relay 1. */
  returnEdge?: Maybe<ReturnsEdge>;
};


/** The output of our update `Return` mutation. */
export type UpdateReturnPayloadreturnEdgeArgs = {
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
};

/** All input for the `updateReturn` mutation. */
export type UpdateReturnInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Return` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Return` being updated. */
  returnPatch: ReturnPatch;
};

/** Represents an update to a `Return`. Fields that are set will be updated. */
export type ReturnPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  validity?: InputMaybe<Scalars['String']>;
  returnPrefix?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  shippingNumber?: InputMaybe<Scalars['String']>;
  shippingDescription?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  liquidationReason?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['String']>;
  howShipped?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  shipTo?: InputMaybe<Scalars['String']>;
  caseId?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateReturnById` mutation. */
export type UpdateReturnByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Return` being updated. */
  returnPatch: ReturnPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Review` mutation. */
export type UpdateReviewPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was updated by this mutation. */
  review?: Maybe<Review>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our update `Review` mutation. */
export type UpdateReviewPayloadreviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the `updateReview` mutation. */
export type UpdateReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Review` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Review` being updated. */
  reviewPatch: ReviewPatch;
};

/** Represents an update to a `Review`. Fields that are set will be updated. */
export type ReviewPatch = {
  id?: InputMaybe<Scalars['Int']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  shopId?: InputMaybe<Scalars['Int']>;
  commentId?: InputMaybe<Scalars['Int']>;
};

/** All input for the `updateReviewById` mutation. */
export type UpdateReviewByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Review` being updated. */
  reviewPatch: ReviewPatch;
  id: Scalars['Int'];
};

/** The output of our update `Reward` mutation. */
export type UpdateRewardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reward` that was updated by this mutation. */
  reward?: Maybe<Reward>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Reward`. May be used by Relay 1. */
  rewardEdge?: Maybe<RewardsEdge>;
};


/** The output of our update `Reward` mutation. */
export type UpdateRewardPayloadrewardEdgeArgs = {
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
};

/** All input for the `updateReward` mutation. */
export type UpdateRewardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Reward` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Reward` being updated. */
  rewardPatch: RewardPatch;
};

/** Represents an update to a `Reward`. Fields that are set will be updated. */
export type RewardPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateRewardById` mutation. */
export type UpdateRewardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Reward` being updated. */
  rewardPatch: RewardPatch;
  id: Scalars['Int'];
};

/** The output of our update `Role` mutation. */
export type UpdateRolePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Role` that was updated by this mutation. */
  role?: Maybe<Role>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our update `Role` mutation. */
export type UpdateRolePayloadroleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the `updateRole` mutation. */
export type UpdateRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Role` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Role` being updated. */
  rolePatch: RolePatch;
};

/** Represents an update to a `Role`. Fields that are set will be updated. */
export type RolePatch = {
  id?: InputMaybe<Scalars['Int']>;
  roleName?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateRoleById` mutation. */
export type UpdateRoleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Role` being updated. */
  rolePatch: RolePatch;
  id: Scalars['Int'];
};

/** The output of our update `Scheduler` mutation. */
export type UpdateSchedulerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Scheduler` that was updated by this mutation. */
  scheduler?: Maybe<Scheduler>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
};


/** The output of our update `Scheduler` mutation. */
export type UpdateSchedulerPayloadschedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the `updateScheduler` mutation. */
export type UpdateSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Scheduler` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Scheduler` being updated. */
  schedulerPatch: SchedulerPatch;
};

/** Represents an update to a `Scheduler`. Fields that are set will be updated. */
export type SchedulerPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  endDate?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  notes?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSchedulerById` mutation. */
export type UpdateSchedulerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Scheduler` being updated. */
  schedulerPatch: SchedulerPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Segment` mutation. */
export type UpdateSegmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Segment` that was updated by this mutation. */
  segment?: Maybe<Segment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Segment`. May be used by Relay 1. */
  segmentEdge?: Maybe<SegmentsEdge>;
};


/** The output of our update `Segment` mutation. */
export type UpdateSegmentPayloadsegmentEdgeArgs = {
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
};

/** All input for the `updateSegment` mutation. */
export type UpdateSegmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Segment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Segment` being updated. */
  segmentPatch: SegmentPatch;
};

/** Represents an update to a `Segment`. Fields that are set will be updated. */
export type SegmentPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  applyTo?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSegmentById` mutation. */
export type UpdateSegmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Segment` being updated. */
  segmentPatch: SegmentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Setting` mutation. */
export type UpdateSettingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Setting` that was updated by this mutation. */
  setting?: Maybe<Setting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our update `Setting` mutation. */
export type UpdateSettingPayloadsettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the `updateSetting` mutation. */
export type UpdateSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Setting` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Setting` being updated. */
  settingPatch: SettingPatch;
};

/** Represents an update to a `Setting`. Fields that are set will be updated. */
export type SettingPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  storeName?: InputMaybe<Scalars['String']>;
  storePhone?: InputMaybe<Scalars['String']>;
  storeHours?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  vatNumber?: InputMaybe<Scalars['String']>;
  allowState?: InputMaybe<Scalars['String']>;
  stateRequiredFor?: InputMaybe<Scalars['String']>;
  allowCountries?: InputMaybe<Scalars['String']>;
  defaultCountry?: InputMaybe<Scalars['String']>;
  optionalZip?: InputMaybe<Scalars['String']>;
  europeanUnionCountries?: InputMaybe<Scalars['String']>;
  topDestinations?: InputMaybe<Scalars['String']>;
  baseCurrency?: InputMaybe<Scalars['String']>;
  defaultCurrency?: InputMaybe<Scalars['String']>;
  allowedCurrency?: InputMaybe<Scalars['String']>;
  siteName?: InputMaybe<Scalars['String']>;
  siteWebsite?: InputMaybe<Scalars['String']>;
  sentryDsn?: InputMaybe<Scalars['String']>;
  awsS3?: InputMaybe<Scalars['String']>;
  databaseUrl?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  googleAnalytics?: InputMaybe<Scalars['String']>;
  searchSetting?: InputMaybe<Scalars['String']>;
  mailServer?: InputMaybe<Scalars['String']>;
  youtubeVideos?: InputMaybe<Scalars['String']>;
  siteTagline?: InputMaybe<Scalars['String']>;
  googleDrive?: InputMaybe<Scalars['String']>;
  disqusKey?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSettingById` mutation. */
export type UpdateSettingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Setting` being updated. */
  settingPatch: SettingPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Shipment` mutation. */
export type UpdateShipmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipment` that was updated by this mutation. */
  shipment?: Maybe<Shipment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Shipment`. May be used by Relay 1. */
  shipmentEdge?: Maybe<ShipmentsEdge>;
};


/** The output of our update `Shipment` mutation. */
export type UpdateShipmentPayloadshipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
};

/** All input for the `updateShipment` mutation. */
export type UpdateShipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Shipment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Shipment` being updated. */
  shipmentPatch: ShipmentPatch;
};

/** Represents an update to a `Shipment`. Fields that are set will be updated. */
export type ShipmentPatch = {
  product?: InputMaybe<Scalars['String']>;
  speedGrade?: InputMaybe<Scalars['String']>;
  shipDate?: InputMaybe<Scalars['Datetime']>;
  carrierName?: InputMaybe<Scalars['String']>;
  transitTime?: InputMaybe<Scalars['String']>;
  trackingUrl?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateShipmentById` mutation. */
export type UpdateShipmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Shipment` being updated. */
  shipmentPatch: ShipmentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `SpecialDiscount` mutation. */
export type UpdateSpecialDiscountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpecialDiscount` that was updated by this mutation. */
  specialDiscount?: Maybe<SpecialDiscount>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SpecialDiscount`. May be used by Relay 1. */
  specialDiscountEdge?: Maybe<SpecialDiscountsEdge>;
};


/** The output of our update `SpecialDiscount` mutation. */
export type UpdateSpecialDiscountPayloadspecialDiscountEdgeArgs = {
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
};

/** All input for the `updateSpecialDiscount` mutation. */
export type UpdateSpecialDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpecialDiscount` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SpecialDiscount` being updated. */
  specialDiscountPatch: SpecialDiscountPatch;
};

/** Represents an update to a `SpecialDiscount`. Fields that are set will be updated. */
export type SpecialDiscountPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['BigFloat']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['Date']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSpecialDiscountById` mutation. */
export type UpdateSpecialDiscountByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SpecialDiscount` being updated. */
  specialDiscountPatch: SpecialDiscountPatch;
  id: Scalars['Int'];
};

/** The output of our update `State` mutation. */
export type UpdateStatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `State` that was updated by this mutation. */
  state?: Maybe<State>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `State`. May be used by Relay 1. */
  stateEdge?: Maybe<StatesEdge>;
};


/** The output of our update `State` mutation. */
export type UpdateStatePayloadstateEdgeArgs = {
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
};

/** All input for the `updateState` mutation. */
export type UpdateStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `State` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `State` being updated. */
  statePatch: StatePatch;
};

/** Represents an update to a `State`. Fields that are set will be updated. */
export type StatePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateStateById` mutation. */
export type UpdateStateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `State` being updated. */
  statePatch: StatePatch;
  id: Scalars['Int'];
};

/** The output of our update `Statistic` mutation. */
export type UpdateStatisticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Statistic` that was updated by this mutation. */
  statistic?: Maybe<Statistic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Statistic`. May be used by Relay 1. */
  statisticEdge?: Maybe<StatisticsEdge>;
};


/** The output of our update `Statistic` mutation. */
export type UpdateStatisticPayloadstatisticEdgeArgs = {
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
};

/** All input for the `updateStatistic` mutation. */
export type UpdateStatisticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Statistic` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Statistic` being updated. */
  statisticPatch: StatisticPatch;
};

/** Represents an update to a `Statistic`. Fields that are set will be updated. */
export type StatisticPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  specialOffers?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['Date']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateStatisticById` mutation. */
export type UpdateStatisticByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Statistic` being updated. */
  statisticPatch: StatisticPatch;
  id: Scalars['Int'];
};

/** The output of our update `Stock` mutation. */
export type UpdateStockPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Stock` that was updated by this mutation. */
  stock?: Maybe<Stock>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Stock`. May be used by Relay 1. */
  stockEdge?: Maybe<StocksEdge>;
};


/** The output of our update `Stock` mutation. */
export type UpdateStockPayloadstockEdgeArgs = {
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
};

/** All input for the `updateStock` mutation. */
export type UpdateStockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Stock` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Stock` being updated. */
  stockPatch: StockPatch;
};

/** Represents an update to a `Stock`. Fields that are set will be updated. */
export type StockPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  description?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  sources?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateStockById` mutation. */
export type UpdateStockByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Stock` being updated. */
  stockPatch: StockPatch;
  id: Scalars['Int'];
};

/** The output of our update `Survey` mutation. */
export type UpdateSurveyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Survey` that was updated by this mutation. */
  survey?: Maybe<Survey>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Survey`. May be used by Relay 1. */
  surveyEdge?: Maybe<SurveysEdge>;
};


/** The output of our update `Survey` mutation. */
export type UpdateSurveyPayloadsurveyEdgeArgs = {
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
};

/** All input for the `updateSurvey` mutation. */
export type UpdateSurveyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Survey` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Survey` being updated. */
  surveyPatch: SurveyPatch;
};

/** Represents an update to a `Survey`. Fields that are set will be updated. */
export type SurveyPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  question?: InputMaybe<Scalars['String']>;
  answer?: InputMaybe<Scalars['String']>;
  submitText?: InputMaybe<Scalars['String']>;
  satisfiedText?: InputMaybe<Scalars['String']>;
  neitherText?: InputMaybe<Scalars['String']>;
  dissatisfiedText?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSurveyById` mutation. */
export type UpdateSurveyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Survey` being updated. */
  surveyPatch: SurveyPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Tag` mutation. */
export type UpdateTagPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Tag` that was updated by this mutation. */
  tag?: Maybe<Tag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our update `Tag` mutation. */
export type UpdateTagPayloadtagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the `updateTag` mutation. */
export type UpdateTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tag` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: TagPatch;
};

/** Represents an update to a `Tag`. Fields that are set will be updated. */
export type TagPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTagById` mutation. */
export type UpdateTagByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: TagPatch;
  id: Scalars['Int'];
};

/** The output of our update `Target` mutation. */
export type UpdateTargetPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Target` that was updated by this mutation. */
  target?: Maybe<Target>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Target`. May be used by Relay 1. */
  targetEdge?: Maybe<TargetsEdge>;
};


/** The output of our update `Target` mutation. */
export type UpdateTargetPayloadtargetEdgeArgs = {
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
};

/** All input for the `updateTarget` mutation. */
export type UpdateTargetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Target` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Target` being updated. */
  targetPatch: TargetPatch;
};

/** Represents an update to a `Target`. Fields that are set will be updated. */
export type TargetPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  prefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  mobile?: InputMaybe<Scalars['String']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
  emailOptOut?: InputMaybe<Scalars['String']>;
  donotcall?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTargetById` mutation. */
export type UpdateTargetByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Target` being updated. */
  targetPatch: TargetPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `TaxCategory` mutation. */
export type UpdateTaxCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxCategory` that was updated by this mutation. */
  taxCategory?: Maybe<TaxCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxCategory`. May be used by Relay 1. */
  taxCategoryEdge?: Maybe<TaxCategoriesEdge>;
};


/** The output of our update `TaxCategory` mutation. */
export type UpdateTaxCategoryPayloadtaxCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
};

/** All input for the `updateTaxCategory` mutation. */
export type UpdateTaxCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TaxCategory` being updated. */
  taxCategoryPatch: TaxCategoryPatch;
};

/** Represents an update to a `TaxCategory`. Fields that are set will be updated. */
export type TaxCategoryPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTaxCategoryById` mutation. */
export type UpdateTaxCategoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TaxCategory` being updated. */
  taxCategoryPatch: TaxCategoryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `TaxRate` mutation. */
export type UpdateTaxRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRate` that was updated by this mutation. */
  taxRate?: Maybe<TaxRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRate`. May be used by Relay 1. */
  taxRateEdge?: Maybe<TaxRatesEdge>;
};


/** The output of our update `TaxRate` mutation. */
export type UpdateTaxRatePayloadtaxRateEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
};

/** All input for the `updateTaxRate` mutation. */
export type UpdateTaxRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxRate` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TaxRate` being updated. */
  taxRatePatch: TaxRatePatch;
};

/** Represents an update to a `TaxRate`. Fields that are set will be updated. */
export type TaxRatePatch = {
  id?: InputMaybe<Scalars['Int']>;
  taxIdentifier?: InputMaybe<Scalars['String']>;
  zipPostIsRange?: InputMaybe<Scalars['Boolean']>;
  postcode?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  ratePercent?: InputMaybe<Scalars['String']>;
  defaultStoreView?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTaxRateById` mutation. */
export type UpdateTaxRateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TaxRate` being updated. */
  taxRatePatch: TaxRatePatch;
  id: Scalars['Int'];
};

/** The output of our update `TaxRule` mutation. */
export type UpdateTaxRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRule` that was updated by this mutation. */
  taxRule?: Maybe<TaxRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRule`. May be used by Relay 1. */
  taxRuleEdge?: Maybe<TaxRulesEdge>;
};


/** The output of our update `TaxRule` mutation. */
export type UpdateTaxRulePayloadtaxRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
};

/** All input for the `updateTaxRule` mutation. */
export type UpdateTaxRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxRule` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TaxRule` being updated. */
  taxRulePatch: TaxRulePatch;
};

/** Represents an update to a `TaxRule`. Fields that are set will be updated. */
export type TaxRulePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  taxRate?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTaxRuleById` mutation. */
export type UpdateTaxRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TaxRule` being updated. */
  taxRulePatch: TaxRulePatch;
  id: Scalars['Int'];
};

/** The output of our update `Template` mutation. */
export type UpdateTemplatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was updated by this mutation. */
  template?: Maybe<Template>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our update `Template` mutation. */
export type UpdateTemplatePayloadtemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the `updateTemplate` mutation. */
export type UpdateTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Template` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  templatePatch: TemplatePatch;
};

/** Represents an update to a `Template`. Fields that are set will be updated. */
export type TemplatePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['String']>;
  pageSize?: InputMaybe<Scalars['String']>;
  orientation?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  header?: InputMaybe<Scalars['String']>;
  footer?: InputMaybe<Scalars['String']>;
  marginLeft?: InputMaybe<Scalars['String']>;
  marginRight?: InputMaybe<Scalars['String']>;
  marginTop?: InputMaybe<Scalars['String']>;
  marginBottom?: InputMaybe<Scalars['String']>;
  marginHeader?: InputMaybe<Scalars['String']>;
  marginFooter?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTemplateById` mutation. */
export type UpdateTemplateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Template` being updated. */
  templatePatch: TemplatePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Theme` mutation. */
export type UpdateThemePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Theme` that was updated by this mutation. */
  theme?: Maybe<Theme>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Theme`. May be used by Relay 1. */
  themeEdge?: Maybe<ThemesEdge>;
};


/** The output of our update `Theme` mutation. */
export type UpdateThemePayloadthemeEdgeArgs = {
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
};

/** All input for the `updateTheme` mutation. */
export type UpdateThemeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Theme` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Theme` being updated. */
  themePatch: ThemePatch;
};

/** Represents an update to a `Theme`. Fields that are set will be updated. */
export type ThemePatch = {
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  parentTheme?: InputMaybe<Scalars['String']>;
  themePath?: InputMaybe<Scalars['String']>;
  action?: InputMaybe<Scalars['String']>;
  websiteId?: InputMaybe<Scalars['BigInt']>;
  websites?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateThemeById` mutation. */
export type UpdateThemeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Theme` being updated. */
  themePatch: ThemePatch;
  id: Scalars['Int'];
};

/** The output of our update `Ticketing` mutation. */
export type UpdateTicketingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ticketing` that was updated by this mutation. */
  ticketing?: Maybe<Ticketing>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ticketing`. May be used by Relay 1. */
  ticketingEdge?: Maybe<TicketingsEdge>;
};


/** The output of our update `Ticketing` mutation. */
export type UpdateTicketingPayloadticketingEdgeArgs = {
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
};

/** All input for the `updateTicketing` mutation. */
export type UpdateTicketingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Ticketing` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Ticketing` being updated. */
  ticketingPatch: TicketingPatch;
};

/** Represents an update to a `Ticketing`. Fields that are set will be updated. */
export type TicketingPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['String']>;
  severity?: InputMaybe<Scalars['String']>;
  team?: InputMaybe<Scalars['String']>;
  requester?: InputMaybe<Scalars['String']>;
  requesterEmail?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  ticketType?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  resolution?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  dateModified?: InputMaybe<Scalars['Datetime']>;
  accountName?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  projectsProjectsToticketing?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTicketingById` mutation. */
export type UpdateTicketingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Ticketing` being updated. */
  ticketingPatch: TicketingPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Training` mutation. */
export type UpdateTrainingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Training` that was updated by this mutation. */
  training?: Maybe<Training>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Training`. May be used by Relay 1. */
  trainingEdge?: Maybe<TrainingsEdge>;
};


/** The output of our update `Training` mutation. */
export type UpdateTrainingPayloadtrainingEdgeArgs = {
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
};

/** All input for the `updateTraining` mutation. */
export type UpdateTrainingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Training` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Training` being updated. */
  trainingPatch: TrainingPatch;
};

/** Represents an update to a `Training`. Fields that are set will be updated. */
export type TrainingPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  link?: InputMaybe<Scalars['String']>;
  steps?: InputMaybe<Scalars['String']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  analytics?: InputMaybe<Scalars['String']>;
  competency?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Scalars['String']>;
  grade?: InputMaybe<Scalars['String']>;
  school?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['Int']>;
  address?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['Int']>;
  postal?: InputMaybe<Scalars['String']>;
  teacher?: InputMaybe<Scalars['String']>;
  student?: InputMaybe<Scalars['String']>;
  announcement?: InputMaybe<Scalars['String']>;
  resource?: InputMaybe<Scalars['String']>;
  badges?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  isCompleted?: InputMaybe<Scalars['String']>;
  speakers?: InputMaybe<Scalars['String']>;
  fieldTrips?: InputMaybe<Scalars['String']>;
  assignments?: InputMaybe<Scalars['String']>;
  assignmentsDueDate?: InputMaybe<Scalars['String']>;
  origanalityReport?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['BigInt']>;
  faqs?: InputMaybe<Scalars['String']>;
  languages?: InputMaybe<Scalars['String']>;
  checklists?: InputMaybe<Scalars['BigInt']>;
  city?: InputMaybe<Scalars['String']>;
  meetups?: InputMaybe<Scalars['String']>;
  lab?: InputMaybe<Scalars['String']>;
  digiboards?: InputMaybe<Scalars['String']>;
  countries?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTrainingById` mutation. */
export type UpdateTrainingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Training` being updated. */
  trainingPatch: TrainingPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Transaction` mutation. */
export type UpdateTransactionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was updated by this mutation. */
  transaction?: Maybe<Transaction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our update `Transaction` mutation. */
export type UpdateTransactionPayloadtransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the `updateTransaction` mutation. */
export type UpdateTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Transaction` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Transaction` being updated. */
  transactionPatch: TransactionPatch;
};

/** Represents an update to a `Transaction`. Fields that are set will be updated. */
export type TransactionPatch = {
  id?: InputMaybe<Scalars['Int']>;
  orderId?: InputMaybe<Scalars['Int']>;
  transactionId?: InputMaybe<Scalars['Int']>;
  parentTransactionId?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['Datetime']>;
  paymentMethod?: InputMaybe<Scalars['BigInt']>;
  closed?: InputMaybe<Scalars['String']>;
  customerPayment?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTransactionById` mutation. */
export type UpdateTransactionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Transaction` being updated. */
  transactionPatch: TransactionPatch;
  id: Scalars['Int'];
};

/** The output of our update `UploadFile` mutation. */
export type UpdateUploadFilePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UploadFile` that was updated by this mutation. */
  uploadFile?: Maybe<UploadFile>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `UploadFile`. May be used by Relay 1. */
  uploadFileEdge?: Maybe<UploadFilesEdge>;
};


/** The output of our update `UploadFile` mutation. */
export type UpdateUploadFilePayloaduploadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
};

/** All input for the `updateUploadFile` mutation. */
export type UpdateUploadFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UploadFile` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UploadFile` being updated. */
  uploadFilePatch: UploadFilePatch;
};

/** Represents an update to a `UploadFile`. Fields that are set will be updated. */
export type UploadFilePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  alternativeText?: InputMaybe<Scalars['String']>;
  caption?: InputMaybe<Scalars['String']>;
  width?: InputMaybe<Scalars['Int']>;
  height?: InputMaybe<Scalars['Int']>;
  formats?: InputMaybe<Scalars['JSON']>;
  hash?: InputMaybe<Scalars['String']>;
  ext?: InputMaybe<Scalars['String']>;
  mime?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['BigFloat']>;
  url?: InputMaybe<Scalars['String']>;
  previewUrl?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerMetadata?: InputMaybe<Scalars['JSON']>;
  createdBy?: InputMaybe<Scalars['Int']>;
  updatedBy?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateUploadFileById` mutation. */
export type UpdateUploadFileByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UploadFile` being updated. */
  uploadFilePatch: UploadFilePatch;
  id: Scalars['Int'];
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloaduserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  username?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  interfaceLocale?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
  permissions?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  emails?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  messages?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateUserById` mutation. */
export type UpdateUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Vendor` mutation. */
export type UpdateVendorPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was updated by this mutation. */
  vendor?: Maybe<Vendor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our update `Vendor` mutation. */
export type UpdateVendorPayloadvendorEdgeArgs = {
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
};

/** All input for the `updateVendor` mutation. */
export type UpdateVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vendor` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Vendor` being updated. */
  vendorPatch: VendorPatch;
};

/** Represents an update to a `Vendor`. Fields that are set will be updated. */
export type VendorPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  polls?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  reviews?: InputMaybe<Scalars['String']>;
  giftCertificates?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  invoices?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  rewardPoints?: InputMaybe<Scalars['String']>;
  specialDiscounts?: InputMaybe<Scalars['String']>;
  statistics?: InputMaybe<Scalars['String']>;
  stocks?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  physicalStore?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateVendorById` mutation. */
export type UpdateVendorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Vendor` being updated. */
  vendorPatch: VendorPatch;
  id: Scalars['Int'];
};

/** The output of our update `Visit` mutation. */
export type UpdateVisitPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Visit` that was updated by this mutation. */
  visit?: Maybe<Visit>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Visit`. May be used by Relay 1. */
  visitEdge?: Maybe<VisitsEdge>;
};


/** The output of our update `Visit` mutation. */
export type UpdateVisitPayloadvisitEdgeArgs = {
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
};

/** All input for the `updateVisit` mutation. */
export type UpdateVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Visit` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Visit` being updated. */
  visitPatch: VisitPatch;
};

/** Represents an update to a `Visit`. Fields that are set will be updated. */
export type VisitPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  location?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  reason?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  emergency?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  meeting?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateVisitById` mutation. */
export type UpdateVisitByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Visit` being updated. */
  visitPatch: VisitPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Warehouse` mutation. */
export type UpdateWarehousePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was updated by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our update `Warehouse` mutation. */
export type UpdateWarehousePayloadwarehouseEdgeArgs = {
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
};

/** All input for the `updateWarehouse` mutation. */
export type UpdateWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Warehouse` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Warehouse` being updated. */
  warehousePatch: WarehousePatch;
};

/** Represents an update to a `Warehouse`. Fields that are set will be updated. */
export type WarehousePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postal?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWarehouseById` mutation. */
export type UpdateWarehouseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Warehouse` being updated. */
  warehousePatch: WarehousePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Webhook` mutation. */
export type UpdateWebhookPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Webhook` that was updated by this mutation. */
  webhook?: Maybe<Webhook>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Webhook`. May be used by Relay 1. */
  webhookEdge?: Maybe<WebhooksEdge>;
};


/** The output of our update `Webhook` mutation. */
export type UpdateWebhookPayloadwebhookEdgeArgs = {
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
};

/** All input for the `updateWebhook` mutation. */
export type UpdateWebhookInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Webhook` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Webhook` being updated. */
  webhookPatch: WebhookPatch;
};

/** Represents an update to a `Webhook`. Fields that are set will be updated. */
export type WebhookPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  headers?: InputMaybe<Scalars['String']>;
  create?: InputMaybe<Scalars['String']>;
  retrieve?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['String']>;
  delete?: InputMaybe<Scalars['String']>;
  publish?: InputMaybe<Scalars['String']>;
  unpublish?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWebhookById` mutation. */
export type UpdateWebhookByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Webhook` being updated. */
  webhookPatch: WebhookPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Website` mutation. */
export type UpdateWebsitePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Website` that was updated by this mutation. */
  website?: Maybe<Website>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Website`. May be used by Relay 1. */
  websiteEdge?: Maybe<WebsitesEdge>;
};


/** The output of our update `Website` mutation. */
export type UpdateWebsitePayloadwebsiteEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
};

/** All input for the `updateWebsite` mutation. */
export type UpdateWebsiteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Website` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Website` being updated. */
  websitePatch: WebsitePatch;
};

/** Represents an update to a `Website`. Fields that are set will be updated. */
export type WebsitePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  shop?: InputMaybe<Scalars['String']>;
  store?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  themes?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWebsiteById` mutation. */
export type UpdateWebsiteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Website` being updated. */
  websitePatch: WebsitePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Wishlist` mutation. */
export type UpdateWishlistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Wishlist` that was updated by this mutation. */
  wishlist?: Maybe<Wishlist>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Wishlist`. May be used by Relay 1. */
  wishlistEdge?: Maybe<WishlistsEdge>;
};


/** The output of our update `Wishlist` mutation. */
export type UpdateWishlistPayloadwishlistEdgeArgs = {
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
};

/** All input for the `updateWishlist` mutation. */
export type UpdateWishlistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Wishlist` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Wishlist` being updated. */
  wishlistPatch: WishlistPatch;
};

/** Represents an update to a `Wishlist`. Fields that are set will be updated. */
export type WishlistPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['String']>;
  occassions?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWishlistById` mutation. */
export type UpdateWishlistByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Wishlist` being updated. */
  wishlistPatch: WishlistPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Workspace` mutation. */
export type UpdateWorkspacePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Workspace` that was updated by this mutation. */
  workspace?: Maybe<Workspace>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Workspace`. May be used by Relay 1. */
  workspaceEdge?: Maybe<WorkspacesEdge>;
};


/** The output of our update `Workspace` mutation. */
export type UpdateWorkspacePayloadworkspaceEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
};

/** All input for the `updateWorkspace` mutation. */
export type UpdateWorkspaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Workspace` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Workspace` being updated. */
  workspacePatch: WorkspacePatch;
};

/** Represents an update to a `Workspace`. Fields that are set will be updated. */
export type WorkspacePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['Int']>;
  users?: InputMaybe<Scalars['Int']>;
  products?: InputMaybe<Scalars['BigInt']>;
  tasks?: InputMaybe<Scalars['BigInt']>;
  brands?: InputMaybe<Scalars['BigInt']>;
  shops?: InputMaybe<Scalars['Int']>;
  category?: InputMaybe<Scalars['Int']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  projects?: InputMaybe<Scalars['BigInt']>;
  author?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  brandsBrandsToworkspaces?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  customersCustomersToworkspaces?: InputMaybe<Scalars['String']>;
  productsProductsToworkspaces?: InputMaybe<Scalars['String']>;
  projectsProjectsToworkspaces?: InputMaybe<Scalars['String']>;
  shopsShopsToworkspaces?: InputMaybe<Scalars['String']>;
  tasksTasksToworkspaces?: InputMaybe<Scalars['String']>;
  usersUsersToworkspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWorkspaceById` mutation. */
export type UpdateWorkspaceByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Workspace` being updated. */
  workspacePatch: WorkspacePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Zone` mutation. */
export type UpdateZonePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Zone` that was updated by this mutation. */
  zone?: Maybe<Zone>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Zone`. May be used by Relay 1. */
  zoneEdge?: Maybe<ZonesEdge>;
};


/** The output of our update `Zone` mutation. */
export type UpdateZonePayloadzoneEdgeArgs = {
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
};

/** All input for the `updateZone` mutation. */
export type UpdateZoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Zone` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Zone` being updated. */
  zonePatch: ZonePatch;
};

/** Represents an update to a `Zone`. Fields that are set will be updated. */
export type ZonePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  scope?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  code?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateZoneById` mutation. */
export type UpdateZoneByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Zone` being updated. */
  zonePatch: ZonePatch;
  id: Scalars['BigInt'];
};

/** The output of our delete `Account` mutation. */
export type DeleteAccountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was deleted by this mutation. */
  account?: Maybe<Account>;
  deletedAccountId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our delete `Account` mutation. */
export type DeleteAccountPayloadaccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the `deleteAccount` mutation. */
export type DeleteAccountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Account` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAccountById` mutation. */
export type DeleteAccountByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Agreement` mutation. */
export type DeleteAgreementPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agreement` that was deleted by this mutation. */
  agreement?: Maybe<Agreement>;
  deletedAgreementId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Agreement`. May be used by Relay 1. */
  agreementEdge?: Maybe<AgreementsEdge>;
};


/** The output of our delete `Agreement` mutation. */
export type DeleteAgreementPayloadagreementEdgeArgs = {
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
};

/** All input for the `deleteAgreement` mutation. */
export type DeleteAgreementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Agreement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAgreementById` mutation. */
export type DeleteAgreementByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Analytic` mutation. */
export type DeleteAnalyticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Analytic` that was deleted by this mutation. */
  analytic?: Maybe<Analytic>;
  deletedAnalyticId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Analytic`. May be used by Relay 1. */
  analyticEdge?: Maybe<AnalyticsEdge>;
};


/** The output of our delete `Analytic` mutation. */
export type DeleteAnalyticPayloadanalyticEdgeArgs = {
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
};

/** All input for the `deleteAnalytic` mutation. */
export type DeleteAnalyticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Analytic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAnalyticById` mutation. */
export type DeleteAnalyticByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Apitoken` mutation. */
export type DeleteApitokenPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Apitoken` that was deleted by this mutation. */
  apitoken?: Maybe<Apitoken>;
  deletedApitokenId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Apitoken`. May be used by Relay 1. */
  apitokenEdge?: Maybe<ApitokensEdge>;
};


/** The output of our delete `Apitoken` mutation. */
export type DeleteApitokenPayloadapitokenEdgeArgs = {
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
};

/** All input for the `deleteApitoken` mutation. */
export type DeleteApitokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Apitoken` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteApitokenById` mutation. */
export type DeleteApitokenByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Article` mutation. */
export type DeleteArticlePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Article` that was deleted by this mutation. */
  article?: Maybe<Article>;
  deletedArticleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Article`. May be used by Relay 1. */
  articleEdge?: Maybe<ArticlesEdge>;
};


/** The output of our delete `Article` mutation. */
export type DeleteArticlePayloadarticleEdgeArgs = {
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
};

/** All input for the `deleteArticle` mutation. */
export type DeleteArticleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Article` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteArticleById` mutation. */
export type DeleteArticleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Attribute` mutation. */
export type DeleteAttributePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Attribute` that was deleted by this mutation. */
  attribute?: Maybe<Attribute>;
  deletedAttributeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Attribute`. May be used by Relay 1. */
  attributeEdge?: Maybe<AttributesEdge>;
};


/** The output of our delete `Attribute` mutation. */
export type DeleteAttributePayloadattributeEdgeArgs = {
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
};

/** All input for the `deleteAttribute` mutation. */
export type DeleteAttributeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Attribute` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAttributeById` mutation. */
export type DeleteAttributeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Brand` mutation. */
export type DeleteBrandPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Brand` that was deleted by this mutation. */
  brand?: Maybe<Brand>;
  deletedBrandId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<BrandsEdge>;
};


/** The output of our delete `Brand` mutation. */
export type DeleteBrandPayloadbrandEdgeArgs = {
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
};

/** All input for the `deleteBrand` mutation. */
export type DeleteBrandInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Brand` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteBrandById` mutation. */
export type DeleteBrandByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CartPriceRule` mutation. */
export type DeleteCartPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CartPriceRule` that was deleted by this mutation. */
  cartPriceRule?: Maybe<CartPriceRule>;
  deletedCartPriceRuleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CartPriceRule`. May be used by Relay 1. */
  cartPriceRuleEdge?: Maybe<CartPriceRulesEdge>;
};


/** The output of our delete `CartPriceRule` mutation. */
export type DeleteCartPriceRulePayloadcartPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
};

/** All input for the `deleteCartPriceRule` mutation. */
export type DeleteCartPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CartPriceRule` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCartPriceRuleById` mutation. */
export type DeleteCartPriceRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Case` mutation. */
export type DeleteCasePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Case` that was deleted by this mutation. */
  case?: Maybe<Case>;
  deletedCaseId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Case`. May be used by Relay 1. */
  caseEdge?: Maybe<CasesEdge>;
};


/** The output of our delete `Case` mutation. */
export type DeleteCasePayloadcaseEdgeArgs = {
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
};

/** All input for the `deleteCase` mutation. */
export type DeleteCaseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Case` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCaseById` mutation. */
export type DeleteCaseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CatalogPriceRule` mutation. */
export type DeleteCatalogPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CatalogPriceRule` that was deleted by this mutation. */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  deletedCatalogPriceRuleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CatalogPriceRule`. May be used by Relay 1. */
  catalogPriceRuleEdge?: Maybe<CatalogPriceRulesEdge>;
};


/** The output of our delete `CatalogPriceRule` mutation. */
export type DeleteCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
};

/** All input for the `deleteCatalogPriceRule` mutation. */
export type DeleteCatalogPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CatalogPriceRule` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCatalogPriceRuleById` mutation. */
export type DeleteCatalogPriceRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Category` mutation. */
export type DeleteCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Category` that was deleted by this mutation. */
  category?: Maybe<Category>;
  deletedCategoryId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<CategoriesEdge>;
};


/** The output of our delete `Category` mutation. */
export type DeleteCategoryPayloadcategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
};

/** All input for the `deleteCategory` mutation. */
export type DeleteCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Category` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCategoryById` mutation. */
export type DeleteCategoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Channel` mutation. */
export type DeleteChannelPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Channel` that was deleted by this mutation. */
  channel?: Maybe<Channel>;
  deletedChannelId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Channel`. May be used by Relay 1. */
  channelEdge?: Maybe<ChannelsEdge>;
};


/** The output of our delete `Channel` mutation. */
export type DeleteChannelPayloadchannelEdgeArgs = {
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
};

/** All input for the `deleteChannel` mutation. */
export type DeleteChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Channel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChannelById` mutation. */
export type DeleteChannelByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Checklist` mutation. */
export type DeleteChecklistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Checklist` that was deleted by this mutation. */
  checklist?: Maybe<Checklist>;
  deletedChecklistId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Checklist`. May be used by Relay 1. */
  checklistEdge?: Maybe<ChecklistsEdge>;
};


/** The output of our delete `Checklist` mutation. */
export type DeleteChecklistPayloadchecklistEdgeArgs = {
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
};

/** All input for the `deleteChecklist` mutation. */
export type DeleteChecklistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Checklist` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChecklistById` mutation. */
export type DeleteChecklistByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `City` mutation. */
export type DeleteCityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `City` that was deleted by this mutation. */
  city?: Maybe<City>;
  deletedCityId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `City`. May be used by Relay 1. */
  cityEdge?: Maybe<CitiesEdge>;
};


/** The output of our delete `City` mutation. */
export type DeleteCityPayloadcityEdgeArgs = {
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
};

/** All input for the `deleteCity` mutation. */
export type DeleteCityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `City` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCityById` mutation. */
export type DeleteCityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Collection` mutation. */
export type DeleteCollectionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Collection` that was deleted by this mutation. */
  collection?: Maybe<Collection>;
  deletedCollectionId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Collection`. May be used by Relay 1. */
  collectionEdge?: Maybe<CollectionsEdge>;
};


/** The output of our delete `Collection` mutation. */
export type DeleteCollectionPayloadcollectionEdgeArgs = {
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
};

/** All input for the `deleteCollection` mutation. */
export type DeleteCollectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Collection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCollectionById` mutation. */
export type DeleteCollectionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Comment` mutation. */
export type DeleteCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Comment` that was deleted by this mutation. */
  comment?: Maybe<Comment>;
  deletedCommentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  commentEdge?: Maybe<CommentsEdge>;
};


/** The output of our delete `Comment` mutation. */
export type DeleteCommentPayloadcommentEdgeArgs = {
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
};

/** All input for the `deleteComment` mutation. */
export type DeleteCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Comment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommentById` mutation. */
export type DeleteCommentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ContentType` mutation. */
export type DeleteContentTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContentType` that was deleted by this mutation. */
  contentType?: Maybe<ContentType>;
  deletedContentTypeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ContentType`. May be used by Relay 1. */
  contentTypeEdge?: Maybe<ContentTypesEdge>;
};


/** The output of our delete `ContentType` mutation. */
export type DeleteContentTypePayloadcontentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
};

/** All input for the `deleteContentType` mutation. */
export type DeleteContentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContentType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContentTypeById` mutation. */
export type DeleteContentTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Contract` mutation. */
export type DeleteContractPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Contract` that was deleted by this mutation. */
  contract?: Maybe<Contract>;
  deletedContractId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Contract`. May be used by Relay 1. */
  contractEdge?: Maybe<ContractsEdge>;
};


/** The output of our delete `Contract` mutation. */
export type DeleteContractPayloadcontractEdgeArgs = {
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
};

/** All input for the `deleteContract` mutation. */
export type DeleteContractInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Contract` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContractById` mutation. */
export type DeleteContractByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Country` mutation. */
export type DeleteCountryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was deleted by this mutation. */
  country?: Maybe<Country>;
  deletedCountryId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our delete `Country` mutation. */
export type DeleteCountryPayloadcountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the `deleteCountry` mutation. */
export type DeleteCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCountryById` mutation. */
export type DeleteCountryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Coupon` mutation. */
export type DeleteCouponPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Coupon` that was deleted by this mutation. */
  coupon?: Maybe<Coupon>;
  deletedCouponId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Coupon`. May be used by Relay 1. */
  couponEdge?: Maybe<CouponsEdge>;
};


/** The output of our delete `Coupon` mutation. */
export type DeleteCouponPayloadcouponEdgeArgs = {
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
};

/** All input for the `deleteCoupon` mutation. */
export type DeleteCouponInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Coupon` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCouponById` mutation. */
export type DeleteCouponByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CreditMemo` mutation. */
export type DeleteCreditMemoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CreditMemo` that was deleted by this mutation. */
  creditMemo?: Maybe<CreditMemo>;
  deletedCreditMemoId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CreditMemo`. May be used by Relay 1. */
  creditMemoEdge?: Maybe<CreditMemosEdge>;
};


/** The output of our delete `CreditMemo` mutation. */
export type DeleteCreditMemoPayloadcreditMemoEdgeArgs = {
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
};

/** All input for the `deleteCreditMemo` mutation. */
export type DeleteCreditMemoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CreditMemo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCreditMemoByCreditMemoAndId` mutation. */
export type DeleteCreditMemoByCreditMemoAndIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  creditMemo: Scalars['String'];
  id: Scalars['BigInt'];
};

/** The output of our delete `Currency` mutation. */
export type DeleteCurrencyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Currency` that was deleted by this mutation. */
  currency?: Maybe<Currency>;
  deletedCurrencyId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Currency`. May be used by Relay 1. */
  currencyEdge?: Maybe<CurrenciesEdge>;
};


/** The output of our delete `Currency` mutation. */
export type DeleteCurrencyPayloadcurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
};

/** All input for the `deleteCurrency` mutation. */
export type DeleteCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Currency` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCurrencyById` mutation. */
export type DeleteCurrencyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CurrencyRate` mutation. */
export type DeleteCurrencyRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencyRate` that was deleted by this mutation. */
  currencyRate?: Maybe<CurrencyRate>;
  deletedCurrencyRateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencyRate`. May be used by Relay 1. */
  currencyRateEdge?: Maybe<CurrencyRatesEdge>;
};


/** The output of our delete `CurrencyRate` mutation. */
export type DeleteCurrencyRatePayloadcurrencyRateEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
};

/** All input for the `deleteCurrencyRate` mutation. */
export type DeleteCurrencyRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CurrencyRate` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCurrencyRateByImportService` mutation. */
export type DeleteCurrencyRateByImportServiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  importService: Scalars['String'];
};

/** The output of our delete `CurrencySymbol` mutation. */
export type DeleteCurrencySymbolPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencySymbol` that was deleted by this mutation. */
  currencySymbol?: Maybe<CurrencySymbol>;
  deletedCurrencySymbolId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencySymbol`. May be used by Relay 1. */
  currencySymbolEdge?: Maybe<CurrencySymbolsEdge>;
};


/** The output of our delete `CurrencySymbol` mutation. */
export type DeleteCurrencySymbolPayloadcurrencySymbolEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
};

/** All input for the `deleteCurrencySymbol` mutation. */
export type DeleteCurrencySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CurrencySymbol` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCurrencySymbolBySymbol` mutation. */
export type DeleteCurrencySymbolBySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  symbol: Scalars['String'];
};

/** The output of our delete `CustomerGroup` mutation. */
export type DeleteCustomerGroupPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerGroup` that was deleted by this mutation. */
  customerGroup?: Maybe<CustomerGroup>;
  deletedCustomerGroupId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerGroup`. May be used by Relay 1. */
  customerGroupEdge?: Maybe<CustomerGroupsEdge>;
};


/** The output of our delete `CustomerGroup` mutation. */
export type DeleteCustomerGroupPayloadcustomerGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
};

/** All input for the `deleteCustomerGroup` mutation. */
export type DeleteCustomerGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerGroupById` mutation. */
export type DeleteCustomerGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was deleted by this mutation. */
  customer?: Maybe<Customer>;
  deletedCustomerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayloadcustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the `deleteCustomer` mutation. */
export type DeleteCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerById` mutation. */
export type DeleteCustomerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Customization` mutation. */
export type DeleteCustomizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customization` that was deleted by this mutation. */
  customization?: Maybe<Customization>;
  deletedCustomizationId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customization`. May be used by Relay 1. */
  customizationEdge?: Maybe<CustomizationsEdge>;
};


/** The output of our delete `Customization` mutation. */
export type DeleteCustomizationPayloadcustomizationEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
};

/** All input for the `deleteCustomization` mutation. */
export type DeleteCustomizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customization` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomizationById` mutation. */
export type DeleteCustomizationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Dashboard` mutation. */
export type DeleteDashboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Dashboard` that was deleted by this mutation. */
  dashboard?: Maybe<Dashboard>;
  deletedDashboardId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Dashboard`. May be used by Relay 1. */
  dashboardEdge?: Maybe<DashboardsEdge>;
};


/** The output of our delete `Dashboard` mutation. */
export type DeleteDashboardPayloaddashboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
};

/** All input for the `deleteDashboard` mutation. */
export type DeleteDashboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dashboard` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDashboardById` mutation. */
export type DeleteDashboardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Deepdive` mutation. */
export type DeleteDeepdivePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Deepdive` that was deleted by this mutation. */
  deepdive?: Maybe<Deepdive>;
  deletedDeepdiveId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Deepdive`. May be used by Relay 1. */
  deepdiveEdge?: Maybe<DeepdivesEdge>;
};


/** The output of our delete `Deepdive` mutation. */
export type DeleteDeepdivePayloaddeepdiveEdgeArgs = {
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
};

/** All input for the `deleteDeepdive` mutation. */
export type DeleteDeepdiveInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Deepdive` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDeepdiveById` mutation. */
export type DeleteDeepdiveByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Digiboard` mutation. */
export type DeleteDigiboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Digiboard` that was deleted by this mutation. */
  digiboard?: Maybe<Digiboard>;
  deletedDigiboardId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Digiboard`. May be used by Relay 1. */
  digiboardEdge?: Maybe<DigiboardsEdge>;
};


/** The output of our delete `Digiboard` mutation. */
export type DeleteDigiboardPayloaddigiboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
};

/** All input for the `deleteDigiboard` mutation. */
export type DeleteDigiboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Digiboard` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDigiboardById` mutation. */
export type DeleteDigiboardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Email` mutation. */
export type DeleteEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was deleted by this mutation. */
  email?: Maybe<Email>;
  deletedEmailId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our delete `Email` mutation. */
export type DeleteEmailPayloademailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the `deleteEmail` mutation. */
export type DeleteEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Email` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEmailById` mutation. */
export type DeleteEmailByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Endofshift` mutation. */
export type DeleteEndofshiftPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Endofshift` that was deleted by this mutation. */
  endofshift?: Maybe<Endofshift>;
  deletedEndofshiftId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Endofshift`. May be used by Relay 1. */
  endofshiftEdge?: Maybe<EndofshiftsEdge>;
};


/** The output of our delete `Endofshift` mutation. */
export type DeleteEndofshiftPayloadendofshiftEdgeArgs = {
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
};

/** All input for the `deleteEndofshift` mutation. */
export type DeleteEndofshiftInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Endofshift` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEndofshiftById` mutation. */
export type DeleteEndofshiftByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` that was deleted by this mutation. */
  event?: Maybe<Event>;
  deletedEventId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadeventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Event` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEventById` mutation. */
export type DeleteEventByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Fullfillment` mutation. */
export type DeleteFullfillmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Fullfillment` that was deleted by this mutation. */
  fullfillment?: Maybe<Fullfillment>;
  deletedFullfillmentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Fullfillment`. May be used by Relay 1. */
  fullfillmentEdge?: Maybe<FullfillmentsEdge>;
};


/** The output of our delete `Fullfillment` mutation. */
export type DeleteFullfillmentPayloadfullfillmentEdgeArgs = {
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
};

/** All input for the `deleteFullfillment` mutation. */
export type DeleteFullfillmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Fullfillment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFullfillmentById` mutation. */
export type DeleteFullfillmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `GiftCertificate` mutation. */
export type DeleteGiftCertificatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GiftCertificate` that was deleted by this mutation. */
  giftCertificate?: Maybe<GiftCertificate>;
  deletedGiftCertificateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `GiftCertificate`. May be used by Relay 1. */
  giftCertificateEdge?: Maybe<GiftCertificatesEdge>;
};


/** The output of our delete `GiftCertificate` mutation. */
export type DeleteGiftCertificatePayloadgiftCertificateEdgeArgs = {
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
};

/** All input for the `deleteGiftCertificate` mutation. */
export type DeleteGiftCertificateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GiftCertificate` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGiftCertificateById` mutation. */
export type DeleteGiftCertificateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Glossary` mutation. */
export type DeleteGlossaryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Glossary` that was deleted by this mutation. */
  glossary?: Maybe<Glossary>;
  deletedGlossaryId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Glossary`. May be used by Relay 1. */
  glossaryEdge?: Maybe<GlossariesEdge>;
};


/** The output of our delete `Glossary` mutation. */
export type DeleteGlossaryPayloadglossaryEdgeArgs = {
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
};

/** All input for the `deleteGlossary` mutation. */
export type DeleteGlossaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Glossary` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGlossaryById` mutation. */
export type DeleteGlossaryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Importm` mutation. */
export type DeleteImportmPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Importm` that was deleted by this mutation. */
  importm?: Maybe<Importm>;
  deletedImportmId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Importm`. May be used by Relay 1. */
  importmEdge?: Maybe<ImportmsEdge>;
};


/** The output of our delete `Importm` mutation. */
export type DeleteImportmPayloadimportmEdgeArgs = {
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
};

/** All input for the `deleteImportm` mutation. */
export type DeleteImportmInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Importm` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteImportmById` mutation. */
export type DeleteImportmByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Integration` mutation. */
export type DeleteIntegrationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Integration` that was deleted by this mutation. */
  integration?: Maybe<Integration>;
  deletedIntegrationId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Integration`. May be used by Relay 1. */
  integrationEdge?: Maybe<IntegrationsEdge>;
};


/** The output of our delete `Integration` mutation. */
export type DeleteIntegrationPayloadintegrationEdgeArgs = {
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
};

/** All input for the `deleteIntegration` mutation. */
export type DeleteIntegrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Integration` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteIntegrationById` mutation. */
export type DeleteIntegrationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Internalization` mutation. */
export type DeleteInternalizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Internalization` that was deleted by this mutation. */
  internalization?: Maybe<Internalization>;
  deletedInternalizationId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Internalization`. May be used by Relay 1. */
  internalizationEdge?: Maybe<InternalizationsEdge>;
};


/** The output of our delete `Internalization` mutation. */
export type DeleteInternalizationPayloadinternalizationEdgeArgs = {
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
};

/** All input for the `deleteInternalization` mutation. */
export type DeleteInternalizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Internalization` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInternalizationById` mutation. */
export type DeleteInternalizationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Invitation` mutation. */
export type DeleteInvitationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invitation` that was deleted by this mutation. */
  invitation?: Maybe<Invitation>;
  deletedInvitationId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invitation`. May be used by Relay 1. */
  invitationEdge?: Maybe<InvitationsEdge>;
};


/** The output of our delete `Invitation` mutation. */
export type DeleteInvitationPayloadinvitationEdgeArgs = {
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
};

/** All input for the `deleteInvitation` mutation. */
export type DeleteInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invitation` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInvitationById` mutation. */
export type DeleteInvitationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Invoice` mutation. */
export type DeleteInvoicePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was deleted by this mutation. */
  invoice?: Maybe<Invoice>;
  deletedInvoiceId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our delete `Invoice` mutation. */
export type DeleteInvoicePayloadinvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the `deleteInvoice` mutation. */
export type DeleteInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invoice` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInvoiceById` mutation. */
export type DeleteInvoiceByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Lead` mutation. */
export type DeleteLeadPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lead` that was deleted by this mutation. */
  lead?: Maybe<Lead>;
  deletedLeadId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
};


/** The output of our delete `Lead` mutation. */
export type DeleteLeadPayloadleadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the `deleteLead` mutation. */
export type DeleteLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lead` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLeadById` mutation. */
export type DeleteLeadByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Manufacturer` mutation. */
export type DeleteManufacturerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Manufacturer` that was deleted by this mutation. */
  manufacturer?: Maybe<Manufacturer>;
  deletedManufacturerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Manufacturer`. May be used by Relay 1. */
  manufacturerEdge?: Maybe<ManufacturersEdge>;
};


/** The output of our delete `Manufacturer` mutation. */
export type DeleteManufacturerPayloadmanufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
};

/** All input for the `deleteManufacturer` mutation. */
export type DeleteManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Manufacturer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteManufacturerById` mutation. */
export type DeleteManufacturerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Mediamanager` mutation. */
export type DeleteMediamanagerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Mediamanager` that was deleted by this mutation. */
  mediamanager?: Maybe<Mediamanager>;
  deletedMediamanagerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Mediamanager`. May be used by Relay 1. */
  mediamanagerEdge?: Maybe<MediamanagersEdge>;
};


/** The output of our delete `Mediamanager` mutation. */
export type DeleteMediamanagerPayloadmediamanagerEdgeArgs = {
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
};

/** All input for the `deleteMediamanager` mutation. */
export type DeleteMediamanagerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Mediamanager` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteMediamanagerById` mutation. */
export type DeleteMediamanagerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Meeting` mutation. */
export type DeleteMeetingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Meeting` that was deleted by this mutation. */
  meeting?: Maybe<Meeting>;
  deletedMeetingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Meeting`. May be used by Relay 1. */
  meetingEdge?: Maybe<MeetingsEdge>;
};


/** The output of our delete `Meeting` mutation. */
export type DeleteMeetingPayloadmeetingEdgeArgs = {
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
};

/** All input for the `deleteMeeting` mutation. */
export type DeleteMeetingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Meeting` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteMeetingById` mutation. */
export type DeleteMeetingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Message` mutation. */
export type DeleteMessagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was deleted by this mutation. */
  message?: Maybe<Message>;
  deletedMessageId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
};


/** The output of our delete `Message` mutation. */
export type DeleteMessagePayloadmessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the `deleteMessage` mutation. */
export type DeleteMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Message` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteMessageById` mutation. */
export type DeleteMessageByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Newsletter` mutation. */
export type DeleteNewsletterPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Newsletter` that was deleted by this mutation. */
  newsletter?: Maybe<Newsletter>;
  deletedNewsletterId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Newsletter`. May be used by Relay 1. */
  newsletterEdge?: Maybe<NewslettersEdge>;
};


/** The output of our delete `Newsletter` mutation. */
export type DeleteNewsletterPayloadnewsletterEdgeArgs = {
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
};

/** All input for the `deleteNewsletter` mutation. */
export type DeleteNewsletterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Newsletter` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNewsletterById` mutation. */
export type DeleteNewsletterByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Ooto` mutation. */
export type DeleteOotoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ooto` that was deleted by this mutation. */
  ooto?: Maybe<Ooto>;
  deletedOotoId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ooto`. May be used by Relay 1. */
  ootoEdge?: Maybe<OotosEdge>;
};


/** The output of our delete `Ooto` mutation. */
export type DeleteOotoPayloadootoEdgeArgs = {
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
};

/** All input for the `deleteOoto` mutation. */
export type DeleteOotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Ooto` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOotoById` mutation. */
export type DeleteOotoByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Opportunity` mutation. */
export type DeleteOpportunityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Opportunity` that was deleted by this mutation. */
  opportunity?: Maybe<Opportunity>;
  deletedOpportunityId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
};


/** The output of our delete `Opportunity` mutation. */
export type DeleteOpportunityPayloadopportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the `deleteOpportunity` mutation. */
export type DeleteOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Opportunity` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOpportunityById` mutation. */
export type DeleteOpportunityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Order` mutation. */
export type DeleteOrderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Order` that was deleted by this mutation. */
  order?: Maybe<Order>;
  deletedOrderId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Order`. May be used by Relay 1. */
  orderEdge?: Maybe<OrdersEdge>;
};


/** The output of our delete `Order` mutation. */
export type DeleteOrderPayloadorderEdgeArgs = {
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
};

/** All input for the `deleteOrder` mutation. */
export type DeleteOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Order` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderById` mutation. */
export type DeleteOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Page` mutation. */
export type DeletePagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` that was deleted by this mutation. */
  page?: Maybe<Page>;
  deletedPageId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge?: Maybe<PagesEdge>;
};


/** The output of our delete `Page` mutation. */
export type DeletePagePayloadpageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the `deletePage` mutation. */
export type DeletePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Page` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePageById` mutation. */
export type DeletePageByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Partner` mutation. */
export type DeletePartnerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Partner` that was deleted by this mutation. */
  partner?: Maybe<Partner>;
  deletedPartnerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Partner`. May be used by Relay 1. */
  partnerEdge?: Maybe<PartnersEdge>;
};


/** The output of our delete `Partner` mutation. */
export type DeletePartnerPayloadpartnerEdgeArgs = {
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
};

/** All input for the `deletePartner` mutation. */
export type DeletePartnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Partner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePartnerById` mutation. */
export type DeletePartnerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Payment` mutation. */
export type DeletePaymentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was deleted by this mutation. */
  payment?: Maybe<Payment>;
  deletedPaymentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our delete `Payment` mutation. */
export type DeletePaymentPayloadpaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the `deletePayment` mutation. */
export type DeletePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Payment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePaymentById` mutation. */
export type DeletePaymentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Permission` that was deleted by this mutation. */
  permission?: Maybe<Permission>;
  deletedPermissionId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
};


/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayloadpermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `deletePermission` mutation. */
export type DeletePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePermissionById` mutation. */
export type DeletePermissionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Plugin` mutation. */
export type DeletePluginPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Plugin` that was deleted by this mutation. */
  plugin?: Maybe<Plugin>;
  deletedPluginId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Plugin`. May be used by Relay 1. */
  pluginEdge?: Maybe<PluginsEdge>;
};


/** The output of our delete `Plugin` mutation. */
export type DeletePluginPayloadpluginEdgeArgs = {
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
};

/** All input for the `deletePlugin` mutation. */
export type DeletePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Plugin` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePluginById` mutation. */
export type DeletePluginByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Poll` mutation. */
export type DeletePollPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Poll` that was deleted by this mutation. */
  poll?: Maybe<Poll>;
  deletedPollId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Poll`. May be used by Relay 1. */
  pollEdge?: Maybe<PollsEdge>;
};


/** The output of our delete `Poll` mutation. */
export type DeletePollPayloadpollEdgeArgs = {
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
};

/** All input for the `deletePoll` mutation. */
export type DeletePollInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Poll` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePollById` mutation. */
export type DeletePollByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ProductType` mutation. */
export type DeleteProductTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductType` that was deleted by this mutation. */
  productType?: Maybe<ProductType>;
  deletedProductTypeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductType`. May be used by Relay 1. */
  productTypeEdge?: Maybe<ProductTypesEdge>;
};


/** The output of our delete `ProductType` mutation. */
export type DeleteProductTypePayloadproductTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
};

/** All input for the `deleteProductType` mutation. */
export type DeleteProductTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductTypeById` mutation. */
export type DeleteProductTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Product` mutation. */
export type DeleteProductPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Product` that was deleted by this mutation. */
  product?: Maybe<Product>;
  deletedProductId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Product`. May be used by Relay 1. */
  productEdge?: Maybe<ProductsEdge>;
};


/** The output of our delete `Product` mutation. */
export type DeleteProductPayloadproductEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
};

/** All input for the `deleteProduct` mutation. */
export type DeleteProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Product` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductById` mutation. */
export type DeleteProductByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Project` mutation. */
export type DeleteProjectPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Project` that was deleted by this mutation. */
  project?: Maybe<Project>;
  deletedProjectId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
};


/** The output of our delete `Project` mutation. */
export type DeleteProjectPayloadprojectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the `deleteProject` mutation. */
export type DeleteProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Project` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProjectById` mutation. */
export type DeleteProjectByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Provider` mutation. */
export type DeleteProviderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Provider` that was deleted by this mutation. */
  provider?: Maybe<Provider>;
  deletedProviderId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Provider`. May be used by Relay 1. */
  providerEdge?: Maybe<ProvidersEdge>;
};


/** The output of our delete `Provider` mutation. */
export type DeleteProviderPayloadproviderEdgeArgs = {
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
};

/** All input for the `deleteProvider` mutation. */
export type DeleteProviderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Provider` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProviderById` mutation. */
export type DeleteProviderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Quote` mutation. */
export type DeleteQuotePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was deleted by this mutation. */
  quote?: Maybe<Quote>;
  deletedQuoteId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our delete `Quote` mutation. */
export type DeleteQuotePayloadquoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the `deleteQuote` mutation. */
export type DeleteQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Quote` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteQuoteById` mutation. */
export type DeleteQuoteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Rating` mutation. */
export type DeleteRatingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Rating` that was deleted by this mutation. */
  rating?: Maybe<Rating>;
  deletedRatingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Rating`. May be used by Relay 1. */
  ratingEdge?: Maybe<RatingsEdge>;
};


/** The output of our delete `Rating` mutation. */
export type DeleteRatingPayloadratingEdgeArgs = {
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
};

/** All input for the `deleteRating` mutation. */
export type DeleteRatingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rating` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRatingById` mutation. */
export type DeleteRatingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Report` mutation. */
export type DeleteReportPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Report` that was deleted by this mutation. */
  report?: Maybe<Report>;
  deletedReportId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
};


/** The output of our delete `Report` mutation. */
export type DeleteReportPayloadreportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the `deleteReport` mutation. */
export type DeleteReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Report` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReportById` mutation. */
export type DeleteReportByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Return` mutation. */
export type DeleteReturnPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Return` that was deleted by this mutation. */
  return?: Maybe<Return>;
  deletedReturnId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Return`. May be used by Relay 1. */
  returnEdge?: Maybe<ReturnsEdge>;
};


/** The output of our delete `Return` mutation. */
export type DeleteReturnPayloadreturnEdgeArgs = {
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
};

/** All input for the `deleteReturn` mutation. */
export type DeleteReturnInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Return` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReturnById` mutation. */
export type DeleteReturnByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Review` mutation. */
export type DeleteReviewPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was deleted by this mutation. */
  review?: Maybe<Review>;
  deletedReviewId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our delete `Review` mutation. */
export type DeleteReviewPayloadreviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the `deleteReview` mutation. */
export type DeleteReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Review` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReviewById` mutation. */
export type DeleteReviewByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Reward` mutation. */
export type DeleteRewardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reward` that was deleted by this mutation. */
  reward?: Maybe<Reward>;
  deletedRewardId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Reward`. May be used by Relay 1. */
  rewardEdge?: Maybe<RewardsEdge>;
};


/** The output of our delete `Reward` mutation. */
export type DeleteRewardPayloadrewardEdgeArgs = {
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
};

/** All input for the `deleteReward` mutation. */
export type DeleteRewardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Reward` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRewardById` mutation. */
export type DeleteRewardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Role` mutation. */
export type DeleteRolePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Role` that was deleted by this mutation. */
  role?: Maybe<Role>;
  deletedRoleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our delete `Role` mutation. */
export type DeleteRolePayloadroleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the `deleteRole` mutation. */
export type DeleteRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Role` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRoleById` mutation. */
export type DeleteRoleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Scheduler` mutation. */
export type DeleteSchedulerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Scheduler` that was deleted by this mutation. */
  scheduler?: Maybe<Scheduler>;
  deletedSchedulerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
};


/** The output of our delete `Scheduler` mutation. */
export type DeleteSchedulerPayloadschedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the `deleteScheduler` mutation. */
export type DeleteSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Scheduler` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSchedulerById` mutation. */
export type DeleteSchedulerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Segment` mutation. */
export type DeleteSegmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Segment` that was deleted by this mutation. */
  segment?: Maybe<Segment>;
  deletedSegmentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Segment`. May be used by Relay 1. */
  segmentEdge?: Maybe<SegmentsEdge>;
};


/** The output of our delete `Segment` mutation. */
export type DeleteSegmentPayloadsegmentEdgeArgs = {
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
};

/** All input for the `deleteSegment` mutation. */
export type DeleteSegmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Segment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSegmentById` mutation. */
export type DeleteSegmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Setting` mutation. */
export type DeleteSettingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Setting` that was deleted by this mutation. */
  setting?: Maybe<Setting>;
  deletedSettingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our delete `Setting` mutation. */
export type DeleteSettingPayloadsettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the `deleteSetting` mutation. */
export type DeleteSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Setting` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSettingById` mutation. */
export type DeleteSettingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Shipment` mutation. */
export type DeleteShipmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipment` that was deleted by this mutation. */
  shipment?: Maybe<Shipment>;
  deletedShipmentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Shipment`. May be used by Relay 1. */
  shipmentEdge?: Maybe<ShipmentsEdge>;
};


/** The output of our delete `Shipment` mutation. */
export type DeleteShipmentPayloadshipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
};

/** All input for the `deleteShipment` mutation. */
export type DeleteShipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Shipment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipmentById` mutation. */
export type DeleteShipmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `SpecialDiscount` mutation. */
export type DeleteSpecialDiscountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpecialDiscount` that was deleted by this mutation. */
  specialDiscount?: Maybe<SpecialDiscount>;
  deletedSpecialDiscountId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SpecialDiscount`. May be used by Relay 1. */
  specialDiscountEdge?: Maybe<SpecialDiscountsEdge>;
};


/** The output of our delete `SpecialDiscount` mutation. */
export type DeleteSpecialDiscountPayloadspecialDiscountEdgeArgs = {
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
};

/** All input for the `deleteSpecialDiscount` mutation. */
export type DeleteSpecialDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpecialDiscount` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSpecialDiscountById` mutation. */
export type DeleteSpecialDiscountByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `State` mutation. */
export type DeleteStatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `State` that was deleted by this mutation. */
  state?: Maybe<State>;
  deletedStateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `State`. May be used by Relay 1. */
  stateEdge?: Maybe<StatesEdge>;
};


/** The output of our delete `State` mutation. */
export type DeleteStatePayloadstateEdgeArgs = {
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
};

/** All input for the `deleteState` mutation. */
export type DeleteStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `State` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStateById` mutation. */
export type DeleteStateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Statistic` mutation. */
export type DeleteStatisticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Statistic` that was deleted by this mutation. */
  statistic?: Maybe<Statistic>;
  deletedStatisticId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Statistic`. May be used by Relay 1. */
  statisticEdge?: Maybe<StatisticsEdge>;
};


/** The output of our delete `Statistic` mutation. */
export type DeleteStatisticPayloadstatisticEdgeArgs = {
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
};

/** All input for the `deleteStatistic` mutation. */
export type DeleteStatisticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Statistic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStatisticById` mutation. */
export type DeleteStatisticByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Stock` mutation. */
export type DeleteStockPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Stock` that was deleted by this mutation. */
  stock?: Maybe<Stock>;
  deletedStockId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Stock`. May be used by Relay 1. */
  stockEdge?: Maybe<StocksEdge>;
};


/** The output of our delete `Stock` mutation. */
export type DeleteStockPayloadstockEdgeArgs = {
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
};

/** All input for the `deleteStock` mutation. */
export type DeleteStockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Stock` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStockById` mutation. */
export type DeleteStockByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Survey` mutation. */
export type DeleteSurveyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Survey` that was deleted by this mutation. */
  survey?: Maybe<Survey>;
  deletedSurveyId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Survey`. May be used by Relay 1. */
  surveyEdge?: Maybe<SurveysEdge>;
};


/** The output of our delete `Survey` mutation. */
export type DeleteSurveyPayloadsurveyEdgeArgs = {
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
};

/** All input for the `deleteSurvey` mutation. */
export type DeleteSurveyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Survey` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSurveyById` mutation. */
export type DeleteSurveyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Tag` mutation. */
export type DeleteTagPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Tag` that was deleted by this mutation. */
  tag?: Maybe<Tag>;
  deletedTagId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our delete `Tag` mutation. */
export type DeleteTagPayloadtagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the `deleteTag` mutation. */
export type DeleteTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTagById` mutation. */
export type DeleteTagByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Target` mutation. */
export type DeleteTargetPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Target` that was deleted by this mutation. */
  target?: Maybe<Target>;
  deletedTargetId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Target`. May be used by Relay 1. */
  targetEdge?: Maybe<TargetsEdge>;
};


/** The output of our delete `Target` mutation. */
export type DeleteTargetPayloadtargetEdgeArgs = {
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
};

/** All input for the `deleteTarget` mutation. */
export type DeleteTargetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Target` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTargetById` mutation. */
export type DeleteTargetByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `TaxCategory` mutation. */
export type DeleteTaxCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxCategory` that was deleted by this mutation. */
  taxCategory?: Maybe<TaxCategory>;
  deletedTaxCategoryId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxCategory`. May be used by Relay 1. */
  taxCategoryEdge?: Maybe<TaxCategoriesEdge>;
};


/** The output of our delete `TaxCategory` mutation. */
export type DeleteTaxCategoryPayloadtaxCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
};

/** All input for the `deleteTaxCategory` mutation. */
export type DeleteTaxCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTaxCategoryById` mutation. */
export type DeleteTaxCategoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `TaxRate` mutation. */
export type DeleteTaxRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRate` that was deleted by this mutation. */
  taxRate?: Maybe<TaxRate>;
  deletedTaxRateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRate`. May be used by Relay 1. */
  taxRateEdge?: Maybe<TaxRatesEdge>;
};


/** The output of our delete `TaxRate` mutation. */
export type DeleteTaxRatePayloadtaxRateEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
};

/** All input for the `deleteTaxRate` mutation. */
export type DeleteTaxRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxRate` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTaxRateById` mutation. */
export type DeleteTaxRateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `TaxRule` mutation. */
export type DeleteTaxRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRule` that was deleted by this mutation. */
  taxRule?: Maybe<TaxRule>;
  deletedTaxRuleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRule`. May be used by Relay 1. */
  taxRuleEdge?: Maybe<TaxRulesEdge>;
};


/** The output of our delete `TaxRule` mutation. */
export type DeleteTaxRulePayloadtaxRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
};

/** All input for the `deleteTaxRule` mutation. */
export type DeleteTaxRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxRule` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTaxRuleById` mutation. */
export type DeleteTaxRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was deleted by this mutation. */
  template?: Maybe<Template>;
  deletedTemplateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayloadtemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the `deleteTemplate` mutation. */
export type DeleteTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Template` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTemplateById` mutation. */
export type DeleteTemplateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Theme` mutation. */
export type DeleteThemePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Theme` that was deleted by this mutation. */
  theme?: Maybe<Theme>;
  deletedThemeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Theme`. May be used by Relay 1. */
  themeEdge?: Maybe<ThemesEdge>;
};


/** The output of our delete `Theme` mutation. */
export type DeleteThemePayloadthemeEdgeArgs = {
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
};

/** All input for the `deleteTheme` mutation. */
export type DeleteThemeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Theme` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteThemeById` mutation. */
export type DeleteThemeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Ticketing` mutation. */
export type DeleteTicketingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ticketing` that was deleted by this mutation. */
  ticketing?: Maybe<Ticketing>;
  deletedTicketingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ticketing`. May be used by Relay 1. */
  ticketingEdge?: Maybe<TicketingsEdge>;
};


/** The output of our delete `Ticketing` mutation. */
export type DeleteTicketingPayloadticketingEdgeArgs = {
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
};

/** All input for the `deleteTicketing` mutation. */
export type DeleteTicketingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Ticketing` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTicketingById` mutation. */
export type DeleteTicketingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Training` mutation. */
export type DeleteTrainingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Training` that was deleted by this mutation. */
  training?: Maybe<Training>;
  deletedTrainingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Training`. May be used by Relay 1. */
  trainingEdge?: Maybe<TrainingsEdge>;
};


/** The output of our delete `Training` mutation. */
export type DeleteTrainingPayloadtrainingEdgeArgs = {
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
};

/** All input for the `deleteTraining` mutation. */
export type DeleteTrainingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Training` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTrainingById` mutation. */
export type DeleteTrainingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Transaction` mutation. */
export type DeleteTransactionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was deleted by this mutation. */
  transaction?: Maybe<Transaction>;
  deletedTransactionId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our delete `Transaction` mutation. */
export type DeleteTransactionPayloadtransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the `deleteTransaction` mutation. */
export type DeleteTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Transaction` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTransactionById` mutation. */
export type DeleteTransactionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `UploadFile` mutation. */
export type DeleteUploadFilePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UploadFile` that was deleted by this mutation. */
  uploadFile?: Maybe<UploadFile>;
  deletedUploadFileId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `UploadFile`. May be used by Relay 1. */
  uploadFileEdge?: Maybe<UploadFilesEdge>;
};


/** The output of our delete `UploadFile` mutation. */
export type DeleteUploadFilePayloaduploadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
};

/** All input for the `deleteUploadFile` mutation. */
export type DeleteUploadFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UploadFile` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUploadFileById` mutation. */
export type DeleteUploadFileByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  deletedUserId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloaduserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserById` mutation. */
export type DeleteUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Vendor` mutation. */
export type DeleteVendorPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was deleted by this mutation. */
  vendor?: Maybe<Vendor>;
  deletedVendorId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our delete `Vendor` mutation. */
export type DeleteVendorPayloadvendorEdgeArgs = {
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
};

/** All input for the `deleteVendor` mutation. */
export type DeleteVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vendor` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVendorById` mutation. */
export type DeleteVendorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Visit` mutation. */
export type DeleteVisitPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Visit` that was deleted by this mutation. */
  visit?: Maybe<Visit>;
  deletedVisitId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Visit`. May be used by Relay 1. */
  visitEdge?: Maybe<VisitsEdge>;
};


/** The output of our delete `Visit` mutation. */
export type DeleteVisitPayloadvisitEdgeArgs = {
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
};

/** All input for the `deleteVisit` mutation. */
export type DeleteVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Visit` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVisitById` mutation. */
export type DeleteVisitByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Warehouse` mutation. */
export type DeleteWarehousePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was deleted by this mutation. */
  warehouse?: Maybe<Warehouse>;
  deletedWarehouseId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our delete `Warehouse` mutation. */
export type DeleteWarehousePayloadwarehouseEdgeArgs = {
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
};

/** All input for the `deleteWarehouse` mutation. */
export type DeleteWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Warehouse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWarehouseById` mutation. */
export type DeleteWarehouseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Webhook` mutation. */
export type DeleteWebhookPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Webhook` that was deleted by this mutation. */
  webhook?: Maybe<Webhook>;
  deletedWebhookId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Webhook`. May be used by Relay 1. */
  webhookEdge?: Maybe<WebhooksEdge>;
};


/** The output of our delete `Webhook` mutation. */
export type DeleteWebhookPayloadwebhookEdgeArgs = {
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
};

/** All input for the `deleteWebhook` mutation. */
export type DeleteWebhookInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Webhook` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWebhookById` mutation. */
export type DeleteWebhookByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Website` mutation. */
export type DeleteWebsitePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Website` that was deleted by this mutation. */
  website?: Maybe<Website>;
  deletedWebsiteId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Website`. May be used by Relay 1. */
  websiteEdge?: Maybe<WebsitesEdge>;
};


/** The output of our delete `Website` mutation. */
export type DeleteWebsitePayloadwebsiteEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
};

/** All input for the `deleteWebsite` mutation. */
export type DeleteWebsiteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Website` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWebsiteById` mutation. */
export type DeleteWebsiteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Wishlist` mutation. */
export type DeleteWishlistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Wishlist` that was deleted by this mutation. */
  wishlist?: Maybe<Wishlist>;
  deletedWishlistId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Wishlist`. May be used by Relay 1. */
  wishlistEdge?: Maybe<WishlistsEdge>;
};


/** The output of our delete `Wishlist` mutation. */
export type DeleteWishlistPayloadwishlistEdgeArgs = {
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
};

/** All input for the `deleteWishlist` mutation. */
export type DeleteWishlistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Wishlist` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWishlistById` mutation. */
export type DeleteWishlistByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Workspace` mutation. */
export type DeleteWorkspacePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Workspace` that was deleted by this mutation. */
  workspace?: Maybe<Workspace>;
  deletedWorkspaceId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Workspace`. May be used by Relay 1. */
  workspaceEdge?: Maybe<WorkspacesEdge>;
};


/** The output of our delete `Workspace` mutation. */
export type DeleteWorkspacePayloadworkspaceEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
};

/** All input for the `deleteWorkspace` mutation. */
export type DeleteWorkspaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Workspace` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWorkspaceById` mutation. */
export type DeleteWorkspaceByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Zone` mutation. */
export type DeleteZonePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Zone` that was deleted by this mutation. */
  zone?: Maybe<Zone>;
  deletedZoneId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Zone`. May be used by Relay 1. */
  zoneEdge?: Maybe<ZonesEdge>;
};


/** The output of our delete `Zone` mutation. */
export type DeleteZonePayloadzoneEdgeArgs = {
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
};

/** All input for the `deleteZone` mutation. */
export type DeleteZoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Zone` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteZoneById` mutation. */
export type DeleteZoneByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type Subscription = {
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form. (live)
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live) */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. (live) */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `Account`. (live) */
  allAccounts?: Maybe<AccountsConnection>;
  /** Reads a set of `Account`. (live) */
  allAccountsList?: Maybe<Array<Account>>;
  /** Reads and enables pagination through a set of `Agreement`. (live) */
  allAgreements?: Maybe<AgreementsConnection>;
  /** Reads a set of `Agreement`. (live) */
  allAgreementsList?: Maybe<Array<Agreement>>;
  /** Reads and enables pagination through a set of `Analytic`. (live) */
  allAnalytics?: Maybe<AnalyticsConnection>;
  /** Reads a set of `Analytic`. (live) */
  allAnalyticsList?: Maybe<Array<Analytic>>;
  /** Reads and enables pagination through a set of `Apitoken`. (live) */
  allApitokens?: Maybe<ApitokensConnection>;
  /** Reads a set of `Apitoken`. (live) */
  allApitokensList?: Maybe<Array<Apitoken>>;
  /** Reads and enables pagination through a set of `Article`. (live) */
  allArticles?: Maybe<ArticlesConnection>;
  /** Reads a set of `Article`. (live) */
  allArticlesList?: Maybe<Array<Article>>;
  /** Reads and enables pagination through a set of `Attribute`. (live) */
  allAttributes?: Maybe<AttributesConnection>;
  /** Reads a set of `Attribute`. (live) */
  allAttributesList?: Maybe<Array<Attribute>>;
  /** Reads and enables pagination through a set of `Brand`. (live) */
  allBrands?: Maybe<BrandsConnection>;
  /** Reads a set of `Brand`. (live) */
  allBrandsList?: Maybe<Array<Brand>>;
  /** Reads and enables pagination through a set of `CartPriceRule`. (live) */
  allCartPriceRules?: Maybe<CartPriceRulesConnection>;
  /** Reads a set of `CartPriceRule`. (live) */
  allCartPriceRulesList?: Maybe<Array<CartPriceRule>>;
  /** Reads and enables pagination through a set of `Case`. (live) */
  allCases?: Maybe<CasesConnection>;
  /** Reads a set of `Case`. (live) */
  allCasesList?: Maybe<Array<Case>>;
  /** Reads and enables pagination through a set of `CatalogPriceRule`. (live) */
  allCatalogPriceRules?: Maybe<CatalogPriceRulesConnection>;
  /** Reads a set of `CatalogPriceRule`. (live) */
  allCatalogPriceRulesList?: Maybe<Array<CatalogPriceRule>>;
  /** Reads and enables pagination through a set of `Category`. (live) */
  allCategories?: Maybe<CategoriesConnection>;
  /** Reads a set of `Category`. (live) */
  allCategoriesList?: Maybe<Array<Category>>;
  /** Reads and enables pagination through a set of `Channel`. (live) */
  allChannels?: Maybe<ChannelsConnection>;
  /** Reads a set of `Channel`. (live) */
  allChannelsList?: Maybe<Array<Channel>>;
  /** Reads and enables pagination through a set of `Checklist`. (live) */
  allChecklists?: Maybe<ChecklistsConnection>;
  /** Reads a set of `Checklist`. (live) */
  allChecklistsList?: Maybe<Array<Checklist>>;
  /** Reads and enables pagination through a set of `City`. (live) */
  allCities?: Maybe<CitiesConnection>;
  /** Reads a set of `City`. (live) */
  allCitiesList?: Maybe<Array<City>>;
  /** Reads and enables pagination through a set of `Collection`. (live) */
  allCollections?: Maybe<CollectionsConnection>;
  /** Reads a set of `Collection`. (live) */
  allCollectionsList?: Maybe<Array<Collection>>;
  /** Reads and enables pagination through a set of `Comment`. (live) */
  allComments?: Maybe<CommentsConnection>;
  /** Reads a set of `Comment`. (live) */
  allCommentsList?: Maybe<Array<Comment>>;
  /** Reads and enables pagination through a set of `ContentType`. (live) */
  allContentTypes?: Maybe<ContentTypesConnection>;
  /** Reads a set of `ContentType`. (live) */
  allContentTypesList?: Maybe<Array<ContentType>>;
  /** Reads and enables pagination through a set of `Contract`. (live) */
  allContracts?: Maybe<ContractsConnection>;
  /** Reads a set of `Contract`. (live) */
  allContractsList?: Maybe<Array<Contract>>;
  /** Reads and enables pagination through a set of `Country`. (live) */
  allCountries?: Maybe<CountriesConnection>;
  /** Reads a set of `Country`. (live) */
  allCountriesList?: Maybe<Array<Country>>;
  /** Reads and enables pagination through a set of `Coupon`. (live) */
  allCoupons?: Maybe<CouponsConnection>;
  /** Reads a set of `Coupon`. (live) */
  allCouponsList?: Maybe<Array<Coupon>>;
  /** Reads and enables pagination through a set of `CreditMemo`. (live) */
  allCreditMemos?: Maybe<CreditMemosConnection>;
  /** Reads a set of `CreditMemo`. (live) */
  allCreditMemosList?: Maybe<Array<CreditMemo>>;
  /** Reads and enables pagination through a set of `Currency`. (live) */
  allCurrencies?: Maybe<CurrenciesConnection>;
  /** Reads a set of `Currency`. (live) */
  allCurrenciesList?: Maybe<Array<Currency>>;
  /** Reads and enables pagination through a set of `CurrencyRate`. (live) */
  allCurrencyRates?: Maybe<CurrencyRatesConnection>;
  /** Reads a set of `CurrencyRate`. (live) */
  allCurrencyRatesList?: Maybe<Array<CurrencyRate>>;
  /** Reads and enables pagination through a set of `CurrencySymbol`. (live) */
  allCurrencySymbols?: Maybe<CurrencySymbolsConnection>;
  /** Reads a set of `CurrencySymbol`. (live) */
  allCurrencySymbolsList?: Maybe<Array<CurrencySymbol>>;
  /** Reads and enables pagination through a set of `CustomerGroup`. (live) */
  allCustomerGroups?: Maybe<CustomerGroupsConnection>;
  /** Reads a set of `CustomerGroup`. (live) */
  allCustomerGroupsList?: Maybe<Array<CustomerGroup>>;
  /** Reads and enables pagination through a set of `Customer`. (live) */
  allCustomers?: Maybe<CustomersConnection>;
  /** Reads a set of `Customer`. (live) */
  allCustomersList?: Maybe<Array<Customer>>;
  /** Reads and enables pagination through a set of `Customization`. (live) */
  allCustomizations?: Maybe<CustomizationsConnection>;
  /** Reads a set of `Customization`. (live) */
  allCustomizationsList?: Maybe<Array<Customization>>;
  /** Reads and enables pagination through a set of `Dashboard`. (live) */
  allDashboards?: Maybe<DashboardsConnection>;
  /** Reads a set of `Dashboard`. (live) */
  allDashboardsList?: Maybe<Array<Dashboard>>;
  /** Reads and enables pagination through a set of `Deepdive`. (live) */
  allDeepdives?: Maybe<DeepdivesConnection>;
  /** Reads a set of `Deepdive`. (live) */
  allDeepdivesList?: Maybe<Array<Deepdive>>;
  /** Reads and enables pagination through a set of `Digiboard`. (live) */
  allDigiboards?: Maybe<DigiboardsConnection>;
  /** Reads a set of `Digiboard`. (live) */
  allDigiboardsList?: Maybe<Array<Digiboard>>;
  /** Reads and enables pagination through a set of `Email`. (live) */
  allEmails?: Maybe<EmailsConnection>;
  /** Reads a set of `Email`. (live) */
  allEmailsList?: Maybe<Array<Email>>;
  /** Reads and enables pagination through a set of `Endofshift`. (live) */
  allEndofshifts?: Maybe<EndofshiftsConnection>;
  /** Reads a set of `Endofshift`. (live) */
  allEndofshiftsList?: Maybe<Array<Endofshift>>;
  /** Reads and enables pagination through a set of `Event`. (live) */
  allEvents?: Maybe<EventsConnection>;
  /** Reads a set of `Event`. (live) */
  allEventsList?: Maybe<Array<Event>>;
  /** Reads and enables pagination through a set of `Fullfillment`. (live) */
  allFullfillments?: Maybe<FullfillmentsConnection>;
  /** Reads a set of `Fullfillment`. (live) */
  allFullfillmentsList?: Maybe<Array<Fullfillment>>;
  /** Reads and enables pagination through a set of `GiftCertificate`. (live) */
  allGiftCertificates?: Maybe<GiftCertificatesConnection>;
  /** Reads a set of `GiftCertificate`. (live) */
  allGiftCertificatesList?: Maybe<Array<GiftCertificate>>;
  /** Reads and enables pagination through a set of `Glossary`. (live) */
  allGlossaries?: Maybe<GlossariesConnection>;
  /** Reads a set of `Glossary`. (live) */
  allGlossariesList?: Maybe<Array<Glossary>>;
  /** Reads and enables pagination through a set of `Importm`. (live) */
  allImportms?: Maybe<ImportmsConnection>;
  /** Reads a set of `Importm`. (live) */
  allImportmsList?: Maybe<Array<Importm>>;
  /** Reads and enables pagination through a set of `Integration`. (live) */
  allIntegrations?: Maybe<IntegrationsConnection>;
  /** Reads a set of `Integration`. (live) */
  allIntegrationsList?: Maybe<Array<Integration>>;
  /** Reads and enables pagination through a set of `Internalization`. (live) */
  allInternalizations?: Maybe<InternalizationsConnection>;
  /** Reads a set of `Internalization`. (live) */
  allInternalizationsList?: Maybe<Array<Internalization>>;
  /** Reads and enables pagination through a set of `Invitation`. (live) */
  allInvitations?: Maybe<InvitationsConnection>;
  /** Reads a set of `Invitation`. (live) */
  allInvitationsList?: Maybe<Array<Invitation>>;
  /** Reads and enables pagination through a set of `Invoice`. (live) */
  allInvoices?: Maybe<InvoicesConnection>;
  /** Reads a set of `Invoice`. (live) */
  allInvoicesList?: Maybe<Array<Invoice>>;
  /** Reads and enables pagination through a set of `Lead`. (live) */
  allLeads?: Maybe<LeadsConnection>;
  /** Reads a set of `Lead`. (live) */
  allLeadsList?: Maybe<Array<Lead>>;
  /** Reads and enables pagination through a set of `Manufacturer`. (live) */
  allManufacturers?: Maybe<ManufacturersConnection>;
  /** Reads a set of `Manufacturer`. (live) */
  allManufacturersList?: Maybe<Array<Manufacturer>>;
  /** Reads and enables pagination through a set of `Mediamanager`. (live) */
  allMediamanagers?: Maybe<MediamanagersConnection>;
  /** Reads a set of `Mediamanager`. (live) */
  allMediamanagersList?: Maybe<Array<Mediamanager>>;
  /** Reads and enables pagination through a set of `Meeting`. (live) */
  allMeetings?: Maybe<MeetingsConnection>;
  /** Reads a set of `Meeting`. (live) */
  allMeetingsList?: Maybe<Array<Meeting>>;
  /** Reads and enables pagination through a set of `Message`. (live) */
  allMessages?: Maybe<MessagesConnection>;
  /** Reads a set of `Message`. (live) */
  allMessagesList?: Maybe<Array<Message>>;
  /** Reads and enables pagination through a set of `Newsletter`. (live) */
  allNewsletters?: Maybe<NewslettersConnection>;
  /** Reads a set of `Newsletter`. (live) */
  allNewslettersList?: Maybe<Array<Newsletter>>;
  /** Reads and enables pagination through a set of `Ooto`. (live) */
  allOotos?: Maybe<OotosConnection>;
  /** Reads a set of `Ooto`. (live) */
  allOotosList?: Maybe<Array<Ooto>>;
  /** Reads and enables pagination through a set of `Opportunity`. (live) */
  allOpportunities?: Maybe<OpportunitiesConnection>;
  /** Reads a set of `Opportunity`. (live) */
  allOpportunitiesList?: Maybe<Array<Opportunity>>;
  /** Reads and enables pagination through a set of `Order`. (live) */
  allOrders?: Maybe<OrdersConnection>;
  /** Reads a set of `Order`. (live) */
  allOrdersList?: Maybe<Array<Order>>;
  /** Reads and enables pagination through a set of `Page`. (live) */
  allPages?: Maybe<PagesConnection>;
  /** Reads a set of `Page`. (live) */
  allPagesList?: Maybe<Array<Page>>;
  /** Reads and enables pagination through a set of `Partner`. (live) */
  allPartners?: Maybe<PartnersConnection>;
  /** Reads a set of `Partner`. (live) */
  allPartnersList?: Maybe<Array<Partner>>;
  /** Reads and enables pagination through a set of `Payment`. (live) */
  allPayments?: Maybe<PaymentsConnection>;
  /** Reads a set of `Payment`. (live) */
  allPaymentsList?: Maybe<Array<Payment>>;
  /** Reads and enables pagination through a set of `Permission`. (live) */
  allPermissions?: Maybe<PermissionsConnection>;
  /** Reads a set of `Permission`. (live) */
  allPermissionsList?: Maybe<Array<Permission>>;
  /** Reads and enables pagination through a set of `Plugin`. (live) */
  allPlugins?: Maybe<PluginsConnection>;
  /** Reads a set of `Plugin`. (live) */
  allPluginsList?: Maybe<Array<Plugin>>;
  /** Reads and enables pagination through a set of `Poll`. (live) */
  allPolls?: Maybe<PollsConnection>;
  /** Reads a set of `Poll`. (live) */
  allPollsList?: Maybe<Array<Poll>>;
  /** Reads and enables pagination through a set of `ProductType`. (live) */
  allProductTypes?: Maybe<ProductTypesConnection>;
  /** Reads a set of `ProductType`. (live) */
  allProductTypesList?: Maybe<Array<ProductType>>;
  /** Reads and enables pagination through a set of `Product`. (live) */
  allProducts?: Maybe<ProductsConnection>;
  /** Reads a set of `Product`. (live) */
  allProductsList?: Maybe<Array<Product>>;
  /** Reads and enables pagination through a set of `Project`. (live) */
  allProjects?: Maybe<ProjectsConnection>;
  /** Reads a set of `Project`. (live) */
  allProjectsList?: Maybe<Array<Project>>;
  /** Reads and enables pagination through a set of `Provider`. (live) */
  allProviders?: Maybe<ProvidersConnection>;
  /** Reads a set of `Provider`. (live) */
  allProvidersList?: Maybe<Array<Provider>>;
  /** Reads and enables pagination through a set of `Quote`. (live) */
  allQuotes?: Maybe<QuotesConnection>;
  /** Reads a set of `Quote`. (live) */
  allQuotesList?: Maybe<Array<Quote>>;
  /** Reads and enables pagination through a set of `Rating`. (live) */
  allRatings?: Maybe<RatingsConnection>;
  /** Reads a set of `Rating`. (live) */
  allRatingsList?: Maybe<Array<Rating>>;
  /** Reads and enables pagination through a set of `Report`. (live) */
  allReports?: Maybe<ReportsConnection>;
  /** Reads a set of `Report`. (live) */
  allReportsList?: Maybe<Array<Report>>;
  /** Reads and enables pagination through a set of `Return`. (live) */
  allReturns?: Maybe<ReturnsConnection>;
  /** Reads a set of `Return`. (live) */
  allReturnsList?: Maybe<Array<Return>>;
  /** Reads and enables pagination through a set of `Review`. (live) */
  allReviews?: Maybe<ReviewsConnection>;
  /** Reads a set of `Review`. (live) */
  allReviewsList?: Maybe<Array<Review>>;
  /** Reads and enables pagination through a set of `Reward`. (live) */
  allRewards?: Maybe<RewardsConnection>;
  /** Reads a set of `Reward`. (live) */
  allRewardsList?: Maybe<Array<Reward>>;
  /** Reads and enables pagination through a set of `Role`. (live) */
  allRoles?: Maybe<RolesConnection>;
  /** Reads a set of `Role`. (live) */
  allRolesList?: Maybe<Array<Role>>;
  /** Reads and enables pagination through a set of `Scheduler`. (live) */
  allSchedulers?: Maybe<SchedulersConnection>;
  /** Reads a set of `Scheduler`. (live) */
  allSchedulersList?: Maybe<Array<Scheduler>>;
  /** Reads and enables pagination through a set of `Segment`. (live) */
  allSegments?: Maybe<SegmentsConnection>;
  /** Reads a set of `Segment`. (live) */
  allSegmentsList?: Maybe<Array<Segment>>;
  /** Reads and enables pagination through a set of `Setting`. (live) */
  allSettings?: Maybe<SettingsConnection>;
  /** Reads a set of `Setting`. (live) */
  allSettingsList?: Maybe<Array<Setting>>;
  /** Reads and enables pagination through a set of `Shipment`. (live) */
  allShipments?: Maybe<ShipmentsConnection>;
  /** Reads a set of `Shipment`. (live) */
  allShipmentsList?: Maybe<Array<Shipment>>;
  /** Reads and enables pagination through a set of `SpecialDiscount`. (live) */
  allSpecialDiscounts?: Maybe<SpecialDiscountsConnection>;
  /** Reads a set of `SpecialDiscount`. (live) */
  allSpecialDiscountsList?: Maybe<Array<SpecialDiscount>>;
  /** Reads and enables pagination through a set of `State`. (live) */
  allStates?: Maybe<StatesConnection>;
  /** Reads a set of `State`. (live) */
  allStatesList?: Maybe<Array<State>>;
  /** Reads and enables pagination through a set of `Statistic`. (live) */
  allStatistics?: Maybe<StatisticsConnection>;
  /** Reads a set of `Statistic`. (live) */
  allStatisticsList?: Maybe<Array<Statistic>>;
  /** Reads and enables pagination through a set of `Stock`. (live) */
  allStocks?: Maybe<StocksConnection>;
  /** Reads a set of `Stock`. (live) */
  allStocksList?: Maybe<Array<Stock>>;
  /** Reads and enables pagination through a set of `Survey`. (live) */
  allSurveys?: Maybe<SurveysConnection>;
  /** Reads a set of `Survey`. (live) */
  allSurveysList?: Maybe<Array<Survey>>;
  /** Reads and enables pagination through a set of `Tag`. (live) */
  allTags?: Maybe<TagsConnection>;
  /** Reads a set of `Tag`. (live) */
  allTagsList?: Maybe<Array<Tag>>;
  /** Reads and enables pagination through a set of `Target`. (live) */
  allTargets?: Maybe<TargetsConnection>;
  /** Reads a set of `Target`. (live) */
  allTargetsList?: Maybe<Array<Target>>;
  /** Reads and enables pagination through a set of `TaxCategory`. (live) */
  allTaxCategories?: Maybe<TaxCategoriesConnection>;
  /** Reads a set of `TaxCategory`. (live) */
  allTaxCategoriesList?: Maybe<Array<TaxCategory>>;
  /** Reads and enables pagination through a set of `TaxRate`. (live) */
  allTaxRates?: Maybe<TaxRatesConnection>;
  /** Reads a set of `TaxRate`. (live) */
  allTaxRatesList?: Maybe<Array<TaxRate>>;
  /** Reads and enables pagination through a set of `TaxRule`. (live) */
  allTaxRules?: Maybe<TaxRulesConnection>;
  /** Reads a set of `TaxRule`. (live) */
  allTaxRulesList?: Maybe<Array<TaxRule>>;
  /** Reads and enables pagination through a set of `Template`. (live) */
  allTemplates?: Maybe<TemplatesConnection>;
  /** Reads a set of `Template`. (live) */
  allTemplatesList?: Maybe<Array<Template>>;
  /** Reads and enables pagination through a set of `Theme`. (live) */
  allThemes?: Maybe<ThemesConnection>;
  /** Reads a set of `Theme`. (live) */
  allThemesList?: Maybe<Array<Theme>>;
  /** Reads and enables pagination through a set of `Ticketing`. (live) */
  allTicketings?: Maybe<TicketingsConnection>;
  /** Reads a set of `Ticketing`. (live) */
  allTicketingsList?: Maybe<Array<Ticketing>>;
  /** Reads and enables pagination through a set of `Training`. (live) */
  allTrainings?: Maybe<TrainingsConnection>;
  /** Reads a set of `Training`. (live) */
  allTrainingsList?: Maybe<Array<Training>>;
  /** Reads and enables pagination through a set of `Transaction`. (live) */
  allTransactions?: Maybe<TransactionsConnection>;
  /** Reads a set of `Transaction`. (live) */
  allTransactionsList?: Maybe<Array<Transaction>>;
  /** Reads and enables pagination through a set of `UploadFile`. (live) */
  allUploadFiles?: Maybe<UploadFilesConnection>;
  /** Reads a set of `UploadFile`. (live) */
  allUploadFilesList?: Maybe<Array<UploadFile>>;
  /** Reads and enables pagination through a set of `User`. (live) */
  allUsers?: Maybe<UsersConnection>;
  /** Reads a set of `User`. (live) */
  allUsersList?: Maybe<Array<User>>;
  /** Reads and enables pagination through a set of `Vendor`. (live) */
  allVendors?: Maybe<VendorsConnection>;
  /** Reads a set of `Vendor`. (live) */
  allVendorsList?: Maybe<Array<Vendor>>;
  /** Reads and enables pagination through a set of `Visit`. (live) */
  allVisits?: Maybe<VisitsConnection>;
  /** Reads a set of `Visit`. (live) */
  allVisitsList?: Maybe<Array<Visit>>;
  /** Reads and enables pagination through a set of `Warehouse`. (live) */
  allWarehouses?: Maybe<WarehousesConnection>;
  /** Reads a set of `Warehouse`. (live) */
  allWarehousesList?: Maybe<Array<Warehouse>>;
  /** Reads and enables pagination through a set of `Webhook`. (live) */
  allWebhooks?: Maybe<WebhooksConnection>;
  /** Reads a set of `Webhook`. (live) */
  allWebhooksList?: Maybe<Array<Webhook>>;
  /** Reads and enables pagination through a set of `Website`. (live) */
  allWebsites?: Maybe<WebsitesConnection>;
  /** Reads a set of `Website`. (live) */
  allWebsitesList?: Maybe<Array<Website>>;
  /** Reads and enables pagination through a set of `Wishlist`. (live) */
  allWishlists?: Maybe<WishlistsConnection>;
  /** Reads a set of `Wishlist`. (live) */
  allWishlistsList?: Maybe<Array<Wishlist>>;
  /** Reads and enables pagination through a set of `Workspace`. (live) */
  allWorkspaces?: Maybe<WorkspacesConnection>;
  /** Reads a set of `Workspace`. (live) */
  allWorkspacesList?: Maybe<Array<Workspace>>;
  /** Reads and enables pagination through a set of `Zone`. (live) */
  allZones?: Maybe<ZonesConnection>;
  /** Reads a set of `Zone`. (live) */
  allZonesList?: Maybe<Array<Zone>>;
  /**  (live) */
  accountById?: Maybe<Account>;
  /**  (live) */
  agreementById?: Maybe<Agreement>;
  /**  (live) */
  analyticById?: Maybe<Analytic>;
  /**  (live) */
  apitokenById?: Maybe<Apitoken>;
  /**  (live) */
  articleById?: Maybe<Article>;
  /**  (live) */
  attributeById?: Maybe<Attribute>;
  /**  (live) */
  brandById?: Maybe<Brand>;
  /**  (live) */
  cartPriceRuleById?: Maybe<CartPriceRule>;
  /**  (live) */
  caseById?: Maybe<Case>;
  /**  (live) */
  catalogPriceRuleById?: Maybe<CatalogPriceRule>;
  /**  (live) */
  categoryById?: Maybe<Category>;
  /**  (live) */
  channelById?: Maybe<Channel>;
  /**  (live) */
  checklistById?: Maybe<Checklist>;
  /**  (live) */
  cityById?: Maybe<City>;
  /**  (live) */
  collectionById?: Maybe<Collection>;
  /**  (live) */
  commentById?: Maybe<Comment>;
  /**  (live) */
  contentTypeById?: Maybe<ContentType>;
  /**  (live) */
  contractById?: Maybe<Contract>;
  /**  (live) */
  countryById?: Maybe<Country>;
  /**  (live) */
  couponById?: Maybe<Coupon>;
  /**  (live) */
  creditMemoByCreditMemoAndId?: Maybe<CreditMemo>;
  /**  (live) */
  currencyById?: Maybe<Currency>;
  /**  (live) */
  currencyRateByImportService?: Maybe<CurrencyRate>;
  /**  (live) */
  currencySymbolBySymbol?: Maybe<CurrencySymbol>;
  /**  (live) */
  customerGroupById?: Maybe<CustomerGroup>;
  /**  (live) */
  customerById?: Maybe<Customer>;
  /**  (live) */
  customizationById?: Maybe<Customization>;
  /**  (live) */
  dashboardById?: Maybe<Dashboard>;
  /**  (live) */
  deepdiveById?: Maybe<Deepdive>;
  /**  (live) */
  digiboardById?: Maybe<Digiboard>;
  /**  (live) */
  emailById?: Maybe<Email>;
  /**  (live) */
  endofshiftById?: Maybe<Endofshift>;
  /**  (live) */
  eventById?: Maybe<Event>;
  /**  (live) */
  fullfillmentById?: Maybe<Fullfillment>;
  /**  (live) */
  giftCertificateById?: Maybe<GiftCertificate>;
  /**  (live) */
  glossaryById?: Maybe<Glossary>;
  /**  (live) */
  importmById?: Maybe<Importm>;
  /**  (live) */
  integrationById?: Maybe<Integration>;
  /**  (live) */
  internalizationById?: Maybe<Internalization>;
  /**  (live) */
  invitationById?: Maybe<Invitation>;
  /**  (live) */
  invoiceById?: Maybe<Invoice>;
  /**  (live) */
  leadById?: Maybe<Lead>;
  /**  (live) */
  manufacturerById?: Maybe<Manufacturer>;
  /**  (live) */
  mediamanagerById?: Maybe<Mediamanager>;
  /**  (live) */
  meetingById?: Maybe<Meeting>;
  /**  (live) */
  messageById?: Maybe<Message>;
  /**  (live) */
  newsletterById?: Maybe<Newsletter>;
  /**  (live) */
  ootoById?: Maybe<Ooto>;
  /**  (live) */
  opportunityById?: Maybe<Opportunity>;
  /**  (live) */
  orderById?: Maybe<Order>;
  /**  (live) */
  pageById?: Maybe<Page>;
  /**  (live) */
  partnerById?: Maybe<Partner>;
  /**  (live) */
  paymentById?: Maybe<Payment>;
  /**  (live) */
  permissionById?: Maybe<Permission>;
  /**  (live) */
  pluginById?: Maybe<Plugin>;
  /**  (live) */
  pollById?: Maybe<Poll>;
  /**  (live) */
  productTypeById?: Maybe<ProductType>;
  /**  (live) */
  productById?: Maybe<Product>;
  /**  (live) */
  projectById?: Maybe<Project>;
  /**  (live) */
  providerById?: Maybe<Provider>;
  /**  (live) */
  quoteById?: Maybe<Quote>;
  /**  (live) */
  ratingById?: Maybe<Rating>;
  /**  (live) */
  reportById?: Maybe<Report>;
  /**  (live) */
  returnById?: Maybe<Return>;
  /**  (live) */
  reviewById?: Maybe<Review>;
  /**  (live) */
  rewardById?: Maybe<Reward>;
  /**  (live) */
  roleById?: Maybe<Role>;
  /**  (live) */
  schedulerById?: Maybe<Scheduler>;
  /**  (live) */
  segmentById?: Maybe<Segment>;
  /**  (live) */
  settingById?: Maybe<Setting>;
  /**  (live) */
  shipmentById?: Maybe<Shipment>;
  /**  (live) */
  specialDiscountById?: Maybe<SpecialDiscount>;
  /**  (live) */
  stateById?: Maybe<State>;
  /**  (live) */
  statisticById?: Maybe<Statistic>;
  /**  (live) */
  stockById?: Maybe<Stock>;
  /**  (live) */
  surveyById?: Maybe<Survey>;
  /**  (live) */
  tagById?: Maybe<Tag>;
  /**  (live) */
  targetById?: Maybe<Target>;
  /**  (live) */
  taxCategoryById?: Maybe<TaxCategory>;
  /**  (live) */
  taxRateById?: Maybe<TaxRate>;
  /**  (live) */
  taxRuleById?: Maybe<TaxRule>;
  /**  (live) */
  templateById?: Maybe<Template>;
  /**  (live) */
  themeById?: Maybe<Theme>;
  /**  (live) */
  ticketingById?: Maybe<Ticketing>;
  /**  (live) */
  trainingById?: Maybe<Training>;
  /**  (live) */
  transactionById?: Maybe<Transaction>;
  /**  (live) */
  uploadFileById?: Maybe<UploadFile>;
  /**  (live) */
  userById?: Maybe<User>;
  /**  (live) */
  vendorById?: Maybe<Vendor>;
  /**  (live) */
  visitById?: Maybe<Visit>;
  /**  (live) */
  warehouseById?: Maybe<Warehouse>;
  /**  (live) */
  webhookById?: Maybe<Webhook>;
  /**  (live) */
  websiteById?: Maybe<Website>;
  /**  (live) */
  wishlistById?: Maybe<Wishlist>;
  /**  (live) */
  workspaceById?: Maybe<Workspace>;
  /**  (live) */
  zoneById?: Maybe<Zone>;
  /** Reads a single `Account` using its globally unique `ID`. (live) */
  account?: Maybe<Account>;
  /** Reads a single `Agreement` using its globally unique `ID`. (live) */
  agreement?: Maybe<Agreement>;
  /** Reads a single `Analytic` using its globally unique `ID`. (live) */
  analytic?: Maybe<Analytic>;
  /** Reads a single `Apitoken` using its globally unique `ID`. (live) */
  apitoken?: Maybe<Apitoken>;
  /** Reads a single `Article` using its globally unique `ID`. (live) */
  article?: Maybe<Article>;
  /** Reads a single `Attribute` using its globally unique `ID`. (live) */
  attribute?: Maybe<Attribute>;
  /** Reads a single `Brand` using its globally unique `ID`. (live) */
  brand?: Maybe<Brand>;
  /** Reads a single `CartPriceRule` using its globally unique `ID`. (live) */
  cartPriceRule?: Maybe<CartPriceRule>;
  /** Reads a single `Case` using its globally unique `ID`. (live) */
  case?: Maybe<Case>;
  /** Reads a single `CatalogPriceRule` using its globally unique `ID`. (live) */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  /** Reads a single `Category` using its globally unique `ID`. (live) */
  category?: Maybe<Category>;
  /** Reads a single `Channel` using its globally unique `ID`. (live) */
  channel?: Maybe<Channel>;
  /** Reads a single `Checklist` using its globally unique `ID`. (live) */
  checklist?: Maybe<Checklist>;
  /** Reads a single `City` using its globally unique `ID`. (live) */
  city?: Maybe<City>;
  /** Reads a single `Collection` using its globally unique `ID`. (live) */
  collection?: Maybe<Collection>;
  /** Reads a single `Comment` using its globally unique `ID`. (live) */
  comment?: Maybe<Comment>;
  /** Reads a single `ContentType` using its globally unique `ID`. (live) */
  contentType?: Maybe<ContentType>;
  /** Reads a single `Contract` using its globally unique `ID`. (live) */
  contract?: Maybe<Contract>;
  /** Reads a single `Country` using its globally unique `ID`. (live) */
  country?: Maybe<Country>;
  /** Reads a single `Coupon` using its globally unique `ID`. (live) */
  coupon?: Maybe<Coupon>;
  /** Reads a single `CreditMemo` using its globally unique `ID`. (live) */
  creditMemo?: Maybe<CreditMemo>;
  /** Reads a single `Currency` using its globally unique `ID`. (live) */
  currency?: Maybe<Currency>;
  /** Reads a single `CurrencyRate` using its globally unique `ID`. (live) */
  currencyRate?: Maybe<CurrencyRate>;
  /** Reads a single `CurrencySymbol` using its globally unique `ID`. (live) */
  currencySymbol?: Maybe<CurrencySymbol>;
  /** Reads a single `CustomerGroup` using its globally unique `ID`. (live) */
  customerGroup?: Maybe<CustomerGroup>;
  /** Reads a single `Customer` using its globally unique `ID`. (live) */
  customer?: Maybe<Customer>;
  /** Reads a single `Customization` using its globally unique `ID`. (live) */
  customization?: Maybe<Customization>;
  /** Reads a single `Dashboard` using its globally unique `ID`. (live) */
  dashboard?: Maybe<Dashboard>;
  /** Reads a single `Deepdive` using its globally unique `ID`. (live) */
  deepdive?: Maybe<Deepdive>;
  /** Reads a single `Digiboard` using its globally unique `ID`. (live) */
  digiboard?: Maybe<Digiboard>;
  /** Reads a single `Email` using its globally unique `ID`. (live) */
  email?: Maybe<Email>;
  /** Reads a single `Endofshift` using its globally unique `ID`. (live) */
  endofshift?: Maybe<Endofshift>;
  /** Reads a single `Event` using its globally unique `ID`. (live) */
  event?: Maybe<Event>;
  /** Reads a single `Fullfillment` using its globally unique `ID`. (live) */
  fullfillment?: Maybe<Fullfillment>;
  /** Reads a single `GiftCertificate` using its globally unique `ID`. (live) */
  giftCertificate?: Maybe<GiftCertificate>;
  /** Reads a single `Glossary` using its globally unique `ID`. (live) */
  glossary?: Maybe<Glossary>;
  /** Reads a single `Importm` using its globally unique `ID`. (live) */
  importm?: Maybe<Importm>;
  /** Reads a single `Integration` using its globally unique `ID`. (live) */
  integration?: Maybe<Integration>;
  /** Reads a single `Internalization` using its globally unique `ID`. (live) */
  internalization?: Maybe<Internalization>;
  /** Reads a single `Invitation` using its globally unique `ID`. (live) */
  invitation?: Maybe<Invitation>;
  /** Reads a single `Invoice` using its globally unique `ID`. (live) */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Lead` using its globally unique `ID`. (live) */
  lead?: Maybe<Lead>;
  /** Reads a single `Manufacturer` using its globally unique `ID`. (live) */
  manufacturer?: Maybe<Manufacturer>;
  /** Reads a single `Mediamanager` using its globally unique `ID`. (live) */
  mediamanager?: Maybe<Mediamanager>;
  /** Reads a single `Meeting` using its globally unique `ID`. (live) */
  meeting?: Maybe<Meeting>;
  /** Reads a single `Message` using its globally unique `ID`. (live) */
  message?: Maybe<Message>;
  /** Reads a single `Newsletter` using its globally unique `ID`. (live) */
  newsletter?: Maybe<Newsletter>;
  /** Reads a single `Ooto` using its globally unique `ID`. (live) */
  ooto?: Maybe<Ooto>;
  /** Reads a single `Opportunity` using its globally unique `ID`. (live) */
  opportunity?: Maybe<Opportunity>;
  /** Reads a single `Order` using its globally unique `ID`. (live) */
  order?: Maybe<Order>;
  /** Reads a single `Page` using its globally unique `ID`. (live) */
  page?: Maybe<Page>;
  /** Reads a single `Partner` using its globally unique `ID`. (live) */
  partner?: Maybe<Partner>;
  /** Reads a single `Payment` using its globally unique `ID`. (live) */
  payment?: Maybe<Payment>;
  /** Reads a single `Permission` using its globally unique `ID`. (live) */
  permission?: Maybe<Permission>;
  /** Reads a single `Plugin` using its globally unique `ID`. (live) */
  plugin?: Maybe<Plugin>;
  /** Reads a single `Poll` using its globally unique `ID`. (live) */
  poll?: Maybe<Poll>;
  /** Reads a single `ProductType` using its globally unique `ID`. (live) */
  productType?: Maybe<ProductType>;
  /** Reads a single `Product` using its globally unique `ID`. (live) */
  product?: Maybe<Product>;
  /** Reads a single `Project` using its globally unique `ID`. (live) */
  project?: Maybe<Project>;
  /** Reads a single `Provider` using its globally unique `ID`. (live) */
  provider?: Maybe<Provider>;
  /** Reads a single `Quote` using its globally unique `ID`. (live) */
  quote?: Maybe<Quote>;
  /** Reads a single `Rating` using its globally unique `ID`. (live) */
  rating?: Maybe<Rating>;
  /** Reads a single `Report` using its globally unique `ID`. (live) */
  report?: Maybe<Report>;
  /** Reads a single `Return` using its globally unique `ID`. (live) */
  return?: Maybe<Return>;
  /** Reads a single `Review` using its globally unique `ID`. (live) */
  review?: Maybe<Review>;
  /** Reads a single `Reward` using its globally unique `ID`. (live) */
  reward?: Maybe<Reward>;
  /** Reads a single `Role` using its globally unique `ID`. (live) */
  role?: Maybe<Role>;
  /** Reads a single `Scheduler` using its globally unique `ID`. (live) */
  scheduler?: Maybe<Scheduler>;
  /** Reads a single `Segment` using its globally unique `ID`. (live) */
  segment?: Maybe<Segment>;
  /** Reads a single `Setting` using its globally unique `ID`. (live) */
  setting?: Maybe<Setting>;
  /** Reads a single `Shipment` using its globally unique `ID`. (live) */
  shipment?: Maybe<Shipment>;
  /** Reads a single `SpecialDiscount` using its globally unique `ID`. (live) */
  specialDiscount?: Maybe<SpecialDiscount>;
  /** Reads a single `State` using its globally unique `ID`. (live) */
  state?: Maybe<State>;
  /** Reads a single `Statistic` using its globally unique `ID`. (live) */
  statistic?: Maybe<Statistic>;
  /** Reads a single `Stock` using its globally unique `ID`. (live) */
  stock?: Maybe<Stock>;
  /** Reads a single `Survey` using its globally unique `ID`. (live) */
  survey?: Maybe<Survey>;
  /** Reads a single `Tag` using its globally unique `ID`. (live) */
  tag?: Maybe<Tag>;
  /** Reads a single `Target` using its globally unique `ID`. (live) */
  target?: Maybe<Target>;
  /** Reads a single `TaxCategory` using its globally unique `ID`. (live) */
  taxCategory?: Maybe<TaxCategory>;
  /** Reads a single `TaxRate` using its globally unique `ID`. (live) */
  taxRate?: Maybe<TaxRate>;
  /** Reads a single `TaxRule` using its globally unique `ID`. (live) */
  taxRule?: Maybe<TaxRule>;
  /** Reads a single `Template` using its globally unique `ID`. (live) */
  template?: Maybe<Template>;
  /** Reads a single `Theme` using its globally unique `ID`. (live) */
  theme?: Maybe<Theme>;
  /** Reads a single `Ticketing` using its globally unique `ID`. (live) */
  ticketing?: Maybe<Ticketing>;
  /** Reads a single `Training` using its globally unique `ID`. (live) */
  training?: Maybe<Training>;
  /** Reads a single `Transaction` using its globally unique `ID`. (live) */
  transaction?: Maybe<Transaction>;
  /** Reads a single `UploadFile` using its globally unique `ID`. (live) */
  uploadFile?: Maybe<UploadFile>;
  /** Reads a single `User` using its globally unique `ID`. (live) */
  user?: Maybe<User>;
  /** Reads a single `Vendor` using its globally unique `ID`. (live) */
  vendor?: Maybe<Vendor>;
  /** Reads a single `Visit` using its globally unique `ID`. (live) */
  visit?: Maybe<Visit>;
  /** Reads a single `Warehouse` using its globally unique `ID`. (live) */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `Webhook` using its globally unique `ID`. (live) */
  webhook?: Maybe<Webhook>;
  /** Reads a single `Website` using its globally unique `ID`. (live) */
  website?: Maybe<Website>;
  /** Reads a single `Wishlist` using its globally unique `ID`. (live) */
  wishlist?: Maybe<Wishlist>;
  /** Reads a single `Workspace` using its globally unique `ID`. (live) */
  workspace?: Maybe<Workspace>;
  /** Reads a single `Zone` using its globally unique `ID`. (live) */
  zone?: Maybe<Zone>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionnodeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  condition?: InputMaybe<AccountCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAccountsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  condition?: InputMaybe<AccountCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAgreementsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
  condition?: InputMaybe<AgreementCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAgreementsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
  condition?: InputMaybe<AgreementCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAnalyticsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
  condition?: InputMaybe<AnalyticCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAnalyticsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
  condition?: InputMaybe<AnalyticCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallApitokensArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
  condition?: InputMaybe<ApitokenCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallApitokensListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
  condition?: InputMaybe<ApitokenCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallArticlesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
  condition?: InputMaybe<ArticleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallArticlesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
  condition?: InputMaybe<ArticleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAttributesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
  condition?: InputMaybe<AttributeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAttributesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
  condition?: InputMaybe<AttributeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallBrandsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
  condition?: InputMaybe<BrandCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallBrandsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
  condition?: InputMaybe<BrandCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCartPriceRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
  condition?: InputMaybe<CartPriceRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCartPriceRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
  condition?: InputMaybe<CartPriceRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
  condition?: InputMaybe<CaseCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCasesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
  condition?: InputMaybe<CaseCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCatalogPriceRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
  condition?: InputMaybe<CatalogPriceRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCatalogPriceRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
  condition?: InputMaybe<CatalogPriceRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
  condition?: InputMaybe<CategoryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCategoriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
  condition?: InputMaybe<CategoryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
  condition?: InputMaybe<ChannelCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallChannelsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
  condition?: InputMaybe<ChannelCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallChecklistsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
  condition?: InputMaybe<ChecklistCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallChecklistsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
  condition?: InputMaybe<ChecklistCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  condition?: InputMaybe<CityCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCitiesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  condition?: InputMaybe<CityCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCollectionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
  condition?: InputMaybe<CollectionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCollectionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
  condition?: InputMaybe<CollectionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCommentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
  condition?: InputMaybe<CommentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCommentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
  condition?: InputMaybe<CommentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallContentTypesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
  condition?: InputMaybe<ContentTypeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallContentTypesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
  condition?: InputMaybe<ContentTypeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallContractsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
  condition?: InputMaybe<ContractCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallContractsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
  condition?: InputMaybe<ContractCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCountriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  condition?: InputMaybe<CountryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCountriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  condition?: InputMaybe<CountryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCouponsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
  condition?: InputMaybe<CouponCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCouponsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
  condition?: InputMaybe<CouponCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCreditMemosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
  condition?: InputMaybe<CreditMemoCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCreditMemosListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
  condition?: InputMaybe<CreditMemoCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrenciesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
  condition?: InputMaybe<CurrencyCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrenciesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
  condition?: InputMaybe<CurrencyCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrencyRatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
  condition?: InputMaybe<CurrencyRateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrencyRatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
  condition?: InputMaybe<CurrencyRateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrencySymbolsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
  condition?: InputMaybe<CurrencySymbolCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrencySymbolsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
  condition?: InputMaybe<CurrencySymbolCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomerGroupsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
  condition?: InputMaybe<CustomerGroupCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomerGroupsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
  condition?: InputMaybe<CustomerGroupCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
  condition?: InputMaybe<CustomerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
  condition?: InputMaybe<CustomerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomizationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
  condition?: InputMaybe<CustomizationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomizationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
  condition?: InputMaybe<CustomizationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDashboardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
  condition?: InputMaybe<DashboardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDashboardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
  condition?: InputMaybe<DashboardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDeepdivesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
  condition?: InputMaybe<DeepdiveCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDeepdivesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
  condition?: InputMaybe<DeepdiveCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDigiboardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
  condition?: InputMaybe<DigiboardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDigiboardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
  condition?: InputMaybe<DigiboardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEmailsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  condition?: InputMaybe<EmailCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEmailsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  condition?: InputMaybe<EmailCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEndofshiftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
  condition?: InputMaybe<EndofshiftCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEndofshiftsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
  condition?: InputMaybe<EndofshiftCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  condition?: InputMaybe<EventCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEventsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  condition?: InputMaybe<EventCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallFullfillmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
  condition?: InputMaybe<FullfillmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallFullfillmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
  condition?: InputMaybe<FullfillmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallGiftCertificatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
  condition?: InputMaybe<GiftCertificateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallGiftCertificatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
  condition?: InputMaybe<GiftCertificateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallGlossariesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
  condition?: InputMaybe<GlossaryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallGlossariesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
  condition?: InputMaybe<GlossaryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallImportmsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
  condition?: InputMaybe<ImportmCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallImportmsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
  condition?: InputMaybe<ImportmCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallIntegrationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
  condition?: InputMaybe<IntegrationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallIntegrationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
  condition?: InputMaybe<IntegrationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInternalizationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
  condition?: InputMaybe<InternalizationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInternalizationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
  condition?: InputMaybe<InternalizationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInvitationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
  condition?: InputMaybe<InvitationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInvitationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
  condition?: InputMaybe<InvitationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInvoicesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
  condition?: InputMaybe<InvoiceCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInvoicesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
  condition?: InputMaybe<InvoiceCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallLeadsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
  condition?: InputMaybe<LeadCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallLeadsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
  condition?: InputMaybe<LeadCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallManufacturersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
  condition?: InputMaybe<ManufacturerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallManufacturersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
  condition?: InputMaybe<ManufacturerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMediamanagersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
  condition?: InputMaybe<MediamanagerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMediamanagersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
  condition?: InputMaybe<MediamanagerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMeetingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
  condition?: InputMaybe<MeetingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMeetingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
  condition?: InputMaybe<MeetingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMessagesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  condition?: InputMaybe<MessageCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMessagesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  condition?: InputMaybe<MessageCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallNewslettersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
  condition?: InputMaybe<NewsletterCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallNewslettersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
  condition?: InputMaybe<NewsletterCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOotosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
  condition?: InputMaybe<OotoCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOotosListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
  condition?: InputMaybe<OotoCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOpportunitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
  condition?: InputMaybe<OpportunityCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOpportunitiesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
  condition?: InputMaybe<OpportunityCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOrdersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
  condition?: InputMaybe<OrderCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOrdersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
  condition?: InputMaybe<OrderCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPagesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
  condition?: InputMaybe<PageCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPagesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
  condition?: InputMaybe<PageCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPartnersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
  condition?: InputMaybe<PartnerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPartnersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
  condition?: InputMaybe<PartnerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPaymentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
  condition?: InputMaybe<PaymentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPaymentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
  condition?: InputMaybe<PaymentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPermissionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  condition?: InputMaybe<PermissionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPermissionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  condition?: InputMaybe<PermissionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPluginsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
  condition?: InputMaybe<PluginCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPluginsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
  condition?: InputMaybe<PluginCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPollsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
  condition?: InputMaybe<PollCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPollsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
  condition?: InputMaybe<PollCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProductTypesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
  condition?: InputMaybe<ProductTypeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProductTypesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
  condition?: InputMaybe<ProductTypeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProductsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
  condition?: InputMaybe<ProductCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProductsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
  condition?: InputMaybe<ProductCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProjectsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  condition?: InputMaybe<ProjectCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProjectsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  condition?: InputMaybe<ProjectCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProvidersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
  condition?: InputMaybe<ProviderCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProvidersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
  condition?: InputMaybe<ProviderCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallQuotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  condition?: InputMaybe<QuoteCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallQuotesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  condition?: InputMaybe<QuoteCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRatingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
  condition?: InputMaybe<RatingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRatingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
  condition?: InputMaybe<RatingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
  condition?: InputMaybe<ReportCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReportsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
  condition?: InputMaybe<ReportCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReturnsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
  condition?: InputMaybe<ReturnCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReturnsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
  condition?: InputMaybe<ReturnCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReviewsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
  condition?: InputMaybe<ReviewCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReviewsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
  condition?: InputMaybe<ReviewCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRewardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
  condition?: InputMaybe<RewardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRewardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
  condition?: InputMaybe<RewardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRolesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  condition?: InputMaybe<RoleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRolesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  condition?: InputMaybe<RoleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSchedulersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
  condition?: InputMaybe<SchedulerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSchedulersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
  condition?: InputMaybe<SchedulerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSegmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
  condition?: InputMaybe<SegmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSegmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
  condition?: InputMaybe<SegmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSettingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
  condition?: InputMaybe<SettingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSettingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
  condition?: InputMaybe<SettingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallShipmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
  condition?: InputMaybe<ShipmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallShipmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
  condition?: InputMaybe<ShipmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSpecialDiscountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
  condition?: InputMaybe<SpecialDiscountCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSpecialDiscountsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
  condition?: InputMaybe<SpecialDiscountCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
  condition?: InputMaybe<StateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
  condition?: InputMaybe<StateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStatisticsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
  condition?: InputMaybe<StatisticCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStatisticsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
  condition?: InputMaybe<StatisticCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStocksArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
  condition?: InputMaybe<StockCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStocksListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
  condition?: InputMaybe<StockCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSurveysArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
  condition?: InputMaybe<SurveyCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSurveysListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
  condition?: InputMaybe<SurveyCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTagsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
  condition?: InputMaybe<TagCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTagsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
  condition?: InputMaybe<TagCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTargetsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
  condition?: InputMaybe<TargetCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTargetsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
  condition?: InputMaybe<TargetCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
  condition?: InputMaybe<TaxCategoryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxCategoriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
  condition?: InputMaybe<TaxCategoryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxRatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
  condition?: InputMaybe<TaxRateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxRatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
  condition?: InputMaybe<TaxRateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
  condition?: InputMaybe<TaxRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
  condition?: InputMaybe<TaxRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTemplatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
  condition?: InputMaybe<TemplateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTemplatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
  condition?: InputMaybe<TemplateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallThemesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
  condition?: InputMaybe<ThemeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallThemesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
  condition?: InputMaybe<ThemeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTicketingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
  condition?: InputMaybe<TicketingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTicketingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
  condition?: InputMaybe<TicketingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTrainingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
  condition?: InputMaybe<TrainingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTrainingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
  condition?: InputMaybe<TrainingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
  condition?: InputMaybe<TransactionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTransactionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
  condition?: InputMaybe<TransactionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallUploadFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
  condition?: InputMaybe<UploadFileCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallUploadFilesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
  condition?: InputMaybe<UploadFileCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallUsersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  condition?: InputMaybe<UserCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallUsersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  condition?: InputMaybe<UserCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallVendorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
  condition?: InputMaybe<VendorCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallVendorsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
  condition?: InputMaybe<VendorCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallVisitsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
  condition?: InputMaybe<VisitCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallVisitsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
  condition?: InputMaybe<VisitCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWarehousesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
  condition?: InputMaybe<WarehouseCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWarehousesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
  condition?: InputMaybe<WarehouseCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWebhooksArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
  condition?: InputMaybe<WebhookCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWebhooksListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
  condition?: InputMaybe<WebhookCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWebsitesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
  condition?: InputMaybe<WebsiteCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWebsitesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
  condition?: InputMaybe<WebsiteCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWishlistsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
  condition?: InputMaybe<WishlistCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWishlistsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
  condition?: InputMaybe<WishlistCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWorkspacesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
  condition?: InputMaybe<WorkspaceCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWorkspacesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
  condition?: InputMaybe<WorkspaceCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallZonesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
  condition?: InputMaybe<ZoneCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallZonesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
  condition?: InputMaybe<ZoneCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionaccountByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionagreementByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionanalyticByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionapitokenByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionarticleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionattributeByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionbrandByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncartPriceRuleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncaseByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncatalogPriceRuleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncategoryByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionchannelByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionchecklistByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncityByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncollectionByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncommentByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncontentTypeByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncontractByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncountryByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncouponByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncreditMemoByCreditMemoAndIdArgs = {
  creditMemo: Scalars['String'];
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencyByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencyRateByImportServiceArgs = {
  importService: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencySymbolBySymbolArgs = {
  symbol: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomerGroupByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomerByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomizationByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondashboardByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondeepdiveByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondigiboardByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionemailByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionendofshiftByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioneventByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionfullfillmentByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiongiftCertificateByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionglossaryByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionimportmByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionintegrationByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninternalizationByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninvitationByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninvoiceByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionleadByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmanufacturerByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmediamanagerByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmeetingByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmessageByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionnewsletterByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionootoByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionopportunityByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionorderByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpageByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpartnerByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpaymentByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpermissionByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpluginByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpollByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproductTypeByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproductByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionprojectByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproviderByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionquoteByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionratingByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreportByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreturnByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreviewByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionrewardByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionroleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionschedulerByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsegmentByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsettingByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionshipmentByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionspecialDiscountByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstateByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstatisticByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstockByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsurveyByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontagByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontargetByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxCategoryByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxRateByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxRuleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontemplateByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionthemeByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionticketingByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontrainingByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontransactionByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionuploadFileByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionuserByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionvendorByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionvisitByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwarehouseByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwebhookByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwebsiteByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwishlistByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionworkspaceByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionzoneByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionaccountArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionagreementArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionanalyticArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionapitokenArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionarticleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionattributeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionbrandArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncartPriceRuleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncaseArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncatalogPriceRuleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncategoryArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionchannelArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionchecklistArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncityArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncollectionArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncommentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncontentTypeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncontractArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncountryArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncouponArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncreditMemoArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencyArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencyRateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencySymbolArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomerGroupArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomizationArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondashboardArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondeepdiveArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondigiboardArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionemailArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionendofshiftArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioneventArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionfullfillmentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiongiftCertificateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionglossaryArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionimportmArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionintegrationArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninternalizationArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninvitationArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninvoiceArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionleadArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmanufacturerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmediamanagerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmeetingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmessageArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionnewsletterArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionootoArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionopportunityArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionorderArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpageArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpartnerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpaymentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpermissionArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpluginArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpollArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproductTypeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproductArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionprojectArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproviderArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionquoteArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionratingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreportArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreturnArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreviewArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionrewardArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionroleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionschedulerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsegmentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsettingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionshipmentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionspecialDiscountArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstatisticArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstockArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsurveyArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontagArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontargetArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxCategoryArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxRateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxRuleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontemplateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionthemeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionticketingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontrainingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontransactionArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionuploadFileArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionuserArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionvendorArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionvisitArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwarehouseArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwebhookArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwebsiteArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwishlistArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionworkspaceArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionzoneArgs = {
  nodeId: Scalars['ID'];
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;



/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Query: ResolverTypeWrapper<{}>;
  Node: ResolversTypes['Query'] | ResolversTypes['Account'] | ResolversTypes['Agreement'] | ResolversTypes['Analytic'] | ResolversTypes['Apitoken'] | ResolversTypes['Article'] | ResolversTypes['Attribute'] | ResolversTypes['Brand'] | ResolversTypes['CartPriceRule'] | ResolversTypes['Case'] | ResolversTypes['CatalogPriceRule'] | ResolversTypes['Category'] | ResolversTypes['Channel'] | ResolversTypes['Checklist'] | ResolversTypes['City'] | ResolversTypes['Collection'] | ResolversTypes['Comment'] | ResolversTypes['ContentType'] | ResolversTypes['Contract'] | ResolversTypes['Country'] | ResolversTypes['Coupon'] | ResolversTypes['CreditMemo'] | ResolversTypes['Currency'] | ResolversTypes['CurrencyRate'] | ResolversTypes['CurrencySymbol'] | ResolversTypes['CustomerGroup'] | ResolversTypes['Customer'] | ResolversTypes['Customization'] | ResolversTypes['Dashboard'] | ResolversTypes['Deepdive'] | ResolversTypes['Digiboard'] | ResolversTypes['Email'] | ResolversTypes['Endofshift'] | ResolversTypes['Event'] | ResolversTypes['Fullfillment'] | ResolversTypes['GiftCertificate'] | ResolversTypes['Glossary'] | ResolversTypes['Importm'] | ResolversTypes['Integration'] | ResolversTypes['Internalization'] | ResolversTypes['Invitation'] | ResolversTypes['Invoice'] | ResolversTypes['Lead'] | ResolversTypes['Manufacturer'] | ResolversTypes['Mediamanager'] | ResolversTypes['Meeting'] | ResolversTypes['Message'] | ResolversTypes['Newsletter'] | ResolversTypes['Ooto'] | ResolversTypes['Opportunity'] | ResolversTypes['Order'] | ResolversTypes['Page'] | ResolversTypes['Partner'] | ResolversTypes['Payment'] | ResolversTypes['Permission'] | ResolversTypes['Plugin'] | ResolversTypes['Poll'] | ResolversTypes['ProductType'] | ResolversTypes['Product'] | ResolversTypes['Project'] | ResolversTypes['Provider'] | ResolversTypes['Quote'] | ResolversTypes['Rating'] | ResolversTypes['Report'] | ResolversTypes['Return'] | ResolversTypes['Review'] | ResolversTypes['Reward'] | ResolversTypes['Role'] | ResolversTypes['Scheduler'] | ResolversTypes['Segment'] | ResolversTypes['Setting'] | ResolversTypes['Shipment'] | ResolversTypes['SpecialDiscount'] | ResolversTypes['State'] | ResolversTypes['Statistic'] | ResolversTypes['Stock'] | ResolversTypes['Survey'] | ResolversTypes['Tag'] | ResolversTypes['Target'] | ResolversTypes['TaxCategory'] | ResolversTypes['TaxRate'] | ResolversTypes['TaxRule'] | ResolversTypes['Template'] | ResolversTypes['Theme'] | ResolversTypes['Ticketing'] | ResolversTypes['Training'] | ResolversTypes['Transaction'] | ResolversTypes['UploadFile'] | ResolversTypes['User'] | ResolversTypes['Vendor'] | ResolversTypes['Visit'] | ResolversTypes['Warehouse'] | ResolversTypes['Webhook'] | ResolversTypes['Website'] | ResolversTypes['Wishlist'] | ResolversTypes['Workspace'] | ResolversTypes['Zone'];
  ID: ResolverTypeWrapper<Scalars['ID']>;
  AccountsConnection: ResolverTypeWrapper<AccountsConnection>;
  Account: ResolverTypeWrapper<Account>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
  Datetime: ResolverTypeWrapper<Scalars['Datetime']>;
  String: ResolverTypeWrapper<Scalars['String']>;
  AccountsEdge: ResolverTypeWrapper<AccountsEdge>;
  Cursor: ResolverTypeWrapper<Scalars['Cursor']>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  AccountsOrderBy: AccountsOrderBy;
  AccountCondition: AccountCondition;
  AgreementsConnection: ResolverTypeWrapper<AgreementsConnection>;
  Agreement: ResolverTypeWrapper<Agreement>;
  AgreementsEdge: ResolverTypeWrapper<AgreementsEdge>;
  AgreementsOrderBy: AgreementsOrderBy;
  AgreementCondition: AgreementCondition;
  AnalyticsConnection: ResolverTypeWrapper<AnalyticsConnection>;
  Analytic: ResolverTypeWrapper<Analytic>;
  AnalyticsEdge: ResolverTypeWrapper<AnalyticsEdge>;
  AnalyticsOrderBy: AnalyticsOrderBy;
  AnalyticCondition: AnalyticCondition;
  ApitokensConnection: ResolverTypeWrapper<ApitokensConnection>;
  Apitoken: ResolverTypeWrapper<Apitoken>;
  ApitokensEdge: ResolverTypeWrapper<ApitokensEdge>;
  ApitokensOrderBy: ApitokensOrderBy;
  ApitokenCondition: ApitokenCondition;
  ArticlesConnection: ResolverTypeWrapper<ArticlesConnection>;
  Article: ResolverTypeWrapper<Article>;
  ArticlesEdge: ResolverTypeWrapper<ArticlesEdge>;
  ArticlesOrderBy: ArticlesOrderBy;
  ArticleCondition: ArticleCondition;
  AttributesConnection: ResolverTypeWrapper<AttributesConnection>;
  Attribute: ResolverTypeWrapper<Attribute>;
  AttributesEdge: ResolverTypeWrapper<AttributesEdge>;
  AttributesOrderBy: AttributesOrderBy;
  AttributeCondition: AttributeCondition;
  BrandsConnection: ResolverTypeWrapper<BrandsConnection>;
  Brand: ResolverTypeWrapper<Brand>;
  BrandsEdge: ResolverTypeWrapper<BrandsEdge>;
  BrandsOrderBy: BrandsOrderBy;
  BrandCondition: BrandCondition;
  CartPriceRulesConnection: ResolverTypeWrapper<CartPriceRulesConnection>;
  CartPriceRule: ResolverTypeWrapper<CartPriceRule>;
  Date: ResolverTypeWrapper<Scalars['Date']>;
  BigFloat: ResolverTypeWrapper<Scalars['BigFloat']>;
  CartPriceRulesEdge: ResolverTypeWrapper<CartPriceRulesEdge>;
  CartPriceRulesOrderBy: CartPriceRulesOrderBy;
  CartPriceRuleCondition: CartPriceRuleCondition;
  CasesConnection: ResolverTypeWrapper<CasesConnection>;
  Case: ResolverTypeWrapper<Case>;
  CasesEdge: ResolverTypeWrapper<CasesEdge>;
  CasesOrderBy: CasesOrderBy;
  CaseCondition: CaseCondition;
  CatalogPriceRulesConnection: ResolverTypeWrapper<CatalogPriceRulesConnection>;
  CatalogPriceRule: ResolverTypeWrapper<CatalogPriceRule>;
  CatalogPriceRulesEdge: ResolverTypeWrapper<CatalogPriceRulesEdge>;
  CatalogPriceRulesOrderBy: CatalogPriceRulesOrderBy;
  CatalogPriceRuleCondition: CatalogPriceRuleCondition;
  CategoriesConnection: ResolverTypeWrapper<CategoriesConnection>;
  Category: ResolverTypeWrapper<Category>;
  CategoriesEdge: ResolverTypeWrapper<CategoriesEdge>;
  CategoriesOrderBy: CategoriesOrderBy;
  CategoryCondition: CategoryCondition;
  ChannelsConnection: ResolverTypeWrapper<ChannelsConnection>;
  Channel: ResolverTypeWrapper<Channel>;
  ChannelsEdge: ResolverTypeWrapper<ChannelsEdge>;
  ChannelsOrderBy: ChannelsOrderBy;
  ChannelCondition: ChannelCondition;
  ChecklistsConnection: ResolverTypeWrapper<ChecklistsConnection>;
  Checklist: ResolverTypeWrapper<Checklist>;
  ChecklistsEdge: ResolverTypeWrapper<ChecklistsEdge>;
  ChecklistsOrderBy: ChecklistsOrderBy;
  ChecklistCondition: ChecklistCondition;
  CitiesConnection: ResolverTypeWrapper<CitiesConnection>;
  City: ResolverTypeWrapper<City>;
  CitiesEdge: ResolverTypeWrapper<CitiesEdge>;
  CitiesOrderBy: CitiesOrderBy;
  CityCondition: CityCondition;
  CollectionsConnection: ResolverTypeWrapper<CollectionsConnection>;
  Collection: ResolverTypeWrapper<Collection>;
  CollectionsEdge: ResolverTypeWrapper<CollectionsEdge>;
  CollectionsOrderBy: CollectionsOrderBy;
  CollectionCondition: CollectionCondition;
  CommentsConnection: ResolverTypeWrapper<CommentsConnection>;
  Comment: ResolverTypeWrapper<Comment>;
  CommentsEdge: ResolverTypeWrapper<CommentsEdge>;
  CommentsOrderBy: CommentsOrderBy;
  CommentCondition: CommentCondition;
  ContentTypesConnection: ResolverTypeWrapper<ContentTypesConnection>;
  ContentType: ResolverTypeWrapper<ContentType>;
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  Time: ResolverTypeWrapper<Scalars['Time']>;
  ContentTypesEdge: ResolverTypeWrapper<ContentTypesEdge>;
  ContentTypesOrderBy: ContentTypesOrderBy;
  ContentTypeCondition: ContentTypeCondition;
  ContractsConnection: ResolverTypeWrapper<ContractsConnection>;
  Contract: ResolverTypeWrapper<Contract>;
  ContractsEdge: ResolverTypeWrapper<ContractsEdge>;
  ContractsOrderBy: ContractsOrderBy;
  ContractCondition: ContractCondition;
  CountriesConnection: ResolverTypeWrapper<CountriesConnection>;
  Country: ResolverTypeWrapper<Country>;
  CountriesEdge: ResolverTypeWrapper<CountriesEdge>;
  CountriesOrderBy: CountriesOrderBy;
  CountryCondition: CountryCondition;
  CouponsConnection: ResolverTypeWrapper<CouponsConnection>;
  Coupon: ResolverTypeWrapper<Coupon>;
  CouponsEdge: ResolverTypeWrapper<CouponsEdge>;
  CouponsOrderBy: CouponsOrderBy;
  CouponCondition: CouponCondition;
  CreditMemosConnection: ResolverTypeWrapper<CreditMemosConnection>;
  CreditMemo: ResolverTypeWrapper<CreditMemo>;
  CreditMemosEdge: ResolverTypeWrapper<CreditMemosEdge>;
  CreditMemosOrderBy: CreditMemosOrderBy;
  CreditMemoCondition: CreditMemoCondition;
  CurrenciesConnection: ResolverTypeWrapper<CurrenciesConnection>;
  Currency: ResolverTypeWrapper<Currency>;
  CurrenciesEdge: ResolverTypeWrapper<CurrenciesEdge>;
  CurrenciesOrderBy: CurrenciesOrderBy;
  CurrencyCondition: CurrencyCondition;
  CurrencyRatesConnection: ResolverTypeWrapper<CurrencyRatesConnection>;
  CurrencyRate: ResolverTypeWrapper<CurrencyRate>;
  CurrencyRatesEdge: ResolverTypeWrapper<CurrencyRatesEdge>;
  CurrencyRatesOrderBy: CurrencyRatesOrderBy;
  CurrencyRateCondition: CurrencyRateCondition;
  CurrencySymbolsConnection: ResolverTypeWrapper<CurrencySymbolsConnection>;
  CurrencySymbol: ResolverTypeWrapper<CurrencySymbol>;
  CurrencySymbolsEdge: ResolverTypeWrapper<CurrencySymbolsEdge>;
  CurrencySymbolsOrderBy: CurrencySymbolsOrderBy;
  CurrencySymbolCondition: CurrencySymbolCondition;
  CustomerGroupsConnection: ResolverTypeWrapper<CustomerGroupsConnection>;
  CustomerGroup: ResolverTypeWrapper<CustomerGroup>;
  CustomerGroupsEdge: ResolverTypeWrapper<CustomerGroupsEdge>;
  CustomerGroupsOrderBy: CustomerGroupsOrderBy;
  CustomerGroupCondition: CustomerGroupCondition;
  CustomersConnection: ResolverTypeWrapper<CustomersConnection>;
  Customer: ResolverTypeWrapper<Customer>;
  CustomersEdge: ResolverTypeWrapper<CustomersEdge>;
  CustomersOrderBy: CustomersOrderBy;
  CustomerCondition: CustomerCondition;
  CustomizationsConnection: ResolverTypeWrapper<CustomizationsConnection>;
  Customization: ResolverTypeWrapper<Customization>;
  CustomizationsEdge: ResolverTypeWrapper<CustomizationsEdge>;
  CustomizationsOrderBy: CustomizationsOrderBy;
  CustomizationCondition: CustomizationCondition;
  DashboardsConnection: ResolverTypeWrapper<DashboardsConnection>;
  Dashboard: ResolverTypeWrapper<Dashboard>;
  DashboardsEdge: ResolverTypeWrapper<DashboardsEdge>;
  DashboardsOrderBy: DashboardsOrderBy;
  DashboardCondition: DashboardCondition;
  DeepdivesConnection: ResolverTypeWrapper<DeepdivesConnection>;
  Deepdive: ResolverTypeWrapper<Deepdive>;
  DeepdivesEdge: ResolverTypeWrapper<DeepdivesEdge>;
  DeepdivesOrderBy: DeepdivesOrderBy;
  DeepdiveCondition: DeepdiveCondition;
  DigiboardsConnection: ResolverTypeWrapper<DigiboardsConnection>;
  Digiboard: ResolverTypeWrapper<Digiboard>;
  DigiboardsEdge: ResolverTypeWrapper<DigiboardsEdge>;
  DigiboardsOrderBy: DigiboardsOrderBy;
  DigiboardCondition: DigiboardCondition;
  EmailsConnection: ResolverTypeWrapper<EmailsConnection>;
  Email: ResolverTypeWrapper<Email>;
  EmailsEdge: ResolverTypeWrapper<EmailsEdge>;
  EmailsOrderBy: EmailsOrderBy;
  EmailCondition: EmailCondition;
  EndofshiftsConnection: ResolverTypeWrapper<EndofshiftsConnection>;
  Endofshift: ResolverTypeWrapper<Endofshift>;
  EndofshiftsEdge: ResolverTypeWrapper<EndofshiftsEdge>;
  EndofshiftsOrderBy: EndofshiftsOrderBy;
  EndofshiftCondition: EndofshiftCondition;
  EventsConnection: ResolverTypeWrapper<EventsConnection>;
  Event: ResolverTypeWrapper<Event>;
  EventsEdge: ResolverTypeWrapper<EventsEdge>;
  EventsOrderBy: EventsOrderBy;
  EventCondition: EventCondition;
  FullfillmentsConnection: ResolverTypeWrapper<FullfillmentsConnection>;
  Fullfillment: ResolverTypeWrapper<Fullfillment>;
  FullfillmentsEdge: ResolverTypeWrapper<FullfillmentsEdge>;
  FullfillmentsOrderBy: FullfillmentsOrderBy;
  FullfillmentCondition: FullfillmentCondition;
  GiftCertificatesConnection: ResolverTypeWrapper<GiftCertificatesConnection>;
  GiftCertificate: ResolverTypeWrapper<GiftCertificate>;
  GiftCertificatesEdge: ResolverTypeWrapper<GiftCertificatesEdge>;
  GiftCertificatesOrderBy: GiftCertificatesOrderBy;
  GiftCertificateCondition: GiftCertificateCondition;
  GlossariesConnection: ResolverTypeWrapper<GlossariesConnection>;
  Glossary: ResolverTypeWrapper<Glossary>;
  GlossariesEdge: ResolverTypeWrapper<GlossariesEdge>;
  GlossariesOrderBy: GlossariesOrderBy;
  GlossaryCondition: GlossaryCondition;
  ImportmsConnection: ResolverTypeWrapper<ImportmsConnection>;
  Importm: ResolverTypeWrapper<Importm>;
  ImportmsEdge: ResolverTypeWrapper<ImportmsEdge>;
  ImportmsOrderBy: ImportmsOrderBy;
  ImportmCondition: ImportmCondition;
  IntegrationsConnection: ResolverTypeWrapper<IntegrationsConnection>;
  Integration: ResolverTypeWrapper<Integration>;
  IntegrationsEdge: ResolverTypeWrapper<IntegrationsEdge>;
  IntegrationsOrderBy: IntegrationsOrderBy;
  IntegrationCondition: IntegrationCondition;
  InternalizationsConnection: ResolverTypeWrapper<InternalizationsConnection>;
  Internalization: ResolverTypeWrapper<Internalization>;
  InternalizationsEdge: ResolverTypeWrapper<InternalizationsEdge>;
  InternalizationsOrderBy: InternalizationsOrderBy;
  InternalizationCondition: InternalizationCondition;
  InvitationsConnection: ResolverTypeWrapper<InvitationsConnection>;
  Invitation: ResolverTypeWrapper<Invitation>;
  InvitationsEdge: ResolverTypeWrapper<InvitationsEdge>;
  InvitationsOrderBy: InvitationsOrderBy;
  InvitationCondition: InvitationCondition;
  InvoicesConnection: ResolverTypeWrapper<InvoicesConnection>;
  Invoice: ResolverTypeWrapper<Invoice>;
  InvoicesEdge: ResolverTypeWrapper<InvoicesEdge>;
  InvoicesOrderBy: InvoicesOrderBy;
  InvoiceCondition: InvoiceCondition;
  LeadsConnection: ResolverTypeWrapper<LeadsConnection>;
  Lead: ResolverTypeWrapper<Lead>;
  LeadsEdge: ResolverTypeWrapper<LeadsEdge>;
  LeadsOrderBy: LeadsOrderBy;
  LeadCondition: LeadCondition;
  ManufacturersConnection: ResolverTypeWrapper<ManufacturersConnection>;
  Manufacturer: ResolverTypeWrapper<Manufacturer>;
  ManufacturersEdge: ResolverTypeWrapper<ManufacturersEdge>;
  ManufacturersOrderBy: ManufacturersOrderBy;
  ManufacturerCondition: ManufacturerCondition;
  MediamanagersConnection: ResolverTypeWrapper<MediamanagersConnection>;
  Mediamanager: ResolverTypeWrapper<Mediamanager>;
  MediamanagersEdge: ResolverTypeWrapper<MediamanagersEdge>;
  MediamanagersOrderBy: MediamanagersOrderBy;
  MediamanagerCondition: MediamanagerCondition;
  MeetingsConnection: ResolverTypeWrapper<MeetingsConnection>;
  Meeting: ResolverTypeWrapper<Meeting>;
  MeetingsEdge: ResolverTypeWrapper<MeetingsEdge>;
  MeetingsOrderBy: MeetingsOrderBy;
  MeetingCondition: MeetingCondition;
  MessagesConnection: ResolverTypeWrapper<MessagesConnection>;
  Message: ResolverTypeWrapper<Message>;
  MessagesEdge: ResolverTypeWrapper<MessagesEdge>;
  MessagesOrderBy: MessagesOrderBy;
  MessageCondition: MessageCondition;
  NewslettersConnection: ResolverTypeWrapper<NewslettersConnection>;
  Newsletter: ResolverTypeWrapper<Newsletter>;
  NewslettersEdge: ResolverTypeWrapper<NewslettersEdge>;
  NewslettersOrderBy: NewslettersOrderBy;
  NewsletterCondition: NewsletterCondition;
  OotosConnection: ResolverTypeWrapper<OotosConnection>;
  Ooto: ResolverTypeWrapper<Ooto>;
  OotosEdge: ResolverTypeWrapper<OotosEdge>;
  OotosOrderBy: OotosOrderBy;
  OotoCondition: OotoCondition;
  OpportunitiesConnection: ResolverTypeWrapper<OpportunitiesConnection>;
  Opportunity: ResolverTypeWrapper<Opportunity>;
  OpportunitiesEdge: ResolverTypeWrapper<OpportunitiesEdge>;
  OpportunitiesOrderBy: OpportunitiesOrderBy;
  OpportunityCondition: OpportunityCondition;
  OrdersConnection: ResolverTypeWrapper<OrdersConnection>;
  Order: ResolverTypeWrapper<Order>;
  OrdersEdge: ResolverTypeWrapper<OrdersEdge>;
  OrdersOrderBy: OrdersOrderBy;
  OrderCondition: OrderCondition;
  PagesConnection: ResolverTypeWrapper<PagesConnection>;
  Page: ResolverTypeWrapper<Page>;
  PagesEdge: ResolverTypeWrapper<PagesEdge>;
  PagesOrderBy: PagesOrderBy;
  PageCondition: PageCondition;
  PartnersConnection: ResolverTypeWrapper<PartnersConnection>;
  Partner: ResolverTypeWrapper<Partner>;
  PartnersEdge: ResolverTypeWrapper<PartnersEdge>;
  PartnersOrderBy: PartnersOrderBy;
  PartnerCondition: PartnerCondition;
  PaymentsConnection: ResolverTypeWrapper<PaymentsConnection>;
  Payment: ResolverTypeWrapper<Payment>;
  PaymentsEdge: ResolverTypeWrapper<PaymentsEdge>;
  PaymentsOrderBy: PaymentsOrderBy;
  PaymentCondition: PaymentCondition;
  PermissionsConnection: ResolverTypeWrapper<PermissionsConnection>;
  Permission: ResolverTypeWrapper<Permission>;
  PermissionsEdge: ResolverTypeWrapper<PermissionsEdge>;
  PermissionsOrderBy: PermissionsOrderBy;
  PermissionCondition: PermissionCondition;
  PluginsConnection: ResolverTypeWrapper<PluginsConnection>;
  Plugin: ResolverTypeWrapper<Plugin>;
  PluginsEdge: ResolverTypeWrapper<PluginsEdge>;
  PluginsOrderBy: PluginsOrderBy;
  PluginCondition: PluginCondition;
  PollsConnection: ResolverTypeWrapper<PollsConnection>;
  Poll: ResolverTypeWrapper<Poll>;
  PollsEdge: ResolverTypeWrapper<PollsEdge>;
  PollsOrderBy: PollsOrderBy;
  PollCondition: PollCondition;
  ProductTypesConnection: ResolverTypeWrapper<ProductTypesConnection>;
  ProductType: ResolverTypeWrapper<ProductType>;
  ProductTypesEdge: ResolverTypeWrapper<ProductTypesEdge>;
  ProductTypesOrderBy: ProductTypesOrderBy;
  ProductTypeCondition: ProductTypeCondition;
  ProductsConnection: ResolverTypeWrapper<ProductsConnection>;
  Product: ResolverTypeWrapper<Product>;
  ProductsEdge: ResolverTypeWrapper<ProductsEdge>;
  ProductsOrderBy: ProductsOrderBy;
  ProductCondition: ProductCondition;
  ProjectsConnection: ResolverTypeWrapper<ProjectsConnection>;
  Project: ResolverTypeWrapper<Project>;
  ProjectsEdge: ResolverTypeWrapper<ProjectsEdge>;
  ProjectsOrderBy: ProjectsOrderBy;
  ProjectCondition: ProjectCondition;
  ProvidersConnection: ResolverTypeWrapper<ProvidersConnection>;
  Provider: ResolverTypeWrapper<Provider>;
  ProvidersEdge: ResolverTypeWrapper<ProvidersEdge>;
  ProvidersOrderBy: ProvidersOrderBy;
  ProviderCondition: ProviderCondition;
  QuotesConnection: ResolverTypeWrapper<QuotesConnection>;
  Quote: ResolverTypeWrapper<Quote>;
  QuotesEdge: ResolverTypeWrapper<QuotesEdge>;
  QuotesOrderBy: QuotesOrderBy;
  QuoteCondition: QuoteCondition;
  RatingsConnection: ResolverTypeWrapper<RatingsConnection>;
  Rating: ResolverTypeWrapper<Rating>;
  RatingsEdge: ResolverTypeWrapper<RatingsEdge>;
  RatingsOrderBy: RatingsOrderBy;
  RatingCondition: RatingCondition;
  ReportsConnection: ResolverTypeWrapper<ReportsConnection>;
  Report: ResolverTypeWrapper<Report>;
  ReportsEdge: ResolverTypeWrapper<ReportsEdge>;
  ReportsOrderBy: ReportsOrderBy;
  ReportCondition: ReportCondition;
  ReturnsConnection: ResolverTypeWrapper<ReturnsConnection>;
  Return: ResolverTypeWrapper<Return>;
  ReturnsEdge: ResolverTypeWrapper<ReturnsEdge>;
  ReturnsOrderBy: ReturnsOrderBy;
  ReturnCondition: ReturnCondition;
  ReviewsConnection: ResolverTypeWrapper<ReviewsConnection>;
  Review: ResolverTypeWrapper<Review>;
  ReviewsEdge: ResolverTypeWrapper<ReviewsEdge>;
  ReviewsOrderBy: ReviewsOrderBy;
  ReviewCondition: ReviewCondition;
  RewardsConnection: ResolverTypeWrapper<RewardsConnection>;
  Reward: ResolverTypeWrapper<Reward>;
  RewardsEdge: ResolverTypeWrapper<RewardsEdge>;
  RewardsOrderBy: RewardsOrderBy;
  RewardCondition: RewardCondition;
  RolesConnection: ResolverTypeWrapper<RolesConnection>;
  Role: ResolverTypeWrapper<Role>;
  RolesEdge: ResolverTypeWrapper<RolesEdge>;
  RolesOrderBy: RolesOrderBy;
  RoleCondition: RoleCondition;
  SchedulersConnection: ResolverTypeWrapper<SchedulersConnection>;
  Scheduler: ResolverTypeWrapper<Scheduler>;
  SchedulersEdge: ResolverTypeWrapper<SchedulersEdge>;
  SchedulersOrderBy: SchedulersOrderBy;
  SchedulerCondition: SchedulerCondition;
  SegmentsConnection: ResolverTypeWrapper<SegmentsConnection>;
  Segment: ResolverTypeWrapper<Segment>;
  SegmentsEdge: ResolverTypeWrapper<SegmentsEdge>;
  SegmentsOrderBy: SegmentsOrderBy;
  SegmentCondition: SegmentCondition;
  SettingsConnection: ResolverTypeWrapper<SettingsConnection>;
  Setting: ResolverTypeWrapper<Setting>;
  SettingsEdge: ResolverTypeWrapper<SettingsEdge>;
  SettingsOrderBy: SettingsOrderBy;
  SettingCondition: SettingCondition;
  ShipmentsConnection: ResolverTypeWrapper<ShipmentsConnection>;
  Shipment: ResolverTypeWrapper<Shipment>;
  ShipmentsEdge: ResolverTypeWrapper<ShipmentsEdge>;
  ShipmentsOrderBy: ShipmentsOrderBy;
  ShipmentCondition: ShipmentCondition;
  SpecialDiscountsConnection: ResolverTypeWrapper<SpecialDiscountsConnection>;
  SpecialDiscount: ResolverTypeWrapper<SpecialDiscount>;
  SpecialDiscountsEdge: ResolverTypeWrapper<SpecialDiscountsEdge>;
  SpecialDiscountsOrderBy: SpecialDiscountsOrderBy;
  SpecialDiscountCondition: SpecialDiscountCondition;
  StatesConnection: ResolverTypeWrapper<StatesConnection>;
  State: ResolverTypeWrapper<State>;
  StatesEdge: ResolverTypeWrapper<StatesEdge>;
  StatesOrderBy: StatesOrderBy;
  StateCondition: StateCondition;
  StatisticsConnection: ResolverTypeWrapper<StatisticsConnection>;
  Statistic: ResolverTypeWrapper<Statistic>;
  StatisticsEdge: ResolverTypeWrapper<StatisticsEdge>;
  StatisticsOrderBy: StatisticsOrderBy;
  StatisticCondition: StatisticCondition;
  StocksConnection: ResolverTypeWrapper<StocksConnection>;
  Stock: ResolverTypeWrapper<Stock>;
  StocksEdge: ResolverTypeWrapper<StocksEdge>;
  StocksOrderBy: StocksOrderBy;
  StockCondition: StockCondition;
  SurveysConnection: ResolverTypeWrapper<SurveysConnection>;
  Survey: ResolverTypeWrapper<Survey>;
  SurveysEdge: ResolverTypeWrapper<SurveysEdge>;
  SurveysOrderBy: SurveysOrderBy;
  SurveyCondition: SurveyCondition;
  TagsConnection: ResolverTypeWrapper<TagsConnection>;
  Tag: ResolverTypeWrapper<Tag>;
  TagsEdge: ResolverTypeWrapper<TagsEdge>;
  TagsOrderBy: TagsOrderBy;
  TagCondition: TagCondition;
  TargetsConnection: ResolverTypeWrapper<TargetsConnection>;
  Target: ResolverTypeWrapper<Target>;
  TargetsEdge: ResolverTypeWrapper<TargetsEdge>;
  TargetsOrderBy: TargetsOrderBy;
  TargetCondition: TargetCondition;
  TaxCategoriesConnection: ResolverTypeWrapper<TaxCategoriesConnection>;
  TaxCategory: ResolverTypeWrapper<TaxCategory>;
  TaxCategoriesEdge: ResolverTypeWrapper<TaxCategoriesEdge>;
  TaxCategoriesOrderBy: TaxCategoriesOrderBy;
  TaxCategoryCondition: TaxCategoryCondition;
  TaxRatesConnection: ResolverTypeWrapper<TaxRatesConnection>;
  TaxRate: ResolverTypeWrapper<TaxRate>;
  TaxRatesEdge: ResolverTypeWrapper<TaxRatesEdge>;
  TaxRatesOrderBy: TaxRatesOrderBy;
  TaxRateCondition: TaxRateCondition;
  TaxRulesConnection: ResolverTypeWrapper<TaxRulesConnection>;
  TaxRule: ResolverTypeWrapper<TaxRule>;
  TaxRulesEdge: ResolverTypeWrapper<TaxRulesEdge>;
  TaxRulesOrderBy: TaxRulesOrderBy;
  TaxRuleCondition: TaxRuleCondition;
  TemplatesConnection: ResolverTypeWrapper<TemplatesConnection>;
  Template: ResolverTypeWrapper<Template>;
  TemplatesEdge: ResolverTypeWrapper<TemplatesEdge>;
  TemplatesOrderBy: TemplatesOrderBy;
  TemplateCondition: TemplateCondition;
  ThemesConnection: ResolverTypeWrapper<ThemesConnection>;
  Theme: ResolverTypeWrapper<Theme>;
  ThemesEdge: ResolverTypeWrapper<ThemesEdge>;
  ThemesOrderBy: ThemesOrderBy;
  ThemeCondition: ThemeCondition;
  TicketingsConnection: ResolverTypeWrapper<TicketingsConnection>;
  Ticketing: ResolverTypeWrapper<Ticketing>;
  TicketingsEdge: ResolverTypeWrapper<TicketingsEdge>;
  TicketingsOrderBy: TicketingsOrderBy;
  TicketingCondition: TicketingCondition;
  TrainingsConnection: ResolverTypeWrapper<TrainingsConnection>;
  Training: ResolverTypeWrapper<Training>;
  TrainingsEdge: ResolverTypeWrapper<TrainingsEdge>;
  TrainingsOrderBy: TrainingsOrderBy;
  TrainingCondition: TrainingCondition;
  TransactionsConnection: ResolverTypeWrapper<TransactionsConnection>;
  Transaction: ResolverTypeWrapper<Transaction>;
  TransactionsEdge: ResolverTypeWrapper<TransactionsEdge>;
  TransactionsOrderBy: TransactionsOrderBy;
  TransactionCondition: TransactionCondition;
  UploadFilesConnection: ResolverTypeWrapper<UploadFilesConnection>;
  UploadFile: ResolverTypeWrapper<UploadFile>;
  UploadFilesEdge: ResolverTypeWrapper<UploadFilesEdge>;
  UploadFilesOrderBy: UploadFilesOrderBy;
  UploadFileCondition: UploadFileCondition;
  UsersConnection: ResolverTypeWrapper<UsersConnection>;
  User: ResolverTypeWrapper<User>;
  UsersEdge: ResolverTypeWrapper<UsersEdge>;
  UsersOrderBy: UsersOrderBy;
  UserCondition: UserCondition;
  VendorsConnection: ResolverTypeWrapper<VendorsConnection>;
  Vendor: ResolverTypeWrapper<Vendor>;
  VendorsEdge: ResolverTypeWrapper<VendorsEdge>;
  VendorsOrderBy: VendorsOrderBy;
  VendorCondition: VendorCondition;
  VisitsConnection: ResolverTypeWrapper<VisitsConnection>;
  Visit: ResolverTypeWrapper<Visit>;
  VisitsEdge: ResolverTypeWrapper<VisitsEdge>;
  VisitsOrderBy: VisitsOrderBy;
  VisitCondition: VisitCondition;
  WarehousesConnection: ResolverTypeWrapper<WarehousesConnection>;
  Warehouse: ResolverTypeWrapper<Warehouse>;
  WarehousesEdge: ResolverTypeWrapper<WarehousesEdge>;
  WarehousesOrderBy: WarehousesOrderBy;
  WarehouseCondition: WarehouseCondition;
  WebhooksConnection: ResolverTypeWrapper<WebhooksConnection>;
  Webhook: ResolverTypeWrapper<Webhook>;
  WebhooksEdge: ResolverTypeWrapper<WebhooksEdge>;
  WebhooksOrderBy: WebhooksOrderBy;
  WebhookCondition: WebhookCondition;
  WebsitesConnection: ResolverTypeWrapper<WebsitesConnection>;
  Website: ResolverTypeWrapper<Website>;
  WebsitesEdge: ResolverTypeWrapper<WebsitesEdge>;
  WebsitesOrderBy: WebsitesOrderBy;
  WebsiteCondition: WebsiteCondition;
  WishlistsConnection: ResolverTypeWrapper<WishlistsConnection>;
  Wishlist: ResolverTypeWrapper<Wishlist>;
  WishlistsEdge: ResolverTypeWrapper<WishlistsEdge>;
  WishlistsOrderBy: WishlistsOrderBy;
  WishlistCondition: WishlistCondition;
  WorkspacesConnection: ResolverTypeWrapper<WorkspacesConnection>;
  Workspace: ResolverTypeWrapper<Workspace>;
  WorkspacesEdge: ResolverTypeWrapper<WorkspacesEdge>;
  WorkspacesOrderBy: WorkspacesOrderBy;
  WorkspaceCondition: WorkspaceCondition;
  ZonesConnection: ResolverTypeWrapper<ZonesConnection>;
  Zone: ResolverTypeWrapper<Zone>;
  ZonesEdge: ResolverTypeWrapper<ZonesEdge>;
  ZonesOrderBy: ZonesOrderBy;
  ZoneCondition: ZoneCondition;
  Mutation: ResolverTypeWrapper<{}>;
  CreateAccountPayload: ResolverTypeWrapper<CreateAccountPayload>;
  CreateAccountInput: CreateAccountInput;
  AccountInput: AccountInput;
  CreateAgreementPayload: ResolverTypeWrapper<CreateAgreementPayload>;
  CreateAgreementInput: CreateAgreementInput;
  AgreementInput: AgreementInput;
  CreateAnalyticPayload: ResolverTypeWrapper<CreateAnalyticPayload>;
  CreateAnalyticInput: CreateAnalyticInput;
  AnalyticInput: AnalyticInput;
  CreateApitokenPayload: ResolverTypeWrapper<CreateApitokenPayload>;
  CreateApitokenInput: CreateApitokenInput;
  ApitokenInput: ApitokenInput;
  CreateArticlePayload: ResolverTypeWrapper<CreateArticlePayload>;
  CreateArticleInput: CreateArticleInput;
  ArticleInput: ArticleInput;
  CreateAttributePayload: ResolverTypeWrapper<CreateAttributePayload>;
  CreateAttributeInput: CreateAttributeInput;
  AttributeInput: AttributeInput;
  CreateBrandPayload: ResolverTypeWrapper<CreateBrandPayload>;
  CreateBrandInput: CreateBrandInput;
  BrandInput: BrandInput;
  CreateCartPriceRulePayload: ResolverTypeWrapper<CreateCartPriceRulePayload>;
  CreateCartPriceRuleInput: CreateCartPriceRuleInput;
  CartPriceRuleInput: CartPriceRuleInput;
  CreateCasePayload: ResolverTypeWrapper<CreateCasePayload>;
  CreateCaseInput: CreateCaseInput;
  CaseInput: CaseInput;
  CreateCatalogPriceRulePayload: ResolverTypeWrapper<CreateCatalogPriceRulePayload>;
  CreateCatalogPriceRuleInput: CreateCatalogPriceRuleInput;
  CatalogPriceRuleInput: CatalogPriceRuleInput;
  CreateCategoryPayload: ResolverTypeWrapper<CreateCategoryPayload>;
  CreateCategoryInput: CreateCategoryInput;
  CategoryInput: CategoryInput;
  CreateChannelPayload: ResolverTypeWrapper<CreateChannelPayload>;
  CreateChannelInput: CreateChannelInput;
  ChannelInput: ChannelInput;
  CreateChecklistPayload: ResolverTypeWrapper<CreateChecklistPayload>;
  CreateChecklistInput: CreateChecklistInput;
  ChecklistInput: ChecklistInput;
  CreateCityPayload: ResolverTypeWrapper<CreateCityPayload>;
  CreateCityInput: CreateCityInput;
  CityInput: CityInput;
  CreateCollectionPayload: ResolverTypeWrapper<CreateCollectionPayload>;
  CreateCollectionInput: CreateCollectionInput;
  CollectionInput: CollectionInput;
  CreateCommentPayload: ResolverTypeWrapper<CreateCommentPayload>;
  CreateCommentInput: CreateCommentInput;
  CommentInput: CommentInput;
  CreateContentTypePayload: ResolverTypeWrapper<CreateContentTypePayload>;
  CreateContentTypeInput: CreateContentTypeInput;
  ContentTypeInput: ContentTypeInput;
  CreateContractPayload: ResolverTypeWrapper<CreateContractPayload>;
  CreateContractInput: CreateContractInput;
  ContractInput: ContractInput;
  CreateCountryPayload: ResolverTypeWrapper<CreateCountryPayload>;
  CreateCountryInput: CreateCountryInput;
  CountryInput: CountryInput;
  CreateCouponPayload: ResolverTypeWrapper<CreateCouponPayload>;
  CreateCouponInput: CreateCouponInput;
  CouponInput: CouponInput;
  CreateCreditMemoPayload: ResolverTypeWrapper<CreateCreditMemoPayload>;
  CreateCreditMemoInput: CreateCreditMemoInput;
  CreditMemoInput: CreditMemoInput;
  CreateCurrencyPayload: ResolverTypeWrapper<CreateCurrencyPayload>;
  CreateCurrencyInput: CreateCurrencyInput;
  CurrencyInput: CurrencyInput;
  CreateCurrencyRatePayload: ResolverTypeWrapper<CreateCurrencyRatePayload>;
  CreateCurrencyRateInput: CreateCurrencyRateInput;
  CurrencyRateInput: CurrencyRateInput;
  CreateCurrencySymbolPayload: ResolverTypeWrapper<CreateCurrencySymbolPayload>;
  CreateCurrencySymbolInput: CreateCurrencySymbolInput;
  CurrencySymbolInput: CurrencySymbolInput;
  CreateCustomerGroupPayload: ResolverTypeWrapper<CreateCustomerGroupPayload>;
  CreateCustomerGroupInput: CreateCustomerGroupInput;
  CustomerGroupInput: CustomerGroupInput;
  CreateCustomerPayload: ResolverTypeWrapper<CreateCustomerPayload>;
  CreateCustomerInput: CreateCustomerInput;
  CustomerInput: CustomerInput;
  CreateCustomizationPayload: ResolverTypeWrapper<CreateCustomizationPayload>;
  CreateCustomizationInput: CreateCustomizationInput;
  CustomizationInput: CustomizationInput;
  CreateDashboardPayload: ResolverTypeWrapper<CreateDashboardPayload>;
  CreateDashboardInput: CreateDashboardInput;
  DashboardInput: DashboardInput;
  CreateDeepdivePayload: ResolverTypeWrapper<CreateDeepdivePayload>;
  CreateDeepdiveInput: CreateDeepdiveInput;
  DeepdiveInput: DeepdiveInput;
  CreateDigiboardPayload: ResolverTypeWrapper<CreateDigiboardPayload>;
  CreateDigiboardInput: CreateDigiboardInput;
  DigiboardInput: DigiboardInput;
  CreateEmailPayload: ResolverTypeWrapper<CreateEmailPayload>;
  CreateEmailInput: CreateEmailInput;
  EmailInput: EmailInput;
  CreateEndofshiftPayload: ResolverTypeWrapper<CreateEndofshiftPayload>;
  CreateEndofshiftInput: CreateEndofshiftInput;
  EndofshiftInput: EndofshiftInput;
  CreateEventPayload: ResolverTypeWrapper<CreateEventPayload>;
  CreateEventInput: CreateEventInput;
  EventInput: EventInput;
  CreateFullfillmentPayload: ResolverTypeWrapper<CreateFullfillmentPayload>;
  CreateFullfillmentInput: CreateFullfillmentInput;
  FullfillmentInput: FullfillmentInput;
  CreateGiftCertificatePayload: ResolverTypeWrapper<CreateGiftCertificatePayload>;
  CreateGiftCertificateInput: CreateGiftCertificateInput;
  GiftCertificateInput: GiftCertificateInput;
  CreateGlossaryPayload: ResolverTypeWrapper<CreateGlossaryPayload>;
  CreateGlossaryInput: CreateGlossaryInput;
  GlossaryInput: GlossaryInput;
  CreateImportmPayload: ResolverTypeWrapper<CreateImportmPayload>;
  CreateImportmInput: CreateImportmInput;
  ImportmInput: ImportmInput;
  CreateIntegrationPayload: ResolverTypeWrapper<CreateIntegrationPayload>;
  CreateIntegrationInput: CreateIntegrationInput;
  IntegrationInput: IntegrationInput;
  CreateInternalizationPayload: ResolverTypeWrapper<CreateInternalizationPayload>;
  CreateInternalizationInput: CreateInternalizationInput;
  InternalizationInput: InternalizationInput;
  CreateInvitationPayload: ResolverTypeWrapper<CreateInvitationPayload>;
  CreateInvitationInput: CreateInvitationInput;
  InvitationInput: InvitationInput;
  CreateInvoicePayload: ResolverTypeWrapper<CreateInvoicePayload>;
  CreateInvoiceInput: CreateInvoiceInput;
  InvoiceInput: InvoiceInput;
  CreateLeadPayload: ResolverTypeWrapper<CreateLeadPayload>;
  CreateLeadInput: CreateLeadInput;
  LeadInput: LeadInput;
  CreateManufacturerPayload: ResolverTypeWrapper<CreateManufacturerPayload>;
  CreateManufacturerInput: CreateManufacturerInput;
  ManufacturerInput: ManufacturerInput;
  CreateMediamanagerPayload: ResolverTypeWrapper<CreateMediamanagerPayload>;
  CreateMediamanagerInput: CreateMediamanagerInput;
  MediamanagerInput: MediamanagerInput;
  CreateMeetingPayload: ResolverTypeWrapper<CreateMeetingPayload>;
  CreateMeetingInput: CreateMeetingInput;
  MeetingInput: MeetingInput;
  CreateMessagePayload: ResolverTypeWrapper<CreateMessagePayload>;
  CreateMessageInput: CreateMessageInput;
  MessageInput: MessageInput;
  CreateNewsletterPayload: ResolverTypeWrapper<CreateNewsletterPayload>;
  CreateNewsletterInput: CreateNewsletterInput;
  NewsletterInput: NewsletterInput;
  CreateOotoPayload: ResolverTypeWrapper<CreateOotoPayload>;
  CreateOotoInput: CreateOotoInput;
  OotoInput: OotoInput;
  CreateOpportunityPayload: ResolverTypeWrapper<CreateOpportunityPayload>;
  CreateOpportunityInput: CreateOpportunityInput;
  OpportunityInput: OpportunityInput;
  CreateOrderPayload: ResolverTypeWrapper<CreateOrderPayload>;
  CreateOrderInput: CreateOrderInput;
  OrderInput: OrderInput;
  CreatePagePayload: ResolverTypeWrapper<CreatePagePayload>;
  CreatePageInput: CreatePageInput;
  PageInput: PageInput;
  CreatePartnerPayload: ResolverTypeWrapper<CreatePartnerPayload>;
  CreatePartnerInput: CreatePartnerInput;
  PartnerInput: PartnerInput;
  CreatePaymentPayload: ResolverTypeWrapper<CreatePaymentPayload>;
  CreatePaymentInput: CreatePaymentInput;
  PaymentInput: PaymentInput;
  CreatePermissionPayload: ResolverTypeWrapper<CreatePermissionPayload>;
  CreatePermissionInput: CreatePermissionInput;
  PermissionInput: PermissionInput;
  CreatePluginPayload: ResolverTypeWrapper<CreatePluginPayload>;
  CreatePluginInput: CreatePluginInput;
  PluginInput: PluginInput;
  CreatePollPayload: ResolverTypeWrapper<CreatePollPayload>;
  CreatePollInput: CreatePollInput;
  PollInput: PollInput;
  CreateProductTypePayload: ResolverTypeWrapper<CreateProductTypePayload>;
  CreateProductTypeInput: CreateProductTypeInput;
  ProductTypeInput: ProductTypeInput;
  CreateProductPayload: ResolverTypeWrapper<CreateProductPayload>;
  CreateProductInput: CreateProductInput;
  ProductInput: ProductInput;
  CreateProjectPayload: ResolverTypeWrapper<CreateProjectPayload>;
  CreateProjectInput: CreateProjectInput;
  ProjectInput: ProjectInput;
  CreateProviderPayload: ResolverTypeWrapper<CreateProviderPayload>;
  CreateProviderInput: CreateProviderInput;
  ProviderInput: ProviderInput;
  CreateQuotePayload: ResolverTypeWrapper<CreateQuotePayload>;
  CreateQuoteInput: CreateQuoteInput;
  QuoteInput: QuoteInput;
  CreateRatingPayload: ResolverTypeWrapper<CreateRatingPayload>;
  CreateRatingInput: CreateRatingInput;
  RatingInput: RatingInput;
  CreateReportPayload: ResolverTypeWrapper<CreateReportPayload>;
  CreateReportInput: CreateReportInput;
  ReportInput: ReportInput;
  CreateReturnPayload: ResolverTypeWrapper<CreateReturnPayload>;
  CreateReturnInput: CreateReturnInput;
  ReturnInput: ReturnInput;
  CreateReviewPayload: ResolverTypeWrapper<CreateReviewPayload>;
  CreateReviewInput: CreateReviewInput;
  ReviewInput: ReviewInput;
  CreateRewardPayload: ResolverTypeWrapper<CreateRewardPayload>;
  CreateRewardInput: CreateRewardInput;
  RewardInput: RewardInput;
  CreateRolePayload: ResolverTypeWrapper<CreateRolePayload>;
  CreateRoleInput: CreateRoleInput;
  RoleInput: RoleInput;
  CreateSchedulerPayload: ResolverTypeWrapper<CreateSchedulerPayload>;
  CreateSchedulerInput: CreateSchedulerInput;
  SchedulerInput: SchedulerInput;
  CreateSegmentPayload: ResolverTypeWrapper<CreateSegmentPayload>;
  CreateSegmentInput: CreateSegmentInput;
  SegmentInput: SegmentInput;
  CreateSettingPayload: ResolverTypeWrapper<CreateSettingPayload>;
  CreateSettingInput: CreateSettingInput;
  SettingInput: SettingInput;
  CreateShipmentPayload: ResolverTypeWrapper<CreateShipmentPayload>;
  CreateShipmentInput: CreateShipmentInput;
  ShipmentInput: ShipmentInput;
  CreateSpecialDiscountPayload: ResolverTypeWrapper<CreateSpecialDiscountPayload>;
  CreateSpecialDiscountInput: CreateSpecialDiscountInput;
  SpecialDiscountInput: SpecialDiscountInput;
  CreateStatePayload: ResolverTypeWrapper<CreateStatePayload>;
  CreateStateInput: CreateStateInput;
  StateInput: StateInput;
  CreateStatisticPayload: ResolverTypeWrapper<CreateStatisticPayload>;
  CreateStatisticInput: CreateStatisticInput;
  StatisticInput: StatisticInput;
  CreateStockPayload: ResolverTypeWrapper<CreateStockPayload>;
  CreateStockInput: CreateStockInput;
  StockInput: StockInput;
  CreateSurveyPayload: ResolverTypeWrapper<CreateSurveyPayload>;
  CreateSurveyInput: CreateSurveyInput;
  SurveyInput: SurveyInput;
  CreateTagPayload: ResolverTypeWrapper<CreateTagPayload>;
  CreateTagInput: CreateTagInput;
  TagInput: TagInput;
  CreateTargetPayload: ResolverTypeWrapper<CreateTargetPayload>;
  CreateTargetInput: CreateTargetInput;
  TargetInput: TargetInput;
  CreateTaxCategoryPayload: ResolverTypeWrapper<CreateTaxCategoryPayload>;
  CreateTaxCategoryInput: CreateTaxCategoryInput;
  TaxCategoryInput: TaxCategoryInput;
  CreateTaxRatePayload: ResolverTypeWrapper<CreateTaxRatePayload>;
  CreateTaxRateInput: CreateTaxRateInput;
  TaxRateInput: TaxRateInput;
  CreateTaxRulePayload: ResolverTypeWrapper<CreateTaxRulePayload>;
  CreateTaxRuleInput: CreateTaxRuleInput;
  TaxRuleInput: TaxRuleInput;
  CreateTemplatePayload: ResolverTypeWrapper<CreateTemplatePayload>;
  CreateTemplateInput: CreateTemplateInput;
  TemplateInput: TemplateInput;
  CreateThemePayload: ResolverTypeWrapper<CreateThemePayload>;
  CreateThemeInput: CreateThemeInput;
  ThemeInput: ThemeInput;
  CreateTicketingPayload: ResolverTypeWrapper<CreateTicketingPayload>;
  CreateTicketingInput: CreateTicketingInput;
  TicketingInput: TicketingInput;
  CreateTrainingPayload: ResolverTypeWrapper<CreateTrainingPayload>;
  CreateTrainingInput: CreateTrainingInput;
  TrainingInput: TrainingInput;
  CreateTransactionPayload: ResolverTypeWrapper<CreateTransactionPayload>;
  CreateTransactionInput: CreateTransactionInput;
  TransactionInput: TransactionInput;
  CreateUploadFilePayload: ResolverTypeWrapper<CreateUploadFilePayload>;
  CreateUploadFileInput: CreateUploadFileInput;
  UploadFileInput: UploadFileInput;
  CreateUserPayload: ResolverTypeWrapper<CreateUserPayload>;
  CreateUserInput: CreateUserInput;
  UserInput: UserInput;
  CreateVendorPayload: ResolverTypeWrapper<CreateVendorPayload>;
  CreateVendorInput: CreateVendorInput;
  VendorInput: VendorInput;
  CreateVisitPayload: ResolverTypeWrapper<CreateVisitPayload>;
  CreateVisitInput: CreateVisitInput;
  VisitInput: VisitInput;
  CreateWarehousePayload: ResolverTypeWrapper<CreateWarehousePayload>;
  CreateWarehouseInput: CreateWarehouseInput;
  WarehouseInput: WarehouseInput;
  CreateWebhookPayload: ResolverTypeWrapper<CreateWebhookPayload>;
  CreateWebhookInput: CreateWebhookInput;
  WebhookInput: WebhookInput;
  CreateWebsitePayload: ResolverTypeWrapper<CreateWebsitePayload>;
  CreateWebsiteInput: CreateWebsiteInput;
  WebsiteInput: WebsiteInput;
  CreateWishlistPayload: ResolverTypeWrapper<CreateWishlistPayload>;
  CreateWishlistInput: CreateWishlistInput;
  WishlistInput: WishlistInput;
  CreateWorkspacePayload: ResolverTypeWrapper<CreateWorkspacePayload>;
  CreateWorkspaceInput: CreateWorkspaceInput;
  WorkspaceInput: WorkspaceInput;
  CreateZonePayload: ResolverTypeWrapper<CreateZonePayload>;
  CreateZoneInput: CreateZoneInput;
  ZoneInput: ZoneInput;
  UpdateAccountPayload: ResolverTypeWrapper<UpdateAccountPayload>;
  UpdateAccountInput: UpdateAccountInput;
  AccountPatch: AccountPatch;
  UpdateAccountByIdInput: UpdateAccountByIdInput;
  UpdateAgreementPayload: ResolverTypeWrapper<UpdateAgreementPayload>;
  UpdateAgreementInput: UpdateAgreementInput;
  AgreementPatch: AgreementPatch;
  UpdateAgreementByIdInput: UpdateAgreementByIdInput;
  UpdateAnalyticPayload: ResolverTypeWrapper<UpdateAnalyticPayload>;
  UpdateAnalyticInput: UpdateAnalyticInput;
  AnalyticPatch: AnalyticPatch;
  UpdateAnalyticByIdInput: UpdateAnalyticByIdInput;
  UpdateApitokenPayload: ResolverTypeWrapper<UpdateApitokenPayload>;
  UpdateApitokenInput: UpdateApitokenInput;
  ApitokenPatch: ApitokenPatch;
  UpdateApitokenByIdInput: UpdateApitokenByIdInput;
  UpdateArticlePayload: ResolverTypeWrapper<UpdateArticlePayload>;
  UpdateArticleInput: UpdateArticleInput;
  ArticlePatch: ArticlePatch;
  UpdateArticleByIdInput: UpdateArticleByIdInput;
  UpdateAttributePayload: ResolverTypeWrapper<UpdateAttributePayload>;
  UpdateAttributeInput: UpdateAttributeInput;
  AttributePatch: AttributePatch;
  UpdateAttributeByIdInput: UpdateAttributeByIdInput;
  UpdateBrandPayload: ResolverTypeWrapper<UpdateBrandPayload>;
  UpdateBrandInput: UpdateBrandInput;
  BrandPatch: BrandPatch;
  UpdateBrandByIdInput: UpdateBrandByIdInput;
  UpdateCartPriceRulePayload: ResolverTypeWrapper<UpdateCartPriceRulePayload>;
  UpdateCartPriceRuleInput: UpdateCartPriceRuleInput;
  CartPriceRulePatch: CartPriceRulePatch;
  UpdateCartPriceRuleByIdInput: UpdateCartPriceRuleByIdInput;
  UpdateCasePayload: ResolverTypeWrapper<UpdateCasePayload>;
  UpdateCaseInput: UpdateCaseInput;
  CasePatch: CasePatch;
  UpdateCaseByIdInput: UpdateCaseByIdInput;
  UpdateCatalogPriceRulePayload: ResolverTypeWrapper<UpdateCatalogPriceRulePayload>;
  UpdateCatalogPriceRuleInput: UpdateCatalogPriceRuleInput;
  CatalogPriceRulePatch: CatalogPriceRulePatch;
  UpdateCatalogPriceRuleByIdInput: UpdateCatalogPriceRuleByIdInput;
  UpdateCategoryPayload: ResolverTypeWrapper<UpdateCategoryPayload>;
  UpdateCategoryInput: UpdateCategoryInput;
  CategoryPatch: CategoryPatch;
  UpdateCategoryByIdInput: UpdateCategoryByIdInput;
  UpdateChannelPayload: ResolverTypeWrapper<UpdateChannelPayload>;
  UpdateChannelInput: UpdateChannelInput;
  ChannelPatch: ChannelPatch;
  UpdateChannelByIdInput: UpdateChannelByIdInput;
  UpdateChecklistPayload: ResolverTypeWrapper<UpdateChecklistPayload>;
  UpdateChecklistInput: UpdateChecklistInput;
  ChecklistPatch: ChecklistPatch;
  UpdateChecklistByIdInput: UpdateChecklistByIdInput;
  UpdateCityPayload: ResolverTypeWrapper<UpdateCityPayload>;
  UpdateCityInput: UpdateCityInput;
  CityPatch: CityPatch;
  UpdateCityByIdInput: UpdateCityByIdInput;
  UpdateCollectionPayload: ResolverTypeWrapper<UpdateCollectionPayload>;
  UpdateCollectionInput: UpdateCollectionInput;
  CollectionPatch: CollectionPatch;
  UpdateCollectionByIdInput: UpdateCollectionByIdInput;
  UpdateCommentPayload: ResolverTypeWrapper<UpdateCommentPayload>;
  UpdateCommentInput: UpdateCommentInput;
  CommentPatch: CommentPatch;
  UpdateCommentByIdInput: UpdateCommentByIdInput;
  UpdateContentTypePayload: ResolverTypeWrapper<UpdateContentTypePayload>;
  UpdateContentTypeInput: UpdateContentTypeInput;
  ContentTypePatch: ContentTypePatch;
  UpdateContentTypeByIdInput: UpdateContentTypeByIdInput;
  UpdateContractPayload: ResolverTypeWrapper<UpdateContractPayload>;
  UpdateContractInput: UpdateContractInput;
  ContractPatch: ContractPatch;
  UpdateContractByIdInput: UpdateContractByIdInput;
  UpdateCountryPayload: ResolverTypeWrapper<UpdateCountryPayload>;
  UpdateCountryInput: UpdateCountryInput;
  CountryPatch: CountryPatch;
  UpdateCountryByIdInput: UpdateCountryByIdInput;
  UpdateCouponPayload: ResolverTypeWrapper<UpdateCouponPayload>;
  UpdateCouponInput: UpdateCouponInput;
  CouponPatch: CouponPatch;
  UpdateCouponByIdInput: UpdateCouponByIdInput;
  UpdateCreditMemoPayload: ResolverTypeWrapper<UpdateCreditMemoPayload>;
  UpdateCreditMemoInput: UpdateCreditMemoInput;
  CreditMemoPatch: CreditMemoPatch;
  UpdateCreditMemoByCreditMemoAndIdInput: UpdateCreditMemoByCreditMemoAndIdInput;
  UpdateCurrencyPayload: ResolverTypeWrapper<UpdateCurrencyPayload>;
  UpdateCurrencyInput: UpdateCurrencyInput;
  CurrencyPatch: CurrencyPatch;
  UpdateCurrencyByIdInput: UpdateCurrencyByIdInput;
  UpdateCurrencyRatePayload: ResolverTypeWrapper<UpdateCurrencyRatePayload>;
  UpdateCurrencyRateInput: UpdateCurrencyRateInput;
  CurrencyRatePatch: CurrencyRatePatch;
  UpdateCurrencyRateByImportServiceInput: UpdateCurrencyRateByImportServiceInput;
  UpdateCurrencySymbolPayload: ResolverTypeWrapper<UpdateCurrencySymbolPayload>;
  UpdateCurrencySymbolInput: UpdateCurrencySymbolInput;
  CurrencySymbolPatch: CurrencySymbolPatch;
  UpdateCurrencySymbolBySymbolInput: UpdateCurrencySymbolBySymbolInput;
  UpdateCustomerGroupPayload: ResolverTypeWrapper<UpdateCustomerGroupPayload>;
  UpdateCustomerGroupInput: UpdateCustomerGroupInput;
  CustomerGroupPatch: CustomerGroupPatch;
  UpdateCustomerGroupByIdInput: UpdateCustomerGroupByIdInput;
  UpdateCustomerPayload: ResolverTypeWrapper<UpdateCustomerPayload>;
  UpdateCustomerInput: UpdateCustomerInput;
  CustomerPatch: CustomerPatch;
  UpdateCustomerByIdInput: UpdateCustomerByIdInput;
  UpdateCustomizationPayload: ResolverTypeWrapper<UpdateCustomizationPayload>;
  UpdateCustomizationInput: UpdateCustomizationInput;
  CustomizationPatch: CustomizationPatch;
  UpdateCustomizationByIdInput: UpdateCustomizationByIdInput;
  UpdateDashboardPayload: ResolverTypeWrapper<UpdateDashboardPayload>;
  UpdateDashboardInput: UpdateDashboardInput;
  DashboardPatch: DashboardPatch;
  UpdateDashboardByIdInput: UpdateDashboardByIdInput;
  UpdateDeepdivePayload: ResolverTypeWrapper<UpdateDeepdivePayload>;
  UpdateDeepdiveInput: UpdateDeepdiveInput;
  DeepdivePatch: DeepdivePatch;
  UpdateDeepdiveByIdInput: UpdateDeepdiveByIdInput;
  UpdateDigiboardPayload: ResolverTypeWrapper<UpdateDigiboardPayload>;
  UpdateDigiboardInput: UpdateDigiboardInput;
  DigiboardPatch: DigiboardPatch;
  UpdateDigiboardByIdInput: UpdateDigiboardByIdInput;
  UpdateEmailPayload: ResolverTypeWrapper<UpdateEmailPayload>;
  UpdateEmailInput: UpdateEmailInput;
  EmailPatch: EmailPatch;
  UpdateEmailByIdInput: UpdateEmailByIdInput;
  UpdateEndofshiftPayload: ResolverTypeWrapper<UpdateEndofshiftPayload>;
  UpdateEndofshiftInput: UpdateEndofshiftInput;
  EndofshiftPatch: EndofshiftPatch;
  UpdateEndofshiftByIdInput: UpdateEndofshiftByIdInput;
  UpdateEventPayload: ResolverTypeWrapper<UpdateEventPayload>;
  UpdateEventInput: UpdateEventInput;
  EventPatch: EventPatch;
  UpdateEventByIdInput: UpdateEventByIdInput;
  UpdateFullfillmentPayload: ResolverTypeWrapper<UpdateFullfillmentPayload>;
  UpdateFullfillmentInput: UpdateFullfillmentInput;
  FullfillmentPatch: FullfillmentPatch;
  UpdateFullfillmentByIdInput: UpdateFullfillmentByIdInput;
  UpdateGiftCertificatePayload: ResolverTypeWrapper<UpdateGiftCertificatePayload>;
  UpdateGiftCertificateInput: UpdateGiftCertificateInput;
  GiftCertificatePatch: GiftCertificatePatch;
  UpdateGiftCertificateByIdInput: UpdateGiftCertificateByIdInput;
  UpdateGlossaryPayload: ResolverTypeWrapper<UpdateGlossaryPayload>;
  UpdateGlossaryInput: UpdateGlossaryInput;
  GlossaryPatch: GlossaryPatch;
  UpdateGlossaryByIdInput: UpdateGlossaryByIdInput;
  UpdateImportmPayload: ResolverTypeWrapper<UpdateImportmPayload>;
  UpdateImportmInput: UpdateImportmInput;
  ImportmPatch: ImportmPatch;
  UpdateImportmByIdInput: UpdateImportmByIdInput;
  UpdateIntegrationPayload: ResolverTypeWrapper<UpdateIntegrationPayload>;
  UpdateIntegrationInput: UpdateIntegrationInput;
  IntegrationPatch: IntegrationPatch;
  UpdateIntegrationByIdInput: UpdateIntegrationByIdInput;
  UpdateInternalizationPayload: ResolverTypeWrapper<UpdateInternalizationPayload>;
  UpdateInternalizationInput: UpdateInternalizationInput;
  InternalizationPatch: InternalizationPatch;
  UpdateInternalizationByIdInput: UpdateInternalizationByIdInput;
  UpdateInvitationPayload: ResolverTypeWrapper<UpdateInvitationPayload>;
  UpdateInvitationInput: UpdateInvitationInput;
  InvitationPatch: InvitationPatch;
  UpdateInvitationByIdInput: UpdateInvitationByIdInput;
  UpdateInvoicePayload: ResolverTypeWrapper<UpdateInvoicePayload>;
  UpdateInvoiceInput: UpdateInvoiceInput;
  InvoicePatch: InvoicePatch;
  UpdateInvoiceByIdInput: UpdateInvoiceByIdInput;
  UpdateLeadPayload: ResolverTypeWrapper<UpdateLeadPayload>;
  UpdateLeadInput: UpdateLeadInput;
  LeadPatch: LeadPatch;
  UpdateLeadByIdInput: UpdateLeadByIdInput;
  UpdateManufacturerPayload: ResolverTypeWrapper<UpdateManufacturerPayload>;
  UpdateManufacturerInput: UpdateManufacturerInput;
  ManufacturerPatch: ManufacturerPatch;
  UpdateManufacturerByIdInput: UpdateManufacturerByIdInput;
  UpdateMediamanagerPayload: ResolverTypeWrapper<UpdateMediamanagerPayload>;
  UpdateMediamanagerInput: UpdateMediamanagerInput;
  MediamanagerPatch: MediamanagerPatch;
  UpdateMediamanagerByIdInput: UpdateMediamanagerByIdInput;
  UpdateMeetingPayload: ResolverTypeWrapper<UpdateMeetingPayload>;
  UpdateMeetingInput: UpdateMeetingInput;
  MeetingPatch: MeetingPatch;
  UpdateMeetingByIdInput: UpdateMeetingByIdInput;
  UpdateMessagePayload: ResolverTypeWrapper<UpdateMessagePayload>;
  UpdateMessageInput: UpdateMessageInput;
  MessagePatch: MessagePatch;
  UpdateMessageByIdInput: UpdateMessageByIdInput;
  UpdateNewsletterPayload: ResolverTypeWrapper<UpdateNewsletterPayload>;
  UpdateNewsletterInput: UpdateNewsletterInput;
  NewsletterPatch: NewsletterPatch;
  UpdateNewsletterByIdInput: UpdateNewsletterByIdInput;
  UpdateOotoPayload: ResolverTypeWrapper<UpdateOotoPayload>;
  UpdateOotoInput: UpdateOotoInput;
  OotoPatch: OotoPatch;
  UpdateOotoByIdInput: UpdateOotoByIdInput;
  UpdateOpportunityPayload: ResolverTypeWrapper<UpdateOpportunityPayload>;
  UpdateOpportunityInput: UpdateOpportunityInput;
  OpportunityPatch: OpportunityPatch;
  UpdateOpportunityByIdInput: UpdateOpportunityByIdInput;
  UpdateOrderPayload: ResolverTypeWrapper<UpdateOrderPayload>;
  UpdateOrderInput: UpdateOrderInput;
  OrderPatch: OrderPatch;
  UpdateOrderByIdInput: UpdateOrderByIdInput;
  UpdatePagePayload: ResolverTypeWrapper<UpdatePagePayload>;
  UpdatePageInput: UpdatePageInput;
  PagePatch: PagePatch;
  UpdatePageByIdInput: UpdatePageByIdInput;
  UpdatePartnerPayload: ResolverTypeWrapper<UpdatePartnerPayload>;
  UpdatePartnerInput: UpdatePartnerInput;
  PartnerPatch: PartnerPatch;
  UpdatePartnerByIdInput: UpdatePartnerByIdInput;
  UpdatePaymentPayload: ResolverTypeWrapper<UpdatePaymentPayload>;
  UpdatePaymentInput: UpdatePaymentInput;
  PaymentPatch: PaymentPatch;
  UpdatePaymentByIdInput: UpdatePaymentByIdInput;
  UpdatePermissionPayload: ResolverTypeWrapper<UpdatePermissionPayload>;
  UpdatePermissionInput: UpdatePermissionInput;
  PermissionPatch: PermissionPatch;
  UpdatePermissionByIdInput: UpdatePermissionByIdInput;
  UpdatePluginPayload: ResolverTypeWrapper<UpdatePluginPayload>;
  UpdatePluginInput: UpdatePluginInput;
  PluginPatch: PluginPatch;
  UpdatePluginByIdInput: UpdatePluginByIdInput;
  UpdatePollPayload: ResolverTypeWrapper<UpdatePollPayload>;
  UpdatePollInput: UpdatePollInput;
  PollPatch: PollPatch;
  UpdatePollByIdInput: UpdatePollByIdInput;
  UpdateProductTypePayload: ResolverTypeWrapper<UpdateProductTypePayload>;
  UpdateProductTypeInput: UpdateProductTypeInput;
  ProductTypePatch: ProductTypePatch;
  UpdateProductTypeByIdInput: UpdateProductTypeByIdInput;
  UpdateProductPayload: ResolverTypeWrapper<UpdateProductPayload>;
  UpdateProductInput: UpdateProductInput;
  ProductPatch: ProductPatch;
  UpdateProductByIdInput: UpdateProductByIdInput;
  UpdateProjectPayload: ResolverTypeWrapper<UpdateProjectPayload>;
  UpdateProjectInput: UpdateProjectInput;
  ProjectPatch: ProjectPatch;
  UpdateProjectByIdInput: UpdateProjectByIdInput;
  UpdateProviderPayload: ResolverTypeWrapper<UpdateProviderPayload>;
  UpdateProviderInput: UpdateProviderInput;
  ProviderPatch: ProviderPatch;
  UpdateProviderByIdInput: UpdateProviderByIdInput;
  UpdateQuotePayload: ResolverTypeWrapper<UpdateQuotePayload>;
  UpdateQuoteInput: UpdateQuoteInput;
  QuotePatch: QuotePatch;
  UpdateQuoteByIdInput: UpdateQuoteByIdInput;
  UpdateRatingPayload: ResolverTypeWrapper<UpdateRatingPayload>;
  UpdateRatingInput: UpdateRatingInput;
  RatingPatch: RatingPatch;
  UpdateRatingByIdInput: UpdateRatingByIdInput;
  UpdateReportPayload: ResolverTypeWrapper<UpdateReportPayload>;
  UpdateReportInput: UpdateReportInput;
  ReportPatch: ReportPatch;
  UpdateReportByIdInput: UpdateReportByIdInput;
  UpdateReturnPayload: ResolverTypeWrapper<UpdateReturnPayload>;
  UpdateReturnInput: UpdateReturnInput;
  ReturnPatch: ReturnPatch;
  UpdateReturnByIdInput: UpdateReturnByIdInput;
  UpdateReviewPayload: ResolverTypeWrapper<UpdateReviewPayload>;
  UpdateReviewInput: UpdateReviewInput;
  ReviewPatch: ReviewPatch;
  UpdateReviewByIdInput: UpdateReviewByIdInput;
  UpdateRewardPayload: ResolverTypeWrapper<UpdateRewardPayload>;
  UpdateRewardInput: UpdateRewardInput;
  RewardPatch: RewardPatch;
  UpdateRewardByIdInput: UpdateRewardByIdInput;
  UpdateRolePayload: ResolverTypeWrapper<UpdateRolePayload>;
  UpdateRoleInput: UpdateRoleInput;
  RolePatch: RolePatch;
  UpdateRoleByIdInput: UpdateRoleByIdInput;
  UpdateSchedulerPayload: ResolverTypeWrapper<UpdateSchedulerPayload>;
  UpdateSchedulerInput: UpdateSchedulerInput;
  SchedulerPatch: SchedulerPatch;
  UpdateSchedulerByIdInput: UpdateSchedulerByIdInput;
  UpdateSegmentPayload: ResolverTypeWrapper<UpdateSegmentPayload>;
  UpdateSegmentInput: UpdateSegmentInput;
  SegmentPatch: SegmentPatch;
  UpdateSegmentByIdInput: UpdateSegmentByIdInput;
  UpdateSettingPayload: ResolverTypeWrapper<UpdateSettingPayload>;
  UpdateSettingInput: UpdateSettingInput;
  SettingPatch: SettingPatch;
  UpdateSettingByIdInput: UpdateSettingByIdInput;
  UpdateShipmentPayload: ResolverTypeWrapper<UpdateShipmentPayload>;
  UpdateShipmentInput: UpdateShipmentInput;
  ShipmentPatch: ShipmentPatch;
  UpdateShipmentByIdInput: UpdateShipmentByIdInput;
  UpdateSpecialDiscountPayload: ResolverTypeWrapper<UpdateSpecialDiscountPayload>;
  UpdateSpecialDiscountInput: UpdateSpecialDiscountInput;
  SpecialDiscountPatch: SpecialDiscountPatch;
  UpdateSpecialDiscountByIdInput: UpdateSpecialDiscountByIdInput;
  UpdateStatePayload: ResolverTypeWrapper<UpdateStatePayload>;
  UpdateStateInput: UpdateStateInput;
  StatePatch: StatePatch;
  UpdateStateByIdInput: UpdateStateByIdInput;
  UpdateStatisticPayload: ResolverTypeWrapper<UpdateStatisticPayload>;
  UpdateStatisticInput: UpdateStatisticInput;
  StatisticPatch: StatisticPatch;
  UpdateStatisticByIdInput: UpdateStatisticByIdInput;
  UpdateStockPayload: ResolverTypeWrapper<UpdateStockPayload>;
  UpdateStockInput: UpdateStockInput;
  StockPatch: StockPatch;
  UpdateStockByIdInput: UpdateStockByIdInput;
  UpdateSurveyPayload: ResolverTypeWrapper<UpdateSurveyPayload>;
  UpdateSurveyInput: UpdateSurveyInput;
  SurveyPatch: SurveyPatch;
  UpdateSurveyByIdInput: UpdateSurveyByIdInput;
  UpdateTagPayload: ResolverTypeWrapper<UpdateTagPayload>;
  UpdateTagInput: UpdateTagInput;
  TagPatch: TagPatch;
  UpdateTagByIdInput: UpdateTagByIdInput;
  UpdateTargetPayload: ResolverTypeWrapper<UpdateTargetPayload>;
  UpdateTargetInput: UpdateTargetInput;
  TargetPatch: TargetPatch;
  UpdateTargetByIdInput: UpdateTargetByIdInput;
  UpdateTaxCategoryPayload: ResolverTypeWrapper<UpdateTaxCategoryPayload>;
  UpdateTaxCategoryInput: UpdateTaxCategoryInput;
  TaxCategoryPatch: TaxCategoryPatch;
  UpdateTaxCategoryByIdInput: UpdateTaxCategoryByIdInput;
  UpdateTaxRatePayload: ResolverTypeWrapper<UpdateTaxRatePayload>;
  UpdateTaxRateInput: UpdateTaxRateInput;
  TaxRatePatch: TaxRatePatch;
  UpdateTaxRateByIdInput: UpdateTaxRateByIdInput;
  UpdateTaxRulePayload: ResolverTypeWrapper<UpdateTaxRulePayload>;
  UpdateTaxRuleInput: UpdateTaxRuleInput;
  TaxRulePatch: TaxRulePatch;
  UpdateTaxRuleByIdInput: UpdateTaxRuleByIdInput;
  UpdateTemplatePayload: ResolverTypeWrapper<UpdateTemplatePayload>;
  UpdateTemplateInput: UpdateTemplateInput;
  TemplatePatch: TemplatePatch;
  UpdateTemplateByIdInput: UpdateTemplateByIdInput;
  UpdateThemePayload: ResolverTypeWrapper<UpdateThemePayload>;
  UpdateThemeInput: UpdateThemeInput;
  ThemePatch: ThemePatch;
  UpdateThemeByIdInput: UpdateThemeByIdInput;
  UpdateTicketingPayload: ResolverTypeWrapper<UpdateTicketingPayload>;
  UpdateTicketingInput: UpdateTicketingInput;
  TicketingPatch: TicketingPatch;
  UpdateTicketingByIdInput: UpdateTicketingByIdInput;
  UpdateTrainingPayload: ResolverTypeWrapper<UpdateTrainingPayload>;
  UpdateTrainingInput: UpdateTrainingInput;
  TrainingPatch: TrainingPatch;
  UpdateTrainingByIdInput: UpdateTrainingByIdInput;
  UpdateTransactionPayload: ResolverTypeWrapper<UpdateTransactionPayload>;
  UpdateTransactionInput: UpdateTransactionInput;
  TransactionPatch: TransactionPatch;
  UpdateTransactionByIdInput: UpdateTransactionByIdInput;
  UpdateUploadFilePayload: ResolverTypeWrapper<UpdateUploadFilePayload>;
  UpdateUploadFileInput: UpdateUploadFileInput;
  UploadFilePatch: UploadFilePatch;
  UpdateUploadFileByIdInput: UpdateUploadFileByIdInput;
  UpdateUserPayload: ResolverTypeWrapper<UpdateUserPayload>;
  UpdateUserInput: UpdateUserInput;
  UserPatch: UserPatch;
  UpdateUserByIdInput: UpdateUserByIdInput;
  UpdateVendorPayload: ResolverTypeWrapper<UpdateVendorPayload>;
  UpdateVendorInput: UpdateVendorInput;
  VendorPatch: VendorPatch;
  UpdateVendorByIdInput: UpdateVendorByIdInput;
  UpdateVisitPayload: ResolverTypeWrapper<UpdateVisitPayload>;
  UpdateVisitInput: UpdateVisitInput;
  VisitPatch: VisitPatch;
  UpdateVisitByIdInput: UpdateVisitByIdInput;
  UpdateWarehousePayload: ResolverTypeWrapper<UpdateWarehousePayload>;
  UpdateWarehouseInput: UpdateWarehouseInput;
  WarehousePatch: WarehousePatch;
  UpdateWarehouseByIdInput: UpdateWarehouseByIdInput;
  UpdateWebhookPayload: ResolverTypeWrapper<UpdateWebhookPayload>;
  UpdateWebhookInput: UpdateWebhookInput;
  WebhookPatch: WebhookPatch;
  UpdateWebhookByIdInput: UpdateWebhookByIdInput;
  UpdateWebsitePayload: ResolverTypeWrapper<UpdateWebsitePayload>;
  UpdateWebsiteInput: UpdateWebsiteInput;
  WebsitePatch: WebsitePatch;
  UpdateWebsiteByIdInput: UpdateWebsiteByIdInput;
  UpdateWishlistPayload: ResolverTypeWrapper<UpdateWishlistPayload>;
  UpdateWishlistInput: UpdateWishlistInput;
  WishlistPatch: WishlistPatch;
  UpdateWishlistByIdInput: UpdateWishlistByIdInput;
  UpdateWorkspacePayload: ResolverTypeWrapper<UpdateWorkspacePayload>;
  UpdateWorkspaceInput: UpdateWorkspaceInput;
  WorkspacePatch: WorkspacePatch;
  UpdateWorkspaceByIdInput: UpdateWorkspaceByIdInput;
  UpdateZonePayload: ResolverTypeWrapper<UpdateZonePayload>;
  UpdateZoneInput: UpdateZoneInput;
  ZonePatch: ZonePatch;
  UpdateZoneByIdInput: UpdateZoneByIdInput;
  DeleteAccountPayload: ResolverTypeWrapper<DeleteAccountPayload>;
  DeleteAccountInput: DeleteAccountInput;
  DeleteAccountByIdInput: DeleteAccountByIdInput;
  DeleteAgreementPayload: ResolverTypeWrapper<DeleteAgreementPayload>;
  DeleteAgreementInput: DeleteAgreementInput;
  DeleteAgreementByIdInput: DeleteAgreementByIdInput;
  DeleteAnalyticPayload: ResolverTypeWrapper<DeleteAnalyticPayload>;
  DeleteAnalyticInput: DeleteAnalyticInput;
  DeleteAnalyticByIdInput: DeleteAnalyticByIdInput;
  DeleteApitokenPayload: ResolverTypeWrapper<DeleteApitokenPayload>;
  DeleteApitokenInput: DeleteApitokenInput;
  DeleteApitokenByIdInput: DeleteApitokenByIdInput;
  DeleteArticlePayload: ResolverTypeWrapper<DeleteArticlePayload>;
  DeleteArticleInput: DeleteArticleInput;
  DeleteArticleByIdInput: DeleteArticleByIdInput;
  DeleteAttributePayload: ResolverTypeWrapper<DeleteAttributePayload>;
  DeleteAttributeInput: DeleteAttributeInput;
  DeleteAttributeByIdInput: DeleteAttributeByIdInput;
  DeleteBrandPayload: ResolverTypeWrapper<DeleteBrandPayload>;
  DeleteBrandInput: DeleteBrandInput;
  DeleteBrandByIdInput: DeleteBrandByIdInput;
  DeleteCartPriceRulePayload: ResolverTypeWrapper<DeleteCartPriceRulePayload>;
  DeleteCartPriceRuleInput: DeleteCartPriceRuleInput;
  DeleteCartPriceRuleByIdInput: DeleteCartPriceRuleByIdInput;
  DeleteCasePayload: ResolverTypeWrapper<DeleteCasePayload>;
  DeleteCaseInput: DeleteCaseInput;
  DeleteCaseByIdInput: DeleteCaseByIdInput;
  DeleteCatalogPriceRulePayload: ResolverTypeWrapper<DeleteCatalogPriceRulePayload>;
  DeleteCatalogPriceRuleInput: DeleteCatalogPriceRuleInput;
  DeleteCatalogPriceRuleByIdInput: DeleteCatalogPriceRuleByIdInput;
  DeleteCategoryPayload: ResolverTypeWrapper<DeleteCategoryPayload>;
  DeleteCategoryInput: DeleteCategoryInput;
  DeleteCategoryByIdInput: DeleteCategoryByIdInput;
  DeleteChannelPayload: ResolverTypeWrapper<DeleteChannelPayload>;
  DeleteChannelInput: DeleteChannelInput;
  DeleteChannelByIdInput: DeleteChannelByIdInput;
  DeleteChecklistPayload: ResolverTypeWrapper<DeleteChecklistPayload>;
  DeleteChecklistInput: DeleteChecklistInput;
  DeleteChecklistByIdInput: DeleteChecklistByIdInput;
  DeleteCityPayload: ResolverTypeWrapper<DeleteCityPayload>;
  DeleteCityInput: DeleteCityInput;
  DeleteCityByIdInput: DeleteCityByIdInput;
  DeleteCollectionPayload: ResolverTypeWrapper<DeleteCollectionPayload>;
  DeleteCollectionInput: DeleteCollectionInput;
  DeleteCollectionByIdInput: DeleteCollectionByIdInput;
  DeleteCommentPayload: ResolverTypeWrapper<DeleteCommentPayload>;
  DeleteCommentInput: DeleteCommentInput;
  DeleteCommentByIdInput: DeleteCommentByIdInput;
  DeleteContentTypePayload: ResolverTypeWrapper<DeleteContentTypePayload>;
  DeleteContentTypeInput: DeleteContentTypeInput;
  DeleteContentTypeByIdInput: DeleteContentTypeByIdInput;
  DeleteContractPayload: ResolverTypeWrapper<DeleteContractPayload>;
  DeleteContractInput: DeleteContractInput;
  DeleteContractByIdInput: DeleteContractByIdInput;
  DeleteCountryPayload: ResolverTypeWrapper<DeleteCountryPayload>;
  DeleteCountryInput: DeleteCountryInput;
  DeleteCountryByIdInput: DeleteCountryByIdInput;
  DeleteCouponPayload: ResolverTypeWrapper<DeleteCouponPayload>;
  DeleteCouponInput: DeleteCouponInput;
  DeleteCouponByIdInput: DeleteCouponByIdInput;
  DeleteCreditMemoPayload: ResolverTypeWrapper<DeleteCreditMemoPayload>;
  DeleteCreditMemoInput: DeleteCreditMemoInput;
  DeleteCreditMemoByCreditMemoAndIdInput: DeleteCreditMemoByCreditMemoAndIdInput;
  DeleteCurrencyPayload: ResolverTypeWrapper<DeleteCurrencyPayload>;
  DeleteCurrencyInput: DeleteCurrencyInput;
  DeleteCurrencyByIdInput: DeleteCurrencyByIdInput;
  DeleteCurrencyRatePayload: ResolverTypeWrapper<DeleteCurrencyRatePayload>;
  DeleteCurrencyRateInput: DeleteCurrencyRateInput;
  DeleteCurrencyRateByImportServiceInput: DeleteCurrencyRateByImportServiceInput;
  DeleteCurrencySymbolPayload: ResolverTypeWrapper<DeleteCurrencySymbolPayload>;
  DeleteCurrencySymbolInput: DeleteCurrencySymbolInput;
  DeleteCurrencySymbolBySymbolInput: DeleteCurrencySymbolBySymbolInput;
  DeleteCustomerGroupPayload: ResolverTypeWrapper<DeleteCustomerGroupPayload>;
  DeleteCustomerGroupInput: DeleteCustomerGroupInput;
  DeleteCustomerGroupByIdInput: DeleteCustomerGroupByIdInput;
  DeleteCustomerPayload: ResolverTypeWrapper<DeleteCustomerPayload>;
  DeleteCustomerInput: DeleteCustomerInput;
  DeleteCustomerByIdInput: DeleteCustomerByIdInput;
  DeleteCustomizationPayload: ResolverTypeWrapper<DeleteCustomizationPayload>;
  DeleteCustomizationInput: DeleteCustomizationInput;
  DeleteCustomizationByIdInput: DeleteCustomizationByIdInput;
  DeleteDashboardPayload: ResolverTypeWrapper<DeleteDashboardPayload>;
  DeleteDashboardInput: DeleteDashboardInput;
  DeleteDashboardByIdInput: DeleteDashboardByIdInput;
  DeleteDeepdivePayload: ResolverTypeWrapper<DeleteDeepdivePayload>;
  DeleteDeepdiveInput: DeleteDeepdiveInput;
  DeleteDeepdiveByIdInput: DeleteDeepdiveByIdInput;
  DeleteDigiboardPayload: ResolverTypeWrapper<DeleteDigiboardPayload>;
  DeleteDigiboardInput: DeleteDigiboardInput;
  DeleteDigiboardByIdInput: DeleteDigiboardByIdInput;
  DeleteEmailPayload: ResolverTypeWrapper<DeleteEmailPayload>;
  DeleteEmailInput: DeleteEmailInput;
  DeleteEmailByIdInput: DeleteEmailByIdInput;
  DeleteEndofshiftPayload: ResolverTypeWrapper<DeleteEndofshiftPayload>;
  DeleteEndofshiftInput: DeleteEndofshiftInput;
  DeleteEndofshiftByIdInput: DeleteEndofshiftByIdInput;
  DeleteEventPayload: ResolverTypeWrapper<DeleteEventPayload>;
  DeleteEventInput: DeleteEventInput;
  DeleteEventByIdInput: DeleteEventByIdInput;
  DeleteFullfillmentPayload: ResolverTypeWrapper<DeleteFullfillmentPayload>;
  DeleteFullfillmentInput: DeleteFullfillmentInput;
  DeleteFullfillmentByIdInput: DeleteFullfillmentByIdInput;
  DeleteGiftCertificatePayload: ResolverTypeWrapper<DeleteGiftCertificatePayload>;
  DeleteGiftCertificateInput: DeleteGiftCertificateInput;
  DeleteGiftCertificateByIdInput: DeleteGiftCertificateByIdInput;
  DeleteGlossaryPayload: ResolverTypeWrapper<DeleteGlossaryPayload>;
  DeleteGlossaryInput: DeleteGlossaryInput;
  DeleteGlossaryByIdInput: DeleteGlossaryByIdInput;
  DeleteImportmPayload: ResolverTypeWrapper<DeleteImportmPayload>;
  DeleteImportmInput: DeleteImportmInput;
  DeleteImportmByIdInput: DeleteImportmByIdInput;
  DeleteIntegrationPayload: ResolverTypeWrapper<DeleteIntegrationPayload>;
  DeleteIntegrationInput: DeleteIntegrationInput;
  DeleteIntegrationByIdInput: DeleteIntegrationByIdInput;
  DeleteInternalizationPayload: ResolverTypeWrapper<DeleteInternalizationPayload>;
  DeleteInternalizationInput: DeleteInternalizationInput;
  DeleteInternalizationByIdInput: DeleteInternalizationByIdInput;
  DeleteInvitationPayload: ResolverTypeWrapper<DeleteInvitationPayload>;
  DeleteInvitationInput: DeleteInvitationInput;
  DeleteInvitationByIdInput: DeleteInvitationByIdInput;
  DeleteInvoicePayload: ResolverTypeWrapper<DeleteInvoicePayload>;
  DeleteInvoiceInput: DeleteInvoiceInput;
  DeleteInvoiceByIdInput: DeleteInvoiceByIdInput;
  DeleteLeadPayload: ResolverTypeWrapper<DeleteLeadPayload>;
  DeleteLeadInput: DeleteLeadInput;
  DeleteLeadByIdInput: DeleteLeadByIdInput;
  DeleteManufacturerPayload: ResolverTypeWrapper<DeleteManufacturerPayload>;
  DeleteManufacturerInput: DeleteManufacturerInput;
  DeleteManufacturerByIdInput: DeleteManufacturerByIdInput;
  DeleteMediamanagerPayload: ResolverTypeWrapper<DeleteMediamanagerPayload>;
  DeleteMediamanagerInput: DeleteMediamanagerInput;
  DeleteMediamanagerByIdInput: DeleteMediamanagerByIdInput;
  DeleteMeetingPayload: ResolverTypeWrapper<DeleteMeetingPayload>;
  DeleteMeetingInput: DeleteMeetingInput;
  DeleteMeetingByIdInput: DeleteMeetingByIdInput;
  DeleteMessagePayload: ResolverTypeWrapper<DeleteMessagePayload>;
  DeleteMessageInput: DeleteMessageInput;
  DeleteMessageByIdInput: DeleteMessageByIdInput;
  DeleteNewsletterPayload: ResolverTypeWrapper<DeleteNewsletterPayload>;
  DeleteNewsletterInput: DeleteNewsletterInput;
  DeleteNewsletterByIdInput: DeleteNewsletterByIdInput;
  DeleteOotoPayload: ResolverTypeWrapper<DeleteOotoPayload>;
  DeleteOotoInput: DeleteOotoInput;
  DeleteOotoByIdInput: DeleteOotoByIdInput;
  DeleteOpportunityPayload: ResolverTypeWrapper<DeleteOpportunityPayload>;
  DeleteOpportunityInput: DeleteOpportunityInput;
  DeleteOpportunityByIdInput: DeleteOpportunityByIdInput;
  DeleteOrderPayload: ResolverTypeWrapper<DeleteOrderPayload>;
  DeleteOrderInput: DeleteOrderInput;
  DeleteOrderByIdInput: DeleteOrderByIdInput;
  DeletePagePayload: ResolverTypeWrapper<DeletePagePayload>;
  DeletePageInput: DeletePageInput;
  DeletePageByIdInput: DeletePageByIdInput;
  DeletePartnerPayload: ResolverTypeWrapper<DeletePartnerPayload>;
  DeletePartnerInput: DeletePartnerInput;
  DeletePartnerByIdInput: DeletePartnerByIdInput;
  DeletePaymentPayload: ResolverTypeWrapper<DeletePaymentPayload>;
  DeletePaymentInput: DeletePaymentInput;
  DeletePaymentByIdInput: DeletePaymentByIdInput;
  DeletePermissionPayload: ResolverTypeWrapper<DeletePermissionPayload>;
  DeletePermissionInput: DeletePermissionInput;
  DeletePermissionByIdInput: DeletePermissionByIdInput;
  DeletePluginPayload: ResolverTypeWrapper<DeletePluginPayload>;
  DeletePluginInput: DeletePluginInput;
  DeletePluginByIdInput: DeletePluginByIdInput;
  DeletePollPayload: ResolverTypeWrapper<DeletePollPayload>;
  DeletePollInput: DeletePollInput;
  DeletePollByIdInput: DeletePollByIdInput;
  DeleteProductTypePayload: ResolverTypeWrapper<DeleteProductTypePayload>;
  DeleteProductTypeInput: DeleteProductTypeInput;
  DeleteProductTypeByIdInput: DeleteProductTypeByIdInput;
  DeleteProductPayload: ResolverTypeWrapper<DeleteProductPayload>;
  DeleteProductInput: DeleteProductInput;
  DeleteProductByIdInput: DeleteProductByIdInput;
  DeleteProjectPayload: ResolverTypeWrapper<DeleteProjectPayload>;
  DeleteProjectInput: DeleteProjectInput;
  DeleteProjectByIdInput: DeleteProjectByIdInput;
  DeleteProviderPayload: ResolverTypeWrapper<DeleteProviderPayload>;
  DeleteProviderInput: DeleteProviderInput;
  DeleteProviderByIdInput: DeleteProviderByIdInput;
  DeleteQuotePayload: ResolverTypeWrapper<DeleteQuotePayload>;
  DeleteQuoteInput: DeleteQuoteInput;
  DeleteQuoteByIdInput: DeleteQuoteByIdInput;
  DeleteRatingPayload: ResolverTypeWrapper<DeleteRatingPayload>;
  DeleteRatingInput: DeleteRatingInput;
  DeleteRatingByIdInput: DeleteRatingByIdInput;
  DeleteReportPayload: ResolverTypeWrapper<DeleteReportPayload>;
  DeleteReportInput: DeleteReportInput;
  DeleteReportByIdInput: DeleteReportByIdInput;
  DeleteReturnPayload: ResolverTypeWrapper<DeleteReturnPayload>;
  DeleteReturnInput: DeleteReturnInput;
  DeleteReturnByIdInput: DeleteReturnByIdInput;
  DeleteReviewPayload: ResolverTypeWrapper<DeleteReviewPayload>;
  DeleteReviewInput: DeleteReviewInput;
  DeleteReviewByIdInput: DeleteReviewByIdInput;
  DeleteRewardPayload: ResolverTypeWrapper<DeleteRewardPayload>;
  DeleteRewardInput: DeleteRewardInput;
  DeleteRewardByIdInput: DeleteRewardByIdInput;
  DeleteRolePayload: ResolverTypeWrapper<DeleteRolePayload>;
  DeleteRoleInput: DeleteRoleInput;
  DeleteRoleByIdInput: DeleteRoleByIdInput;
  DeleteSchedulerPayload: ResolverTypeWrapper<DeleteSchedulerPayload>;
  DeleteSchedulerInput: DeleteSchedulerInput;
  DeleteSchedulerByIdInput: DeleteSchedulerByIdInput;
  DeleteSegmentPayload: ResolverTypeWrapper<DeleteSegmentPayload>;
  DeleteSegmentInput: DeleteSegmentInput;
  DeleteSegmentByIdInput: DeleteSegmentByIdInput;
  DeleteSettingPayload: ResolverTypeWrapper<DeleteSettingPayload>;
  DeleteSettingInput: DeleteSettingInput;
  DeleteSettingByIdInput: DeleteSettingByIdInput;
  DeleteShipmentPayload: ResolverTypeWrapper<DeleteShipmentPayload>;
  DeleteShipmentInput: DeleteShipmentInput;
  DeleteShipmentByIdInput: DeleteShipmentByIdInput;
  DeleteSpecialDiscountPayload: ResolverTypeWrapper<DeleteSpecialDiscountPayload>;
  DeleteSpecialDiscountInput: DeleteSpecialDiscountInput;
  DeleteSpecialDiscountByIdInput: DeleteSpecialDiscountByIdInput;
  DeleteStatePayload: ResolverTypeWrapper<DeleteStatePayload>;
  DeleteStateInput: DeleteStateInput;
  DeleteStateByIdInput: DeleteStateByIdInput;
  DeleteStatisticPayload: ResolverTypeWrapper<DeleteStatisticPayload>;
  DeleteStatisticInput: DeleteStatisticInput;
  DeleteStatisticByIdInput: DeleteStatisticByIdInput;
  DeleteStockPayload: ResolverTypeWrapper<DeleteStockPayload>;
  DeleteStockInput: DeleteStockInput;
  DeleteStockByIdInput: DeleteStockByIdInput;
  DeleteSurveyPayload: ResolverTypeWrapper<DeleteSurveyPayload>;
  DeleteSurveyInput: DeleteSurveyInput;
  DeleteSurveyByIdInput: DeleteSurveyByIdInput;
  DeleteTagPayload: ResolverTypeWrapper<DeleteTagPayload>;
  DeleteTagInput: DeleteTagInput;
  DeleteTagByIdInput: DeleteTagByIdInput;
  DeleteTargetPayload: ResolverTypeWrapper<DeleteTargetPayload>;
  DeleteTargetInput: DeleteTargetInput;
  DeleteTargetByIdInput: DeleteTargetByIdInput;
  DeleteTaxCategoryPayload: ResolverTypeWrapper<DeleteTaxCategoryPayload>;
  DeleteTaxCategoryInput: DeleteTaxCategoryInput;
  DeleteTaxCategoryByIdInput: DeleteTaxCategoryByIdInput;
  DeleteTaxRatePayload: ResolverTypeWrapper<DeleteTaxRatePayload>;
  DeleteTaxRateInput: DeleteTaxRateInput;
  DeleteTaxRateByIdInput: DeleteTaxRateByIdInput;
  DeleteTaxRulePayload: ResolverTypeWrapper<DeleteTaxRulePayload>;
  DeleteTaxRuleInput: DeleteTaxRuleInput;
  DeleteTaxRuleByIdInput: DeleteTaxRuleByIdInput;
  DeleteTemplatePayload: ResolverTypeWrapper<DeleteTemplatePayload>;
  DeleteTemplateInput: DeleteTemplateInput;
  DeleteTemplateByIdInput: DeleteTemplateByIdInput;
  DeleteThemePayload: ResolverTypeWrapper<DeleteThemePayload>;
  DeleteThemeInput: DeleteThemeInput;
  DeleteThemeByIdInput: DeleteThemeByIdInput;
  DeleteTicketingPayload: ResolverTypeWrapper<DeleteTicketingPayload>;
  DeleteTicketingInput: DeleteTicketingInput;
  DeleteTicketingByIdInput: DeleteTicketingByIdInput;
  DeleteTrainingPayload: ResolverTypeWrapper<DeleteTrainingPayload>;
  DeleteTrainingInput: DeleteTrainingInput;
  DeleteTrainingByIdInput: DeleteTrainingByIdInput;
  DeleteTransactionPayload: ResolverTypeWrapper<DeleteTransactionPayload>;
  DeleteTransactionInput: DeleteTransactionInput;
  DeleteTransactionByIdInput: DeleteTransactionByIdInput;
  DeleteUploadFilePayload: ResolverTypeWrapper<DeleteUploadFilePayload>;
  DeleteUploadFileInput: DeleteUploadFileInput;
  DeleteUploadFileByIdInput: DeleteUploadFileByIdInput;
  DeleteUserPayload: ResolverTypeWrapper<DeleteUserPayload>;
  DeleteUserInput: DeleteUserInput;
  DeleteUserByIdInput: DeleteUserByIdInput;
  DeleteVendorPayload: ResolverTypeWrapper<DeleteVendorPayload>;
  DeleteVendorInput: DeleteVendorInput;
  DeleteVendorByIdInput: DeleteVendorByIdInput;
  DeleteVisitPayload: ResolverTypeWrapper<DeleteVisitPayload>;
  DeleteVisitInput: DeleteVisitInput;
  DeleteVisitByIdInput: DeleteVisitByIdInput;
  DeleteWarehousePayload: ResolverTypeWrapper<DeleteWarehousePayload>;
  DeleteWarehouseInput: DeleteWarehouseInput;
  DeleteWarehouseByIdInput: DeleteWarehouseByIdInput;
  DeleteWebhookPayload: ResolverTypeWrapper<DeleteWebhookPayload>;
  DeleteWebhookInput: DeleteWebhookInput;
  DeleteWebhookByIdInput: DeleteWebhookByIdInput;
  DeleteWebsitePayload: ResolverTypeWrapper<DeleteWebsitePayload>;
  DeleteWebsiteInput: DeleteWebsiteInput;
  DeleteWebsiteByIdInput: DeleteWebsiteByIdInput;
  DeleteWishlistPayload: ResolverTypeWrapper<DeleteWishlistPayload>;
  DeleteWishlistInput: DeleteWishlistInput;
  DeleteWishlistByIdInput: DeleteWishlistByIdInput;
  DeleteWorkspacePayload: ResolverTypeWrapper<DeleteWorkspacePayload>;
  DeleteWorkspaceInput: DeleteWorkspaceInput;
  DeleteWorkspaceByIdInput: DeleteWorkspaceByIdInput;
  DeleteZonePayload: ResolverTypeWrapper<DeleteZonePayload>;
  DeleteZoneInput: DeleteZoneInput;
  DeleteZoneByIdInput: DeleteZoneByIdInput;
  Subscription: ResolverTypeWrapper<{}>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Query: {};
  Node: ResolversParentTypes['Query'] | ResolversParentTypes['Account'] | ResolversParentTypes['Agreement'] | ResolversParentTypes['Analytic'] | ResolversParentTypes['Apitoken'] | ResolversParentTypes['Article'] | ResolversParentTypes['Attribute'] | ResolversParentTypes['Brand'] | ResolversParentTypes['CartPriceRule'] | ResolversParentTypes['Case'] | ResolversParentTypes['CatalogPriceRule'] | ResolversParentTypes['Category'] | ResolversParentTypes['Channel'] | ResolversParentTypes['Checklist'] | ResolversParentTypes['City'] | ResolversParentTypes['Collection'] | ResolversParentTypes['Comment'] | ResolversParentTypes['ContentType'] | ResolversParentTypes['Contract'] | ResolversParentTypes['Country'] | ResolversParentTypes['Coupon'] | ResolversParentTypes['CreditMemo'] | ResolversParentTypes['Currency'] | ResolversParentTypes['CurrencyRate'] | ResolversParentTypes['CurrencySymbol'] | ResolversParentTypes['CustomerGroup'] | ResolversParentTypes['Customer'] | ResolversParentTypes['Customization'] | ResolversParentTypes['Dashboard'] | ResolversParentTypes['Deepdive'] | ResolversParentTypes['Digiboard'] | ResolversParentTypes['Email'] | ResolversParentTypes['Endofshift'] | ResolversParentTypes['Event'] | ResolversParentTypes['Fullfillment'] | ResolversParentTypes['GiftCertificate'] | ResolversParentTypes['Glossary'] | ResolversParentTypes['Importm'] | ResolversParentTypes['Integration'] | ResolversParentTypes['Internalization'] | ResolversParentTypes['Invitation'] | ResolversParentTypes['Invoice'] | ResolversParentTypes['Lead'] | ResolversParentTypes['Manufacturer'] | ResolversParentTypes['Mediamanager'] | ResolversParentTypes['Meeting'] | ResolversParentTypes['Message'] | ResolversParentTypes['Newsletter'] | ResolversParentTypes['Ooto'] | ResolversParentTypes['Opportunity'] | ResolversParentTypes['Order'] | ResolversParentTypes['Page'] | ResolversParentTypes['Partner'] | ResolversParentTypes['Payment'] | ResolversParentTypes['Permission'] | ResolversParentTypes['Plugin'] | ResolversParentTypes['Poll'] | ResolversParentTypes['ProductType'] | ResolversParentTypes['Product'] | ResolversParentTypes['Project'] | ResolversParentTypes['Provider'] | ResolversParentTypes['Quote'] | ResolversParentTypes['Rating'] | ResolversParentTypes['Report'] | ResolversParentTypes['Return'] | ResolversParentTypes['Review'] | ResolversParentTypes['Reward'] | ResolversParentTypes['Role'] | ResolversParentTypes['Scheduler'] | ResolversParentTypes['Segment'] | ResolversParentTypes['Setting'] | ResolversParentTypes['Shipment'] | ResolversParentTypes['SpecialDiscount'] | ResolversParentTypes['State'] | ResolversParentTypes['Statistic'] | ResolversParentTypes['Stock'] | ResolversParentTypes['Survey'] | ResolversParentTypes['Tag'] | ResolversParentTypes['Target'] | ResolversParentTypes['TaxCategory'] | ResolversParentTypes['TaxRate'] | ResolversParentTypes['TaxRule'] | ResolversParentTypes['Template'] | ResolversParentTypes['Theme'] | ResolversParentTypes['Ticketing'] | ResolversParentTypes['Training'] | ResolversParentTypes['Transaction'] | ResolversParentTypes['UploadFile'] | ResolversParentTypes['User'] | ResolversParentTypes['Vendor'] | ResolversParentTypes['Visit'] | ResolversParentTypes['Warehouse'] | ResolversParentTypes['Webhook'] | ResolversParentTypes['Website'] | ResolversParentTypes['Wishlist'] | ResolversParentTypes['Workspace'] | ResolversParentTypes['Zone'];
  ID: Scalars['ID'];
  AccountsConnection: AccountsConnection;
  Account: Account;
  BigInt: Scalars['BigInt'];
  Datetime: Scalars['Datetime'];
  String: Scalars['String'];
  AccountsEdge: AccountsEdge;
  Cursor: Scalars['Cursor'];
  PageInfo: PageInfo;
  Boolean: Scalars['Boolean'];
  Int: Scalars['Int'];
  AccountCondition: AccountCondition;
  AgreementsConnection: AgreementsConnection;
  Agreement: Agreement;
  AgreementsEdge: AgreementsEdge;
  AgreementCondition: AgreementCondition;
  AnalyticsConnection: AnalyticsConnection;
  Analytic: Analytic;
  AnalyticsEdge: AnalyticsEdge;
  AnalyticCondition: AnalyticCondition;
  ApitokensConnection: ApitokensConnection;
  Apitoken: Apitoken;
  ApitokensEdge: ApitokensEdge;
  ApitokenCondition: ApitokenCondition;
  ArticlesConnection: ArticlesConnection;
  Article: Article;
  ArticlesEdge: ArticlesEdge;
  ArticleCondition: ArticleCondition;
  AttributesConnection: AttributesConnection;
  Attribute: Attribute;
  AttributesEdge: AttributesEdge;
  AttributeCondition: AttributeCondition;
  BrandsConnection: BrandsConnection;
  Brand: Brand;
  BrandsEdge: BrandsEdge;
  BrandCondition: BrandCondition;
  CartPriceRulesConnection: CartPriceRulesConnection;
  CartPriceRule: CartPriceRule;
  Date: Scalars['Date'];
  BigFloat: Scalars['BigFloat'];
  CartPriceRulesEdge: CartPriceRulesEdge;
  CartPriceRuleCondition: CartPriceRuleCondition;
  CasesConnection: CasesConnection;
  Case: Case;
  CasesEdge: CasesEdge;
  CaseCondition: CaseCondition;
  CatalogPriceRulesConnection: CatalogPriceRulesConnection;
  CatalogPriceRule: CatalogPriceRule;
  CatalogPriceRulesEdge: CatalogPriceRulesEdge;
  CatalogPriceRuleCondition: CatalogPriceRuleCondition;
  CategoriesConnection: CategoriesConnection;
  Category: Category;
  CategoriesEdge: CategoriesEdge;
  CategoryCondition: CategoryCondition;
  ChannelsConnection: ChannelsConnection;
  Channel: Channel;
  ChannelsEdge: ChannelsEdge;
  ChannelCondition: ChannelCondition;
  ChecklistsConnection: ChecklistsConnection;
  Checklist: Checklist;
  ChecklistsEdge: ChecklistsEdge;
  ChecklistCondition: ChecklistCondition;
  CitiesConnection: CitiesConnection;
  City: City;
  CitiesEdge: CitiesEdge;
  CityCondition: CityCondition;
  CollectionsConnection: CollectionsConnection;
  Collection: Collection;
  CollectionsEdge: CollectionsEdge;
  CollectionCondition: CollectionCondition;
  CommentsConnection: CommentsConnection;
  Comment: Comment;
  CommentsEdge: CommentsEdge;
  CommentCondition: CommentCondition;
  ContentTypesConnection: ContentTypesConnection;
  ContentType: ContentType;
  JSON: Scalars['JSON'];
  Time: Scalars['Time'];
  ContentTypesEdge: ContentTypesEdge;
  ContentTypeCondition: ContentTypeCondition;
  ContractsConnection: ContractsConnection;
  Contract: Contract;
  ContractsEdge: ContractsEdge;
  ContractCondition: ContractCondition;
  CountriesConnection: CountriesConnection;
  Country: Country;
  CountriesEdge: CountriesEdge;
  CountryCondition: CountryCondition;
  CouponsConnection: CouponsConnection;
  Coupon: Coupon;
  CouponsEdge: CouponsEdge;
  CouponCondition: CouponCondition;
  CreditMemosConnection: CreditMemosConnection;
  CreditMemo: CreditMemo;
  CreditMemosEdge: CreditMemosEdge;
  CreditMemoCondition: CreditMemoCondition;
  CurrenciesConnection: CurrenciesConnection;
  Currency: Currency;
  CurrenciesEdge: CurrenciesEdge;
  CurrencyCondition: CurrencyCondition;
  CurrencyRatesConnection: CurrencyRatesConnection;
  CurrencyRate: CurrencyRate;
  CurrencyRatesEdge: CurrencyRatesEdge;
  CurrencyRateCondition: CurrencyRateCondition;
  CurrencySymbolsConnection: CurrencySymbolsConnection;
  CurrencySymbol: CurrencySymbol;
  CurrencySymbolsEdge: CurrencySymbolsEdge;
  CurrencySymbolCondition: CurrencySymbolCondition;
  CustomerGroupsConnection: CustomerGroupsConnection;
  CustomerGroup: CustomerGroup;
  CustomerGroupsEdge: CustomerGroupsEdge;
  CustomerGroupCondition: CustomerGroupCondition;
  CustomersConnection: CustomersConnection;
  Customer: Customer;
  CustomersEdge: CustomersEdge;
  CustomerCondition: CustomerCondition;
  CustomizationsConnection: CustomizationsConnection;
  Customization: Customization;
  CustomizationsEdge: CustomizationsEdge;
  CustomizationCondition: CustomizationCondition;
  DashboardsConnection: DashboardsConnection;
  Dashboard: Dashboard;
  DashboardsEdge: DashboardsEdge;
  DashboardCondition: DashboardCondition;
  DeepdivesConnection: DeepdivesConnection;
  Deepdive: Deepdive;
  DeepdivesEdge: DeepdivesEdge;
  DeepdiveCondition: DeepdiveCondition;
  DigiboardsConnection: DigiboardsConnection;
  Digiboard: Digiboard;
  DigiboardsEdge: DigiboardsEdge;
  DigiboardCondition: DigiboardCondition;
  EmailsConnection: EmailsConnection;
  Email: Email;
  EmailsEdge: EmailsEdge;
  EmailCondition: EmailCondition;
  EndofshiftsConnection: EndofshiftsConnection;
  Endofshift: Endofshift;
  EndofshiftsEdge: EndofshiftsEdge;
  EndofshiftCondition: EndofshiftCondition;
  EventsConnection: EventsConnection;
  Event: Event;
  EventsEdge: EventsEdge;
  EventCondition: EventCondition;
  FullfillmentsConnection: FullfillmentsConnection;
  Fullfillment: Fullfillment;
  FullfillmentsEdge: FullfillmentsEdge;
  FullfillmentCondition: FullfillmentCondition;
  GiftCertificatesConnection: GiftCertificatesConnection;
  GiftCertificate: GiftCertificate;
  GiftCertificatesEdge: GiftCertificatesEdge;
  GiftCertificateCondition: GiftCertificateCondition;
  GlossariesConnection: GlossariesConnection;
  Glossary: Glossary;
  GlossariesEdge: GlossariesEdge;
  GlossaryCondition: GlossaryCondition;
  ImportmsConnection: ImportmsConnection;
  Importm: Importm;
  ImportmsEdge: ImportmsEdge;
  ImportmCondition: ImportmCondition;
  IntegrationsConnection: IntegrationsConnection;
  Integration: Integration;
  IntegrationsEdge: IntegrationsEdge;
  IntegrationCondition: IntegrationCondition;
  InternalizationsConnection: InternalizationsConnection;
  Internalization: Internalization;
  InternalizationsEdge: InternalizationsEdge;
  InternalizationCondition: InternalizationCondition;
  InvitationsConnection: InvitationsConnection;
  Invitation: Invitation;
  InvitationsEdge: InvitationsEdge;
  InvitationCondition: InvitationCondition;
  InvoicesConnection: InvoicesConnection;
  Invoice: Invoice;
  InvoicesEdge: InvoicesEdge;
  InvoiceCondition: InvoiceCondition;
  LeadsConnection: LeadsConnection;
  Lead: Lead;
  LeadsEdge: LeadsEdge;
  LeadCondition: LeadCondition;
  ManufacturersConnection: ManufacturersConnection;
  Manufacturer: Manufacturer;
  ManufacturersEdge: ManufacturersEdge;
  ManufacturerCondition: ManufacturerCondition;
  MediamanagersConnection: MediamanagersConnection;
  Mediamanager: Mediamanager;
  MediamanagersEdge: MediamanagersEdge;
  MediamanagerCondition: MediamanagerCondition;
  MeetingsConnection: MeetingsConnection;
  Meeting: Meeting;
  MeetingsEdge: MeetingsEdge;
  MeetingCondition: MeetingCondition;
  MessagesConnection: MessagesConnection;
  Message: Message;
  MessagesEdge: MessagesEdge;
  MessageCondition: MessageCondition;
  NewslettersConnection: NewslettersConnection;
  Newsletter: Newsletter;
  NewslettersEdge: NewslettersEdge;
  NewsletterCondition: NewsletterCondition;
  OotosConnection: OotosConnection;
  Ooto: Ooto;
  OotosEdge: OotosEdge;
  OotoCondition: OotoCondition;
  OpportunitiesConnection: OpportunitiesConnection;
  Opportunity: Opportunity;
  OpportunitiesEdge: OpportunitiesEdge;
  OpportunityCondition: OpportunityCondition;
  OrdersConnection: OrdersConnection;
  Order: Order;
  OrdersEdge: OrdersEdge;
  OrderCondition: OrderCondition;
  PagesConnection: PagesConnection;
  Page: Page;
  PagesEdge: PagesEdge;
  PageCondition: PageCondition;
  PartnersConnection: PartnersConnection;
  Partner: Partner;
  PartnersEdge: PartnersEdge;
  PartnerCondition: PartnerCondition;
  PaymentsConnection: PaymentsConnection;
  Payment: Payment;
  PaymentsEdge: PaymentsEdge;
  PaymentCondition: PaymentCondition;
  PermissionsConnection: PermissionsConnection;
  Permission: Permission;
  PermissionsEdge: PermissionsEdge;
  PermissionCondition: PermissionCondition;
  PluginsConnection: PluginsConnection;
  Plugin: Plugin;
  PluginsEdge: PluginsEdge;
  PluginCondition: PluginCondition;
  PollsConnection: PollsConnection;
  Poll: Poll;
  PollsEdge: PollsEdge;
  PollCondition: PollCondition;
  ProductTypesConnection: ProductTypesConnection;
  ProductType: ProductType;
  ProductTypesEdge: ProductTypesEdge;
  ProductTypeCondition: ProductTypeCondition;
  ProductsConnection: ProductsConnection;
  Product: Product;
  ProductsEdge: ProductsEdge;
  ProductCondition: ProductCondition;
  ProjectsConnection: ProjectsConnection;
  Project: Project;
  ProjectsEdge: ProjectsEdge;
  ProjectCondition: ProjectCondition;
  ProvidersConnection: ProvidersConnection;
  Provider: Provider;
  ProvidersEdge: ProvidersEdge;
  ProviderCondition: ProviderCondition;
  QuotesConnection: QuotesConnection;
  Quote: Quote;
  QuotesEdge: QuotesEdge;
  QuoteCondition: QuoteCondition;
  RatingsConnection: RatingsConnection;
  Rating: Rating;
  RatingsEdge: RatingsEdge;
  RatingCondition: RatingCondition;
  ReportsConnection: ReportsConnection;
  Report: Report;
  ReportsEdge: ReportsEdge;
  ReportCondition: ReportCondition;
  ReturnsConnection: ReturnsConnection;
  Return: Return;
  ReturnsEdge: ReturnsEdge;
  ReturnCondition: ReturnCondition;
  ReviewsConnection: ReviewsConnection;
  Review: Review;
  ReviewsEdge: ReviewsEdge;
  ReviewCondition: ReviewCondition;
  RewardsConnection: RewardsConnection;
  Reward: Reward;
  RewardsEdge: RewardsEdge;
  RewardCondition: RewardCondition;
  RolesConnection: RolesConnection;
  Role: Role;
  RolesEdge: RolesEdge;
  RoleCondition: RoleCondition;
  SchedulersConnection: SchedulersConnection;
  Scheduler: Scheduler;
  SchedulersEdge: SchedulersEdge;
  SchedulerCondition: SchedulerCondition;
  SegmentsConnection: SegmentsConnection;
  Segment: Segment;
  SegmentsEdge: SegmentsEdge;
  SegmentCondition: SegmentCondition;
  SettingsConnection: SettingsConnection;
  Setting: Setting;
  SettingsEdge: SettingsEdge;
  SettingCondition: SettingCondition;
  ShipmentsConnection: ShipmentsConnection;
  Shipment: Shipment;
  ShipmentsEdge: ShipmentsEdge;
  ShipmentCondition: ShipmentCondition;
  SpecialDiscountsConnection: SpecialDiscountsConnection;
  SpecialDiscount: SpecialDiscount;
  SpecialDiscountsEdge: SpecialDiscountsEdge;
  SpecialDiscountCondition: SpecialDiscountCondition;
  StatesConnection: StatesConnection;
  State: State;
  StatesEdge: StatesEdge;
  StateCondition: StateCondition;
  StatisticsConnection: StatisticsConnection;
  Statistic: Statistic;
  StatisticsEdge: StatisticsEdge;
  StatisticCondition: StatisticCondition;
  StocksConnection: StocksConnection;
  Stock: Stock;
  StocksEdge: StocksEdge;
  StockCondition: StockCondition;
  SurveysConnection: SurveysConnection;
  Survey: Survey;
  SurveysEdge: SurveysEdge;
  SurveyCondition: SurveyCondition;
  TagsConnection: TagsConnection;
  Tag: Tag;
  TagsEdge: TagsEdge;
  TagCondition: TagCondition;
  TargetsConnection: TargetsConnection;
  Target: Target;
  TargetsEdge: TargetsEdge;
  TargetCondition: TargetCondition;
  TaxCategoriesConnection: TaxCategoriesConnection;
  TaxCategory: TaxCategory;
  TaxCategoriesEdge: TaxCategoriesEdge;
  TaxCategoryCondition: TaxCategoryCondition;
  TaxRatesConnection: TaxRatesConnection;
  TaxRate: TaxRate;
  TaxRatesEdge: TaxRatesEdge;
  TaxRateCondition: TaxRateCondition;
  TaxRulesConnection: TaxRulesConnection;
  TaxRule: TaxRule;
  TaxRulesEdge: TaxRulesEdge;
  TaxRuleCondition: TaxRuleCondition;
  TemplatesConnection: TemplatesConnection;
  Template: Template;
  TemplatesEdge: TemplatesEdge;
  TemplateCondition: TemplateCondition;
  ThemesConnection: ThemesConnection;
  Theme: Theme;
  ThemesEdge: ThemesEdge;
  ThemeCondition: ThemeCondition;
  TicketingsConnection: TicketingsConnection;
  Ticketing: Ticketing;
  TicketingsEdge: TicketingsEdge;
  TicketingCondition: TicketingCondition;
  TrainingsConnection: TrainingsConnection;
  Training: Training;
  TrainingsEdge: TrainingsEdge;
  TrainingCondition: TrainingCondition;
  TransactionsConnection: TransactionsConnection;
  Transaction: Transaction;
  TransactionsEdge: TransactionsEdge;
  TransactionCondition: TransactionCondition;
  UploadFilesConnection: UploadFilesConnection;
  UploadFile: UploadFile;
  UploadFilesEdge: UploadFilesEdge;
  UploadFileCondition: UploadFileCondition;
  UsersConnection: UsersConnection;
  User: User;
  UsersEdge: UsersEdge;
  UserCondition: UserCondition;
  VendorsConnection: VendorsConnection;
  Vendor: Vendor;
  VendorsEdge: VendorsEdge;
  VendorCondition: VendorCondition;
  VisitsConnection: VisitsConnection;
  Visit: Visit;
  VisitsEdge: VisitsEdge;
  VisitCondition: VisitCondition;
  WarehousesConnection: WarehousesConnection;
  Warehouse: Warehouse;
  WarehousesEdge: WarehousesEdge;
  WarehouseCondition: WarehouseCondition;
  WebhooksConnection: WebhooksConnection;
  Webhook: Webhook;
  WebhooksEdge: WebhooksEdge;
  WebhookCondition: WebhookCondition;
  WebsitesConnection: WebsitesConnection;
  Website: Website;
  WebsitesEdge: WebsitesEdge;
  WebsiteCondition: WebsiteCondition;
  WishlistsConnection: WishlistsConnection;
  Wishlist: Wishlist;
  WishlistsEdge: WishlistsEdge;
  WishlistCondition: WishlistCondition;
  WorkspacesConnection: WorkspacesConnection;
  Workspace: Workspace;
  WorkspacesEdge: WorkspacesEdge;
  WorkspaceCondition: WorkspaceCondition;
  ZonesConnection: ZonesConnection;
  Zone: Zone;
  ZonesEdge: ZonesEdge;
  ZoneCondition: ZoneCondition;
  Mutation: {};
  CreateAccountPayload: CreateAccountPayload;
  CreateAccountInput: CreateAccountInput;
  AccountInput: AccountInput;
  CreateAgreementPayload: CreateAgreementPayload;
  CreateAgreementInput: CreateAgreementInput;
  AgreementInput: AgreementInput;
  CreateAnalyticPayload: CreateAnalyticPayload;
  CreateAnalyticInput: CreateAnalyticInput;
  AnalyticInput: AnalyticInput;
  CreateApitokenPayload: CreateApitokenPayload;
  CreateApitokenInput: CreateApitokenInput;
  ApitokenInput: ApitokenInput;
  CreateArticlePayload: CreateArticlePayload;
  CreateArticleInput: CreateArticleInput;
  ArticleInput: ArticleInput;
  CreateAttributePayload: CreateAttributePayload;
  CreateAttributeInput: CreateAttributeInput;
  AttributeInput: AttributeInput;
  CreateBrandPayload: CreateBrandPayload;
  CreateBrandInput: CreateBrandInput;
  BrandInput: BrandInput;
  CreateCartPriceRulePayload: CreateCartPriceRulePayload;
  CreateCartPriceRuleInput: CreateCartPriceRuleInput;
  CartPriceRuleInput: CartPriceRuleInput;
  CreateCasePayload: CreateCasePayload;
  CreateCaseInput: CreateCaseInput;
  CaseInput: CaseInput;
  CreateCatalogPriceRulePayload: CreateCatalogPriceRulePayload;
  CreateCatalogPriceRuleInput: CreateCatalogPriceRuleInput;
  CatalogPriceRuleInput: CatalogPriceRuleInput;
  CreateCategoryPayload: CreateCategoryPayload;
  CreateCategoryInput: CreateCategoryInput;
  CategoryInput: CategoryInput;
  CreateChannelPayload: CreateChannelPayload;
  CreateChannelInput: CreateChannelInput;
  ChannelInput: ChannelInput;
  CreateChecklistPayload: CreateChecklistPayload;
  CreateChecklistInput: CreateChecklistInput;
  ChecklistInput: ChecklistInput;
  CreateCityPayload: CreateCityPayload;
  CreateCityInput: CreateCityInput;
  CityInput: CityInput;
  CreateCollectionPayload: CreateCollectionPayload;
  CreateCollectionInput: CreateCollectionInput;
  CollectionInput: CollectionInput;
  CreateCommentPayload: CreateCommentPayload;
  CreateCommentInput: CreateCommentInput;
  CommentInput: CommentInput;
  CreateContentTypePayload: CreateContentTypePayload;
  CreateContentTypeInput: CreateContentTypeInput;
  ContentTypeInput: ContentTypeInput;
  CreateContractPayload: CreateContractPayload;
  CreateContractInput: CreateContractInput;
  ContractInput: ContractInput;
  CreateCountryPayload: CreateCountryPayload;
  CreateCountryInput: CreateCountryInput;
  CountryInput: CountryInput;
  CreateCouponPayload: CreateCouponPayload;
  CreateCouponInput: CreateCouponInput;
  CouponInput: CouponInput;
  CreateCreditMemoPayload: CreateCreditMemoPayload;
  CreateCreditMemoInput: CreateCreditMemoInput;
  CreditMemoInput: CreditMemoInput;
  CreateCurrencyPayload: CreateCurrencyPayload;
  CreateCurrencyInput: CreateCurrencyInput;
  CurrencyInput: CurrencyInput;
  CreateCurrencyRatePayload: CreateCurrencyRatePayload;
  CreateCurrencyRateInput: CreateCurrencyRateInput;
  CurrencyRateInput: CurrencyRateInput;
  CreateCurrencySymbolPayload: CreateCurrencySymbolPayload;
  CreateCurrencySymbolInput: CreateCurrencySymbolInput;
  CurrencySymbolInput: CurrencySymbolInput;
  CreateCustomerGroupPayload: CreateCustomerGroupPayload;
  CreateCustomerGroupInput: CreateCustomerGroupInput;
  CustomerGroupInput: CustomerGroupInput;
  CreateCustomerPayload: CreateCustomerPayload;
  CreateCustomerInput: CreateCustomerInput;
  CustomerInput: CustomerInput;
  CreateCustomizationPayload: CreateCustomizationPayload;
  CreateCustomizationInput: CreateCustomizationInput;
  CustomizationInput: CustomizationInput;
  CreateDashboardPayload: CreateDashboardPayload;
  CreateDashboardInput: CreateDashboardInput;
  DashboardInput: DashboardInput;
  CreateDeepdivePayload: CreateDeepdivePayload;
  CreateDeepdiveInput: CreateDeepdiveInput;
  DeepdiveInput: DeepdiveInput;
  CreateDigiboardPayload: CreateDigiboardPayload;
  CreateDigiboardInput: CreateDigiboardInput;
  DigiboardInput: DigiboardInput;
  CreateEmailPayload: CreateEmailPayload;
  CreateEmailInput: CreateEmailInput;
  EmailInput: EmailInput;
  CreateEndofshiftPayload: CreateEndofshiftPayload;
  CreateEndofshiftInput: CreateEndofshiftInput;
  EndofshiftInput: EndofshiftInput;
  CreateEventPayload: CreateEventPayload;
  CreateEventInput: CreateEventInput;
  EventInput: EventInput;
  CreateFullfillmentPayload: CreateFullfillmentPayload;
  CreateFullfillmentInput: CreateFullfillmentInput;
  FullfillmentInput: FullfillmentInput;
  CreateGiftCertificatePayload: CreateGiftCertificatePayload;
  CreateGiftCertificateInput: CreateGiftCertificateInput;
  GiftCertificateInput: GiftCertificateInput;
  CreateGlossaryPayload: CreateGlossaryPayload;
  CreateGlossaryInput: CreateGlossaryInput;
  GlossaryInput: GlossaryInput;
  CreateImportmPayload: CreateImportmPayload;
  CreateImportmInput: CreateImportmInput;
  ImportmInput: ImportmInput;
  CreateIntegrationPayload: CreateIntegrationPayload;
  CreateIntegrationInput: CreateIntegrationInput;
  IntegrationInput: IntegrationInput;
  CreateInternalizationPayload: CreateInternalizationPayload;
  CreateInternalizationInput: CreateInternalizationInput;
  InternalizationInput: InternalizationInput;
  CreateInvitationPayload: CreateInvitationPayload;
  CreateInvitationInput: CreateInvitationInput;
  InvitationInput: InvitationInput;
  CreateInvoicePayload: CreateInvoicePayload;
  CreateInvoiceInput: CreateInvoiceInput;
  InvoiceInput: InvoiceInput;
  CreateLeadPayload: CreateLeadPayload;
  CreateLeadInput: CreateLeadInput;
  LeadInput: LeadInput;
  CreateManufacturerPayload: CreateManufacturerPayload;
  CreateManufacturerInput: CreateManufacturerInput;
  ManufacturerInput: ManufacturerInput;
  CreateMediamanagerPayload: CreateMediamanagerPayload;
  CreateMediamanagerInput: CreateMediamanagerInput;
  MediamanagerInput: MediamanagerInput;
  CreateMeetingPayload: CreateMeetingPayload;
  CreateMeetingInput: CreateMeetingInput;
  MeetingInput: MeetingInput;
  CreateMessagePayload: CreateMessagePayload;
  CreateMessageInput: CreateMessageInput;
  MessageInput: MessageInput;
  CreateNewsletterPayload: CreateNewsletterPayload;
  CreateNewsletterInput: CreateNewsletterInput;
  NewsletterInput: NewsletterInput;
  CreateOotoPayload: CreateOotoPayload;
  CreateOotoInput: CreateOotoInput;
  OotoInput: OotoInput;
  CreateOpportunityPayload: CreateOpportunityPayload;
  CreateOpportunityInput: CreateOpportunityInput;
  OpportunityInput: OpportunityInput;
  CreateOrderPayload: CreateOrderPayload;
  CreateOrderInput: CreateOrderInput;
  OrderInput: OrderInput;
  CreatePagePayload: CreatePagePayload;
  CreatePageInput: CreatePageInput;
  PageInput: PageInput;
  CreatePartnerPayload: CreatePartnerPayload;
  CreatePartnerInput: CreatePartnerInput;
  PartnerInput: PartnerInput;
  CreatePaymentPayload: CreatePaymentPayload;
  CreatePaymentInput: CreatePaymentInput;
  PaymentInput: PaymentInput;
  CreatePermissionPayload: CreatePermissionPayload;
  CreatePermissionInput: CreatePermissionInput;
  PermissionInput: PermissionInput;
  CreatePluginPayload: CreatePluginPayload;
  CreatePluginInput: CreatePluginInput;
  PluginInput: PluginInput;
  CreatePollPayload: CreatePollPayload;
  CreatePollInput: CreatePollInput;
  PollInput: PollInput;
  CreateProductTypePayload: CreateProductTypePayload;
  CreateProductTypeInput: CreateProductTypeInput;
  ProductTypeInput: ProductTypeInput;
  CreateProductPayload: CreateProductPayload;
  CreateProductInput: CreateProductInput;
  ProductInput: ProductInput;
  CreateProjectPayload: CreateProjectPayload;
  CreateProjectInput: CreateProjectInput;
  ProjectInput: ProjectInput;
  CreateProviderPayload: CreateProviderPayload;
  CreateProviderInput: CreateProviderInput;
  ProviderInput: ProviderInput;
  CreateQuotePayload: CreateQuotePayload;
  CreateQuoteInput: CreateQuoteInput;
  QuoteInput: QuoteInput;
  CreateRatingPayload: CreateRatingPayload;
  CreateRatingInput: CreateRatingInput;
  RatingInput: RatingInput;
  CreateReportPayload: CreateReportPayload;
  CreateReportInput: CreateReportInput;
  ReportInput: ReportInput;
  CreateReturnPayload: CreateReturnPayload;
  CreateReturnInput: CreateReturnInput;
  ReturnInput: ReturnInput;
  CreateReviewPayload: CreateReviewPayload;
  CreateReviewInput: CreateReviewInput;
  ReviewInput: ReviewInput;
  CreateRewardPayload: CreateRewardPayload;
  CreateRewardInput: CreateRewardInput;
  RewardInput: RewardInput;
  CreateRolePayload: CreateRolePayload;
  CreateRoleInput: CreateRoleInput;
  RoleInput: RoleInput;
  CreateSchedulerPayload: CreateSchedulerPayload;
  CreateSchedulerInput: CreateSchedulerInput;
  SchedulerInput: SchedulerInput;
  CreateSegmentPayload: CreateSegmentPayload;
  CreateSegmentInput: CreateSegmentInput;
  SegmentInput: SegmentInput;
  CreateSettingPayload: CreateSettingPayload;
  CreateSettingInput: CreateSettingInput;
  SettingInput: SettingInput;
  CreateShipmentPayload: CreateShipmentPayload;
  CreateShipmentInput: CreateShipmentInput;
  ShipmentInput: ShipmentInput;
  CreateSpecialDiscountPayload: CreateSpecialDiscountPayload;
  CreateSpecialDiscountInput: CreateSpecialDiscountInput;
  SpecialDiscountInput: SpecialDiscountInput;
  CreateStatePayload: CreateStatePayload;
  CreateStateInput: CreateStateInput;
  StateInput: StateInput;
  CreateStatisticPayload: CreateStatisticPayload;
  CreateStatisticInput: CreateStatisticInput;
  StatisticInput: StatisticInput;
  CreateStockPayload: CreateStockPayload;
  CreateStockInput: CreateStockInput;
  StockInput: StockInput;
  CreateSurveyPayload: CreateSurveyPayload;
  CreateSurveyInput: CreateSurveyInput;
  SurveyInput: SurveyInput;
  CreateTagPayload: CreateTagPayload;
  CreateTagInput: CreateTagInput;
  TagInput: TagInput;
  CreateTargetPayload: CreateTargetPayload;
  CreateTargetInput: CreateTargetInput;
  TargetInput: TargetInput;
  CreateTaxCategoryPayload: CreateTaxCategoryPayload;
  CreateTaxCategoryInput: CreateTaxCategoryInput;
  TaxCategoryInput: TaxCategoryInput;
  CreateTaxRatePayload: CreateTaxRatePayload;
  CreateTaxRateInput: CreateTaxRateInput;
  TaxRateInput: TaxRateInput;
  CreateTaxRulePayload: CreateTaxRulePayload;
  CreateTaxRuleInput: CreateTaxRuleInput;
  TaxRuleInput: TaxRuleInput;
  CreateTemplatePayload: CreateTemplatePayload;
  CreateTemplateInput: CreateTemplateInput;
  TemplateInput: TemplateInput;
  CreateThemePayload: CreateThemePayload;
  CreateThemeInput: CreateThemeInput;
  ThemeInput: ThemeInput;
  CreateTicketingPayload: CreateTicketingPayload;
  CreateTicketingInput: CreateTicketingInput;
  TicketingInput: TicketingInput;
  CreateTrainingPayload: CreateTrainingPayload;
  CreateTrainingInput: CreateTrainingInput;
  TrainingInput: TrainingInput;
  CreateTransactionPayload: CreateTransactionPayload;
  CreateTransactionInput: CreateTransactionInput;
  TransactionInput: TransactionInput;
  CreateUploadFilePayload: CreateUploadFilePayload;
  CreateUploadFileInput: CreateUploadFileInput;
  UploadFileInput: UploadFileInput;
  CreateUserPayload: CreateUserPayload;
  CreateUserInput: CreateUserInput;
  UserInput: UserInput;
  CreateVendorPayload: CreateVendorPayload;
  CreateVendorInput: CreateVendorInput;
  VendorInput: VendorInput;
  CreateVisitPayload: CreateVisitPayload;
  CreateVisitInput: CreateVisitInput;
  VisitInput: VisitInput;
  CreateWarehousePayload: CreateWarehousePayload;
  CreateWarehouseInput: CreateWarehouseInput;
  WarehouseInput: WarehouseInput;
  CreateWebhookPayload: CreateWebhookPayload;
  CreateWebhookInput: CreateWebhookInput;
  WebhookInput: WebhookInput;
  CreateWebsitePayload: CreateWebsitePayload;
  CreateWebsiteInput: CreateWebsiteInput;
  WebsiteInput: WebsiteInput;
  CreateWishlistPayload: CreateWishlistPayload;
  CreateWishlistInput: CreateWishlistInput;
  WishlistInput: WishlistInput;
  CreateWorkspacePayload: CreateWorkspacePayload;
  CreateWorkspaceInput: CreateWorkspaceInput;
  WorkspaceInput: WorkspaceInput;
  CreateZonePayload: CreateZonePayload;
  CreateZoneInput: CreateZoneInput;
  ZoneInput: ZoneInput;
  UpdateAccountPayload: UpdateAccountPayload;
  UpdateAccountInput: UpdateAccountInput;
  AccountPatch: AccountPatch;
  UpdateAccountByIdInput: UpdateAccountByIdInput;
  UpdateAgreementPayload: UpdateAgreementPayload;
  UpdateAgreementInput: UpdateAgreementInput;
  AgreementPatch: AgreementPatch;
  UpdateAgreementByIdInput: UpdateAgreementByIdInput;
  UpdateAnalyticPayload: UpdateAnalyticPayload;
  UpdateAnalyticInput: UpdateAnalyticInput;
  AnalyticPatch: AnalyticPatch;
  UpdateAnalyticByIdInput: UpdateAnalyticByIdInput;
  UpdateApitokenPayload: UpdateApitokenPayload;
  UpdateApitokenInput: UpdateApitokenInput;
  ApitokenPatch: ApitokenPatch;
  UpdateApitokenByIdInput: UpdateApitokenByIdInput;
  UpdateArticlePayload: UpdateArticlePayload;
  UpdateArticleInput: UpdateArticleInput;
  ArticlePatch: ArticlePatch;
  UpdateArticleByIdInput: UpdateArticleByIdInput;
  UpdateAttributePayload: UpdateAttributePayload;
  UpdateAttributeInput: UpdateAttributeInput;
  AttributePatch: AttributePatch;
  UpdateAttributeByIdInput: UpdateAttributeByIdInput;
  UpdateBrandPayload: UpdateBrandPayload;
  UpdateBrandInput: UpdateBrandInput;
  BrandPatch: BrandPatch;
  UpdateBrandByIdInput: UpdateBrandByIdInput;
  UpdateCartPriceRulePayload: UpdateCartPriceRulePayload;
  UpdateCartPriceRuleInput: UpdateCartPriceRuleInput;
  CartPriceRulePatch: CartPriceRulePatch;
  UpdateCartPriceRuleByIdInput: UpdateCartPriceRuleByIdInput;
  UpdateCasePayload: UpdateCasePayload;
  UpdateCaseInput: UpdateCaseInput;
  CasePatch: CasePatch;
  UpdateCaseByIdInput: UpdateCaseByIdInput;
  UpdateCatalogPriceRulePayload: UpdateCatalogPriceRulePayload;
  UpdateCatalogPriceRuleInput: UpdateCatalogPriceRuleInput;
  CatalogPriceRulePatch: CatalogPriceRulePatch;
  UpdateCatalogPriceRuleByIdInput: UpdateCatalogPriceRuleByIdInput;
  UpdateCategoryPayload: UpdateCategoryPayload;
  UpdateCategoryInput: UpdateCategoryInput;
  CategoryPatch: CategoryPatch;
  UpdateCategoryByIdInput: UpdateCategoryByIdInput;
  UpdateChannelPayload: UpdateChannelPayload;
  UpdateChannelInput: UpdateChannelInput;
  ChannelPatch: ChannelPatch;
  UpdateChannelByIdInput: UpdateChannelByIdInput;
  UpdateChecklistPayload: UpdateChecklistPayload;
  UpdateChecklistInput: UpdateChecklistInput;
  ChecklistPatch: ChecklistPatch;
  UpdateChecklistByIdInput: UpdateChecklistByIdInput;
  UpdateCityPayload: UpdateCityPayload;
  UpdateCityInput: UpdateCityInput;
  CityPatch: CityPatch;
  UpdateCityByIdInput: UpdateCityByIdInput;
  UpdateCollectionPayload: UpdateCollectionPayload;
  UpdateCollectionInput: UpdateCollectionInput;
  CollectionPatch: CollectionPatch;
  UpdateCollectionByIdInput: UpdateCollectionByIdInput;
  UpdateCommentPayload: UpdateCommentPayload;
  UpdateCommentInput: UpdateCommentInput;
  CommentPatch: CommentPatch;
  UpdateCommentByIdInput: UpdateCommentByIdInput;
  UpdateContentTypePayload: UpdateContentTypePayload;
  UpdateContentTypeInput: UpdateContentTypeInput;
  ContentTypePatch: ContentTypePatch;
  UpdateContentTypeByIdInput: UpdateContentTypeByIdInput;
  UpdateContractPayload: UpdateContractPayload;
  UpdateContractInput: UpdateContractInput;
  ContractPatch: ContractPatch;
  UpdateContractByIdInput: UpdateContractByIdInput;
  UpdateCountryPayload: UpdateCountryPayload;
  UpdateCountryInput: UpdateCountryInput;
  CountryPatch: CountryPatch;
  UpdateCountryByIdInput: UpdateCountryByIdInput;
  UpdateCouponPayload: UpdateCouponPayload;
  UpdateCouponInput: UpdateCouponInput;
  CouponPatch: CouponPatch;
  UpdateCouponByIdInput: UpdateCouponByIdInput;
  UpdateCreditMemoPayload: UpdateCreditMemoPayload;
  UpdateCreditMemoInput: UpdateCreditMemoInput;
  CreditMemoPatch: CreditMemoPatch;
  UpdateCreditMemoByCreditMemoAndIdInput: UpdateCreditMemoByCreditMemoAndIdInput;
  UpdateCurrencyPayload: UpdateCurrencyPayload;
  UpdateCurrencyInput: UpdateCurrencyInput;
  CurrencyPatch: CurrencyPatch;
  UpdateCurrencyByIdInput: UpdateCurrencyByIdInput;
  UpdateCurrencyRatePayload: UpdateCurrencyRatePayload;
  UpdateCurrencyRateInput: UpdateCurrencyRateInput;
  CurrencyRatePatch: CurrencyRatePatch;
  UpdateCurrencyRateByImportServiceInput: UpdateCurrencyRateByImportServiceInput;
  UpdateCurrencySymbolPayload: UpdateCurrencySymbolPayload;
  UpdateCurrencySymbolInput: UpdateCurrencySymbolInput;
  CurrencySymbolPatch: CurrencySymbolPatch;
  UpdateCurrencySymbolBySymbolInput: UpdateCurrencySymbolBySymbolInput;
  UpdateCustomerGroupPayload: UpdateCustomerGroupPayload;
  UpdateCustomerGroupInput: UpdateCustomerGroupInput;
  CustomerGroupPatch: CustomerGroupPatch;
  UpdateCustomerGroupByIdInput: UpdateCustomerGroupByIdInput;
  UpdateCustomerPayload: UpdateCustomerPayload;
  UpdateCustomerInput: UpdateCustomerInput;
  CustomerPatch: CustomerPatch;
  UpdateCustomerByIdInput: UpdateCustomerByIdInput;
  UpdateCustomizationPayload: UpdateCustomizationPayload;
  UpdateCustomizationInput: UpdateCustomizationInput;
  CustomizationPatch: CustomizationPatch;
  UpdateCustomizationByIdInput: UpdateCustomizationByIdInput;
  UpdateDashboardPayload: UpdateDashboardPayload;
  UpdateDashboardInput: UpdateDashboardInput;
  DashboardPatch: DashboardPatch;
  UpdateDashboardByIdInput: UpdateDashboardByIdInput;
  UpdateDeepdivePayload: UpdateDeepdivePayload;
  UpdateDeepdiveInput: UpdateDeepdiveInput;
  DeepdivePatch: DeepdivePatch;
  UpdateDeepdiveByIdInput: UpdateDeepdiveByIdInput;
  UpdateDigiboardPayload: UpdateDigiboardPayload;
  UpdateDigiboardInput: UpdateDigiboardInput;
  DigiboardPatch: DigiboardPatch;
  UpdateDigiboardByIdInput: UpdateDigiboardByIdInput;
  UpdateEmailPayload: UpdateEmailPayload;
  UpdateEmailInput: UpdateEmailInput;
  EmailPatch: EmailPatch;
  UpdateEmailByIdInput: UpdateEmailByIdInput;
  UpdateEndofshiftPayload: UpdateEndofshiftPayload;
  UpdateEndofshiftInput: UpdateEndofshiftInput;
  EndofshiftPatch: EndofshiftPatch;
  UpdateEndofshiftByIdInput: UpdateEndofshiftByIdInput;
  UpdateEventPayload: UpdateEventPayload;
  UpdateEventInput: UpdateEventInput;
  EventPatch: EventPatch;
  UpdateEventByIdInput: UpdateEventByIdInput;
  UpdateFullfillmentPayload: UpdateFullfillmentPayload;
  UpdateFullfillmentInput: UpdateFullfillmentInput;
  FullfillmentPatch: FullfillmentPatch;
  UpdateFullfillmentByIdInput: UpdateFullfillmentByIdInput;
  UpdateGiftCertificatePayload: UpdateGiftCertificatePayload;
  UpdateGiftCertificateInput: UpdateGiftCertificateInput;
  GiftCertificatePatch: GiftCertificatePatch;
  UpdateGiftCertificateByIdInput: UpdateGiftCertificateByIdInput;
  UpdateGlossaryPayload: UpdateGlossaryPayload;
  UpdateGlossaryInput: UpdateGlossaryInput;
  GlossaryPatch: GlossaryPatch;
  UpdateGlossaryByIdInput: UpdateGlossaryByIdInput;
  UpdateImportmPayload: UpdateImportmPayload;
  UpdateImportmInput: UpdateImportmInput;
  ImportmPatch: ImportmPatch;
  UpdateImportmByIdInput: UpdateImportmByIdInput;
  UpdateIntegrationPayload: UpdateIntegrationPayload;
  UpdateIntegrationInput: UpdateIntegrationInput;
  IntegrationPatch: IntegrationPatch;
  UpdateIntegrationByIdInput: UpdateIntegrationByIdInput;
  UpdateInternalizationPayload: UpdateInternalizationPayload;
  UpdateInternalizationInput: UpdateInternalizationInput;
  InternalizationPatch: InternalizationPatch;
  UpdateInternalizationByIdInput: UpdateInternalizationByIdInput;
  UpdateInvitationPayload: UpdateInvitationPayload;
  UpdateInvitationInput: UpdateInvitationInput;
  InvitationPatch: InvitationPatch;
  UpdateInvitationByIdInput: UpdateInvitationByIdInput;
  UpdateInvoicePayload: UpdateInvoicePayload;
  UpdateInvoiceInput: UpdateInvoiceInput;
  InvoicePatch: InvoicePatch;
  UpdateInvoiceByIdInput: UpdateInvoiceByIdInput;
  UpdateLeadPayload: UpdateLeadPayload;
  UpdateLeadInput: UpdateLeadInput;
  LeadPatch: LeadPatch;
  UpdateLeadByIdInput: UpdateLeadByIdInput;
  UpdateManufacturerPayload: UpdateManufacturerPayload;
  UpdateManufacturerInput: UpdateManufacturerInput;
  ManufacturerPatch: ManufacturerPatch;
  UpdateManufacturerByIdInput: UpdateManufacturerByIdInput;
  UpdateMediamanagerPayload: UpdateMediamanagerPayload;
  UpdateMediamanagerInput: UpdateMediamanagerInput;
  MediamanagerPatch: MediamanagerPatch;
  UpdateMediamanagerByIdInput: UpdateMediamanagerByIdInput;
  UpdateMeetingPayload: UpdateMeetingPayload;
  UpdateMeetingInput: UpdateMeetingInput;
  MeetingPatch: MeetingPatch;
  UpdateMeetingByIdInput: UpdateMeetingByIdInput;
  UpdateMessagePayload: UpdateMessagePayload;
  UpdateMessageInput: UpdateMessageInput;
  MessagePatch: MessagePatch;
  UpdateMessageByIdInput: UpdateMessageByIdInput;
  UpdateNewsletterPayload: UpdateNewsletterPayload;
  UpdateNewsletterInput: UpdateNewsletterInput;
  NewsletterPatch: NewsletterPatch;
  UpdateNewsletterByIdInput: UpdateNewsletterByIdInput;
  UpdateOotoPayload: UpdateOotoPayload;
  UpdateOotoInput: UpdateOotoInput;
  OotoPatch: OotoPatch;
  UpdateOotoByIdInput: UpdateOotoByIdInput;
  UpdateOpportunityPayload: UpdateOpportunityPayload;
  UpdateOpportunityInput: UpdateOpportunityInput;
  OpportunityPatch: OpportunityPatch;
  UpdateOpportunityByIdInput: UpdateOpportunityByIdInput;
  UpdateOrderPayload: UpdateOrderPayload;
  UpdateOrderInput: UpdateOrderInput;
  OrderPatch: OrderPatch;
  UpdateOrderByIdInput: UpdateOrderByIdInput;
  UpdatePagePayload: UpdatePagePayload;
  UpdatePageInput: UpdatePageInput;
  PagePatch: PagePatch;
  UpdatePageByIdInput: UpdatePageByIdInput;
  UpdatePartnerPayload: UpdatePartnerPayload;
  UpdatePartnerInput: UpdatePartnerInput;
  PartnerPatch: PartnerPatch;
  UpdatePartnerByIdInput: UpdatePartnerByIdInput;
  UpdatePaymentPayload: UpdatePaymentPayload;
  UpdatePaymentInput: UpdatePaymentInput;
  PaymentPatch: PaymentPatch;
  UpdatePaymentByIdInput: UpdatePaymentByIdInput;
  UpdatePermissionPayload: UpdatePermissionPayload;
  UpdatePermissionInput: UpdatePermissionInput;
  PermissionPatch: PermissionPatch;
  UpdatePermissionByIdInput: UpdatePermissionByIdInput;
  UpdatePluginPayload: UpdatePluginPayload;
  UpdatePluginInput: UpdatePluginInput;
  PluginPatch: PluginPatch;
  UpdatePluginByIdInput: UpdatePluginByIdInput;
  UpdatePollPayload: UpdatePollPayload;
  UpdatePollInput: UpdatePollInput;
  PollPatch: PollPatch;
  UpdatePollByIdInput: UpdatePollByIdInput;
  UpdateProductTypePayload: UpdateProductTypePayload;
  UpdateProductTypeInput: UpdateProductTypeInput;
  ProductTypePatch: ProductTypePatch;
  UpdateProductTypeByIdInput: UpdateProductTypeByIdInput;
  UpdateProductPayload: UpdateProductPayload;
  UpdateProductInput: UpdateProductInput;
  ProductPatch: ProductPatch;
  UpdateProductByIdInput: UpdateProductByIdInput;
  UpdateProjectPayload: UpdateProjectPayload;
  UpdateProjectInput: UpdateProjectInput;
  ProjectPatch: ProjectPatch;
  UpdateProjectByIdInput: UpdateProjectByIdInput;
  UpdateProviderPayload: UpdateProviderPayload;
  UpdateProviderInput: UpdateProviderInput;
  ProviderPatch: ProviderPatch;
  UpdateProviderByIdInput: UpdateProviderByIdInput;
  UpdateQuotePayload: UpdateQuotePayload;
  UpdateQuoteInput: UpdateQuoteInput;
  QuotePatch: QuotePatch;
  UpdateQuoteByIdInput: UpdateQuoteByIdInput;
  UpdateRatingPayload: UpdateRatingPayload;
  UpdateRatingInput: UpdateRatingInput;
  RatingPatch: RatingPatch;
  UpdateRatingByIdInput: UpdateRatingByIdInput;
  UpdateReportPayload: UpdateReportPayload;
  UpdateReportInput: UpdateReportInput;
  ReportPatch: ReportPatch;
  UpdateReportByIdInput: UpdateReportByIdInput;
  UpdateReturnPayload: UpdateReturnPayload;
  UpdateReturnInput: UpdateReturnInput;
  ReturnPatch: ReturnPatch;
  UpdateReturnByIdInput: UpdateReturnByIdInput;
  UpdateReviewPayload: UpdateReviewPayload;
  UpdateReviewInput: UpdateReviewInput;
  ReviewPatch: ReviewPatch;
  UpdateReviewByIdInput: UpdateReviewByIdInput;
  UpdateRewardPayload: UpdateRewardPayload;
  UpdateRewardInput: UpdateRewardInput;
  RewardPatch: RewardPatch;
  UpdateRewardByIdInput: UpdateRewardByIdInput;
  UpdateRolePayload: UpdateRolePayload;
  UpdateRoleInput: UpdateRoleInput;
  RolePatch: RolePatch;
  UpdateRoleByIdInput: UpdateRoleByIdInput;
  UpdateSchedulerPayload: UpdateSchedulerPayload;
  UpdateSchedulerInput: UpdateSchedulerInput;
  SchedulerPatch: SchedulerPatch;
  UpdateSchedulerByIdInput: UpdateSchedulerByIdInput;
  UpdateSegmentPayload: UpdateSegmentPayload;
  UpdateSegmentInput: UpdateSegmentInput;
  SegmentPatch: SegmentPatch;
  UpdateSegmentByIdInput: UpdateSegmentByIdInput;
  UpdateSettingPayload: UpdateSettingPayload;
  UpdateSettingInput: UpdateSettingInput;
  SettingPatch: SettingPatch;
  UpdateSettingByIdInput: UpdateSettingByIdInput;
  UpdateShipmentPayload: UpdateShipmentPayload;
  UpdateShipmentInput: UpdateShipmentInput;
  ShipmentPatch: ShipmentPatch;
  UpdateShipmentByIdInput: UpdateShipmentByIdInput;
  UpdateSpecialDiscountPayload: UpdateSpecialDiscountPayload;
  UpdateSpecialDiscountInput: UpdateSpecialDiscountInput;
  SpecialDiscountPatch: SpecialDiscountPatch;
  UpdateSpecialDiscountByIdInput: UpdateSpecialDiscountByIdInput;
  UpdateStatePayload: UpdateStatePayload;
  UpdateStateInput: UpdateStateInput;
  StatePatch: StatePatch;
  UpdateStateByIdInput: UpdateStateByIdInput;
  UpdateStatisticPayload: UpdateStatisticPayload;
  UpdateStatisticInput: UpdateStatisticInput;
  StatisticPatch: StatisticPatch;
  UpdateStatisticByIdInput: UpdateStatisticByIdInput;
  UpdateStockPayload: UpdateStockPayload;
  UpdateStockInput: UpdateStockInput;
  StockPatch: StockPatch;
  UpdateStockByIdInput: UpdateStockByIdInput;
  UpdateSurveyPayload: UpdateSurveyPayload;
  UpdateSurveyInput: UpdateSurveyInput;
  SurveyPatch: SurveyPatch;
  UpdateSurveyByIdInput: UpdateSurveyByIdInput;
  UpdateTagPayload: UpdateTagPayload;
  UpdateTagInput: UpdateTagInput;
  TagPatch: TagPatch;
  UpdateTagByIdInput: UpdateTagByIdInput;
  UpdateTargetPayload: UpdateTargetPayload;
  UpdateTargetInput: UpdateTargetInput;
  TargetPatch: TargetPatch;
  UpdateTargetByIdInput: UpdateTargetByIdInput;
  UpdateTaxCategoryPayload: UpdateTaxCategoryPayload;
  UpdateTaxCategoryInput: UpdateTaxCategoryInput;
  TaxCategoryPatch: TaxCategoryPatch;
  UpdateTaxCategoryByIdInput: UpdateTaxCategoryByIdInput;
  UpdateTaxRatePayload: UpdateTaxRatePayload;
  UpdateTaxRateInput: UpdateTaxRateInput;
  TaxRatePatch: TaxRatePatch;
  UpdateTaxRateByIdInput: UpdateTaxRateByIdInput;
  UpdateTaxRulePayload: UpdateTaxRulePayload;
  UpdateTaxRuleInput: UpdateTaxRuleInput;
  TaxRulePatch: TaxRulePatch;
  UpdateTaxRuleByIdInput: UpdateTaxRuleByIdInput;
  UpdateTemplatePayload: UpdateTemplatePayload;
  UpdateTemplateInput: UpdateTemplateInput;
  TemplatePatch: TemplatePatch;
  UpdateTemplateByIdInput: UpdateTemplateByIdInput;
  UpdateThemePayload: UpdateThemePayload;
  UpdateThemeInput: UpdateThemeInput;
  ThemePatch: ThemePatch;
  UpdateThemeByIdInput: UpdateThemeByIdInput;
  UpdateTicketingPayload: UpdateTicketingPayload;
  UpdateTicketingInput: UpdateTicketingInput;
  TicketingPatch: TicketingPatch;
  UpdateTicketingByIdInput: UpdateTicketingByIdInput;
  UpdateTrainingPayload: UpdateTrainingPayload;
  UpdateTrainingInput: UpdateTrainingInput;
  TrainingPatch: TrainingPatch;
  UpdateTrainingByIdInput: UpdateTrainingByIdInput;
  UpdateTransactionPayload: UpdateTransactionPayload;
  UpdateTransactionInput: UpdateTransactionInput;
  TransactionPatch: TransactionPatch;
  UpdateTransactionByIdInput: UpdateTransactionByIdInput;
  UpdateUploadFilePayload: UpdateUploadFilePayload;
  UpdateUploadFileInput: UpdateUploadFileInput;
  UploadFilePatch: UploadFilePatch;
  UpdateUploadFileByIdInput: UpdateUploadFileByIdInput;
  UpdateUserPayload: UpdateUserPayload;
  UpdateUserInput: UpdateUserInput;
  UserPatch: UserPatch;
  UpdateUserByIdInput: UpdateUserByIdInput;
  UpdateVendorPayload: UpdateVendorPayload;
  UpdateVendorInput: UpdateVendorInput;
  VendorPatch: VendorPatch;
  UpdateVendorByIdInput: UpdateVendorByIdInput;
  UpdateVisitPayload: UpdateVisitPayload;
  UpdateVisitInput: UpdateVisitInput;
  VisitPatch: VisitPatch;
  UpdateVisitByIdInput: UpdateVisitByIdInput;
  UpdateWarehousePayload: UpdateWarehousePayload;
  UpdateWarehouseInput: UpdateWarehouseInput;
  WarehousePatch: WarehousePatch;
  UpdateWarehouseByIdInput: UpdateWarehouseByIdInput;
  UpdateWebhookPayload: UpdateWebhookPayload;
  UpdateWebhookInput: UpdateWebhookInput;
  WebhookPatch: WebhookPatch;
  UpdateWebhookByIdInput: UpdateWebhookByIdInput;
  UpdateWebsitePayload: UpdateWebsitePayload;
  UpdateWebsiteInput: UpdateWebsiteInput;
  WebsitePatch: WebsitePatch;
  UpdateWebsiteByIdInput: UpdateWebsiteByIdInput;
  UpdateWishlistPayload: UpdateWishlistPayload;
  UpdateWishlistInput: UpdateWishlistInput;
  WishlistPatch: WishlistPatch;
  UpdateWishlistByIdInput: UpdateWishlistByIdInput;
  UpdateWorkspacePayload: UpdateWorkspacePayload;
  UpdateWorkspaceInput: UpdateWorkspaceInput;
  WorkspacePatch: WorkspacePatch;
  UpdateWorkspaceByIdInput: UpdateWorkspaceByIdInput;
  UpdateZonePayload: UpdateZonePayload;
  UpdateZoneInput: UpdateZoneInput;
  ZonePatch: ZonePatch;
  UpdateZoneByIdInput: UpdateZoneByIdInput;
  DeleteAccountPayload: DeleteAccountPayload;
  DeleteAccountInput: DeleteAccountInput;
  DeleteAccountByIdInput: DeleteAccountByIdInput;
  DeleteAgreementPayload: DeleteAgreementPayload;
  DeleteAgreementInput: DeleteAgreementInput;
  DeleteAgreementByIdInput: DeleteAgreementByIdInput;
  DeleteAnalyticPayload: DeleteAnalyticPayload;
  DeleteAnalyticInput: DeleteAnalyticInput;
  DeleteAnalyticByIdInput: DeleteAnalyticByIdInput;
  DeleteApitokenPayload: DeleteApitokenPayload;
  DeleteApitokenInput: DeleteApitokenInput;
  DeleteApitokenByIdInput: DeleteApitokenByIdInput;
  DeleteArticlePayload: DeleteArticlePayload;
  DeleteArticleInput: DeleteArticleInput;
  DeleteArticleByIdInput: DeleteArticleByIdInput;
  DeleteAttributePayload: DeleteAttributePayload;
  DeleteAttributeInput: DeleteAttributeInput;
  DeleteAttributeByIdInput: DeleteAttributeByIdInput;
  DeleteBrandPayload: DeleteBrandPayload;
  DeleteBrandInput: DeleteBrandInput;
  DeleteBrandByIdInput: DeleteBrandByIdInput;
  DeleteCartPriceRulePayload: DeleteCartPriceRulePayload;
  DeleteCartPriceRuleInput: DeleteCartPriceRuleInput;
  DeleteCartPriceRuleByIdInput: DeleteCartPriceRuleByIdInput;
  DeleteCasePayload: DeleteCasePayload;
  DeleteCaseInput: DeleteCaseInput;
  DeleteCaseByIdInput: DeleteCaseByIdInput;
  DeleteCatalogPriceRulePayload: DeleteCatalogPriceRulePayload;
  DeleteCatalogPriceRuleInput: DeleteCatalogPriceRuleInput;
  DeleteCatalogPriceRuleByIdInput: DeleteCatalogPriceRuleByIdInput;
  DeleteCategoryPayload: DeleteCategoryPayload;
  DeleteCategoryInput: DeleteCategoryInput;
  DeleteCategoryByIdInput: DeleteCategoryByIdInput;
  DeleteChannelPayload: DeleteChannelPayload;
  DeleteChannelInput: DeleteChannelInput;
  DeleteChannelByIdInput: DeleteChannelByIdInput;
  DeleteChecklistPayload: DeleteChecklistPayload;
  DeleteChecklistInput: DeleteChecklistInput;
  DeleteChecklistByIdInput: DeleteChecklistByIdInput;
  DeleteCityPayload: DeleteCityPayload;
  DeleteCityInput: DeleteCityInput;
  DeleteCityByIdInput: DeleteCityByIdInput;
  DeleteCollectionPayload: DeleteCollectionPayload;
  DeleteCollectionInput: DeleteCollectionInput;
  DeleteCollectionByIdInput: DeleteCollectionByIdInput;
  DeleteCommentPayload: DeleteCommentPayload;
  DeleteCommentInput: DeleteCommentInput;
  DeleteCommentByIdInput: DeleteCommentByIdInput;
  DeleteContentTypePayload: DeleteContentTypePayload;
  DeleteContentTypeInput: DeleteContentTypeInput;
  DeleteContentTypeByIdInput: DeleteContentTypeByIdInput;
  DeleteContractPayload: DeleteContractPayload;
  DeleteContractInput: DeleteContractInput;
  DeleteContractByIdInput: DeleteContractByIdInput;
  DeleteCountryPayload: DeleteCountryPayload;
  DeleteCountryInput: DeleteCountryInput;
  DeleteCountryByIdInput: DeleteCountryByIdInput;
  DeleteCouponPayload: DeleteCouponPayload;
  DeleteCouponInput: DeleteCouponInput;
  DeleteCouponByIdInput: DeleteCouponByIdInput;
  DeleteCreditMemoPayload: DeleteCreditMemoPayload;
  DeleteCreditMemoInput: DeleteCreditMemoInput;
  DeleteCreditMemoByCreditMemoAndIdInput: DeleteCreditMemoByCreditMemoAndIdInput;
  DeleteCurrencyPayload: DeleteCurrencyPayload;
  DeleteCurrencyInput: DeleteCurrencyInput;
  DeleteCurrencyByIdInput: DeleteCurrencyByIdInput;
  DeleteCurrencyRatePayload: DeleteCurrencyRatePayload;
  DeleteCurrencyRateInput: DeleteCurrencyRateInput;
  DeleteCurrencyRateByImportServiceInput: DeleteCurrencyRateByImportServiceInput;
  DeleteCurrencySymbolPayload: DeleteCurrencySymbolPayload;
  DeleteCurrencySymbolInput: DeleteCurrencySymbolInput;
  DeleteCurrencySymbolBySymbolInput: DeleteCurrencySymbolBySymbolInput;
  DeleteCustomerGroupPayload: DeleteCustomerGroupPayload;
  DeleteCustomerGroupInput: DeleteCustomerGroupInput;
  DeleteCustomerGroupByIdInput: DeleteCustomerGroupByIdInput;
  DeleteCustomerPayload: DeleteCustomerPayload;
  DeleteCustomerInput: DeleteCustomerInput;
  DeleteCustomerByIdInput: DeleteCustomerByIdInput;
  DeleteCustomizationPayload: DeleteCustomizationPayload;
  DeleteCustomizationInput: DeleteCustomizationInput;
  DeleteCustomizationByIdInput: DeleteCustomizationByIdInput;
  DeleteDashboardPayload: DeleteDashboardPayload;
  DeleteDashboardInput: DeleteDashboardInput;
  DeleteDashboardByIdInput: DeleteDashboardByIdInput;
  DeleteDeepdivePayload: DeleteDeepdivePayload;
  DeleteDeepdiveInput: DeleteDeepdiveInput;
  DeleteDeepdiveByIdInput: DeleteDeepdiveByIdInput;
  DeleteDigiboardPayload: DeleteDigiboardPayload;
  DeleteDigiboardInput: DeleteDigiboardInput;
  DeleteDigiboardByIdInput: DeleteDigiboardByIdInput;
  DeleteEmailPayload: DeleteEmailPayload;
  DeleteEmailInput: DeleteEmailInput;
  DeleteEmailByIdInput: DeleteEmailByIdInput;
  DeleteEndofshiftPayload: DeleteEndofshiftPayload;
  DeleteEndofshiftInput: DeleteEndofshiftInput;
  DeleteEndofshiftByIdInput: DeleteEndofshiftByIdInput;
  DeleteEventPayload: DeleteEventPayload;
  DeleteEventInput: DeleteEventInput;
  DeleteEventByIdInput: DeleteEventByIdInput;
  DeleteFullfillmentPayload: DeleteFullfillmentPayload;
  DeleteFullfillmentInput: DeleteFullfillmentInput;
  DeleteFullfillmentByIdInput: DeleteFullfillmentByIdInput;
  DeleteGiftCertificatePayload: DeleteGiftCertificatePayload;
  DeleteGiftCertificateInput: DeleteGiftCertificateInput;
  DeleteGiftCertificateByIdInput: DeleteGiftCertificateByIdInput;
  DeleteGlossaryPayload: DeleteGlossaryPayload;
  DeleteGlossaryInput: DeleteGlossaryInput;
  DeleteGlossaryByIdInput: DeleteGlossaryByIdInput;
  DeleteImportmPayload: DeleteImportmPayload;
  DeleteImportmInput: DeleteImportmInput;
  DeleteImportmByIdInput: DeleteImportmByIdInput;
  DeleteIntegrationPayload: DeleteIntegrationPayload;
  DeleteIntegrationInput: DeleteIntegrationInput;
  DeleteIntegrationByIdInput: DeleteIntegrationByIdInput;
  DeleteInternalizationPayload: DeleteInternalizationPayload;
  DeleteInternalizationInput: DeleteInternalizationInput;
  DeleteInternalizationByIdInput: DeleteInternalizationByIdInput;
  DeleteInvitationPayload: DeleteInvitationPayload;
  DeleteInvitationInput: DeleteInvitationInput;
  DeleteInvitationByIdInput: DeleteInvitationByIdInput;
  DeleteInvoicePayload: DeleteInvoicePayload;
  DeleteInvoiceInput: DeleteInvoiceInput;
  DeleteInvoiceByIdInput: DeleteInvoiceByIdInput;
  DeleteLeadPayload: DeleteLeadPayload;
  DeleteLeadInput: DeleteLeadInput;
  DeleteLeadByIdInput: DeleteLeadByIdInput;
  DeleteManufacturerPayload: DeleteManufacturerPayload;
  DeleteManufacturerInput: DeleteManufacturerInput;
  DeleteManufacturerByIdInput: DeleteManufacturerByIdInput;
  DeleteMediamanagerPayload: DeleteMediamanagerPayload;
  DeleteMediamanagerInput: DeleteMediamanagerInput;
  DeleteMediamanagerByIdInput: DeleteMediamanagerByIdInput;
  DeleteMeetingPayload: DeleteMeetingPayload;
  DeleteMeetingInput: DeleteMeetingInput;
  DeleteMeetingByIdInput: DeleteMeetingByIdInput;
  DeleteMessagePayload: DeleteMessagePayload;
  DeleteMessageInput: DeleteMessageInput;
  DeleteMessageByIdInput: DeleteMessageByIdInput;
  DeleteNewsletterPayload: DeleteNewsletterPayload;
  DeleteNewsletterInput: DeleteNewsletterInput;
  DeleteNewsletterByIdInput: DeleteNewsletterByIdInput;
  DeleteOotoPayload: DeleteOotoPayload;
  DeleteOotoInput: DeleteOotoInput;
  DeleteOotoByIdInput: DeleteOotoByIdInput;
  DeleteOpportunityPayload: DeleteOpportunityPayload;
  DeleteOpportunityInput: DeleteOpportunityInput;
  DeleteOpportunityByIdInput: DeleteOpportunityByIdInput;
  DeleteOrderPayload: DeleteOrderPayload;
  DeleteOrderInput: DeleteOrderInput;
  DeleteOrderByIdInput: DeleteOrderByIdInput;
  DeletePagePayload: DeletePagePayload;
  DeletePageInput: DeletePageInput;
  DeletePageByIdInput: DeletePageByIdInput;
  DeletePartnerPayload: DeletePartnerPayload;
  DeletePartnerInput: DeletePartnerInput;
  DeletePartnerByIdInput: DeletePartnerByIdInput;
  DeletePaymentPayload: DeletePaymentPayload;
  DeletePaymentInput: DeletePaymentInput;
  DeletePaymentByIdInput: DeletePaymentByIdInput;
  DeletePermissionPayload: DeletePermissionPayload;
  DeletePermissionInput: DeletePermissionInput;
  DeletePermissionByIdInput: DeletePermissionByIdInput;
  DeletePluginPayload: DeletePluginPayload;
  DeletePluginInput: DeletePluginInput;
  DeletePluginByIdInput: DeletePluginByIdInput;
  DeletePollPayload: DeletePollPayload;
  DeletePollInput: DeletePollInput;
  DeletePollByIdInput: DeletePollByIdInput;
  DeleteProductTypePayload: DeleteProductTypePayload;
  DeleteProductTypeInput: DeleteProductTypeInput;
  DeleteProductTypeByIdInput: DeleteProductTypeByIdInput;
  DeleteProductPayload: DeleteProductPayload;
  DeleteProductInput: DeleteProductInput;
  DeleteProductByIdInput: DeleteProductByIdInput;
  DeleteProjectPayload: DeleteProjectPayload;
  DeleteProjectInput: DeleteProjectInput;
  DeleteProjectByIdInput: DeleteProjectByIdInput;
  DeleteProviderPayload: DeleteProviderPayload;
  DeleteProviderInput: DeleteProviderInput;
  DeleteProviderByIdInput: DeleteProviderByIdInput;
  DeleteQuotePayload: DeleteQuotePayload;
  DeleteQuoteInput: DeleteQuoteInput;
  DeleteQuoteByIdInput: DeleteQuoteByIdInput;
  DeleteRatingPayload: DeleteRatingPayload;
  DeleteRatingInput: DeleteRatingInput;
  DeleteRatingByIdInput: DeleteRatingByIdInput;
  DeleteReportPayload: DeleteReportPayload;
  DeleteReportInput: DeleteReportInput;
  DeleteReportByIdInput: DeleteReportByIdInput;
  DeleteReturnPayload: DeleteReturnPayload;
  DeleteReturnInput: DeleteReturnInput;
  DeleteReturnByIdInput: DeleteReturnByIdInput;
  DeleteReviewPayload: DeleteReviewPayload;
  DeleteReviewInput: DeleteReviewInput;
  DeleteReviewByIdInput: DeleteReviewByIdInput;
  DeleteRewardPayload: DeleteRewardPayload;
  DeleteRewardInput: DeleteRewardInput;
  DeleteRewardByIdInput: DeleteRewardByIdInput;
  DeleteRolePayload: DeleteRolePayload;
  DeleteRoleInput: DeleteRoleInput;
  DeleteRoleByIdInput: DeleteRoleByIdInput;
  DeleteSchedulerPayload: DeleteSchedulerPayload;
  DeleteSchedulerInput: DeleteSchedulerInput;
  DeleteSchedulerByIdInput: DeleteSchedulerByIdInput;
  DeleteSegmentPayload: DeleteSegmentPayload;
  DeleteSegmentInput: DeleteSegmentInput;
  DeleteSegmentByIdInput: DeleteSegmentByIdInput;
  DeleteSettingPayload: DeleteSettingPayload;
  DeleteSettingInput: DeleteSettingInput;
  DeleteSettingByIdInput: DeleteSettingByIdInput;
  DeleteShipmentPayload: DeleteShipmentPayload;
  DeleteShipmentInput: DeleteShipmentInput;
  DeleteShipmentByIdInput: DeleteShipmentByIdInput;
  DeleteSpecialDiscountPayload: DeleteSpecialDiscountPayload;
  DeleteSpecialDiscountInput: DeleteSpecialDiscountInput;
  DeleteSpecialDiscountByIdInput: DeleteSpecialDiscountByIdInput;
  DeleteStatePayload: DeleteStatePayload;
  DeleteStateInput: DeleteStateInput;
  DeleteStateByIdInput: DeleteStateByIdInput;
  DeleteStatisticPayload: DeleteStatisticPayload;
  DeleteStatisticInput: DeleteStatisticInput;
  DeleteStatisticByIdInput: DeleteStatisticByIdInput;
  DeleteStockPayload: DeleteStockPayload;
  DeleteStockInput: DeleteStockInput;
  DeleteStockByIdInput: DeleteStockByIdInput;
  DeleteSurveyPayload: DeleteSurveyPayload;
  DeleteSurveyInput: DeleteSurveyInput;
  DeleteSurveyByIdInput: DeleteSurveyByIdInput;
  DeleteTagPayload: DeleteTagPayload;
  DeleteTagInput: DeleteTagInput;
  DeleteTagByIdInput: DeleteTagByIdInput;
  DeleteTargetPayload: DeleteTargetPayload;
  DeleteTargetInput: DeleteTargetInput;
  DeleteTargetByIdInput: DeleteTargetByIdInput;
  DeleteTaxCategoryPayload: DeleteTaxCategoryPayload;
  DeleteTaxCategoryInput: DeleteTaxCategoryInput;
  DeleteTaxCategoryByIdInput: DeleteTaxCategoryByIdInput;
  DeleteTaxRatePayload: DeleteTaxRatePayload;
  DeleteTaxRateInput: DeleteTaxRateInput;
  DeleteTaxRateByIdInput: DeleteTaxRateByIdInput;
  DeleteTaxRulePayload: DeleteTaxRulePayload;
  DeleteTaxRuleInput: DeleteTaxRuleInput;
  DeleteTaxRuleByIdInput: DeleteTaxRuleByIdInput;
  DeleteTemplatePayload: DeleteTemplatePayload;
  DeleteTemplateInput: DeleteTemplateInput;
  DeleteTemplateByIdInput: DeleteTemplateByIdInput;
  DeleteThemePayload: DeleteThemePayload;
  DeleteThemeInput: DeleteThemeInput;
  DeleteThemeByIdInput: DeleteThemeByIdInput;
  DeleteTicketingPayload: DeleteTicketingPayload;
  DeleteTicketingInput: DeleteTicketingInput;
  DeleteTicketingByIdInput: DeleteTicketingByIdInput;
  DeleteTrainingPayload: DeleteTrainingPayload;
  DeleteTrainingInput: DeleteTrainingInput;
  DeleteTrainingByIdInput: DeleteTrainingByIdInput;
  DeleteTransactionPayload: DeleteTransactionPayload;
  DeleteTransactionInput: DeleteTransactionInput;
  DeleteTransactionByIdInput: DeleteTransactionByIdInput;
  DeleteUploadFilePayload: DeleteUploadFilePayload;
  DeleteUploadFileInput: DeleteUploadFileInput;
  DeleteUploadFileByIdInput: DeleteUploadFileByIdInput;
  DeleteUserPayload: DeleteUserPayload;
  DeleteUserInput: DeleteUserInput;
  DeleteUserByIdInput: DeleteUserByIdInput;
  DeleteVendorPayload: DeleteVendorPayload;
  DeleteVendorInput: DeleteVendorInput;
  DeleteVendorByIdInput: DeleteVendorByIdInput;
  DeleteVisitPayload: DeleteVisitPayload;
  DeleteVisitInput: DeleteVisitInput;
  DeleteVisitByIdInput: DeleteVisitByIdInput;
  DeleteWarehousePayload: DeleteWarehousePayload;
  DeleteWarehouseInput: DeleteWarehouseInput;
  DeleteWarehouseByIdInput: DeleteWarehouseByIdInput;
  DeleteWebhookPayload: DeleteWebhookPayload;
  DeleteWebhookInput: DeleteWebhookInput;
  DeleteWebhookByIdInput: DeleteWebhookByIdInput;
  DeleteWebsitePayload: DeleteWebsitePayload;
  DeleteWebsiteInput: DeleteWebsiteInput;
  DeleteWebsiteByIdInput: DeleteWebsiteByIdInput;
  DeleteWishlistPayload: DeleteWishlistPayload;
  DeleteWishlistInput: DeleteWishlistInput;
  DeleteWishlistByIdInput: DeleteWishlistByIdInput;
  DeleteWorkspacePayload: DeleteWorkspacePayload;
  DeleteWorkspaceInput: DeleteWorkspaceInput;
  DeleteWorkspaceByIdInput: DeleteWorkspaceByIdInput;
  DeleteZonePayload: DeleteZonePayload;
  DeleteZoneInput: DeleteZoneInput;
  DeleteZoneByIdInput: DeleteZoneByIdInput;
  Subscription: {};
}>;

export type QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QuerynodeArgs, 'nodeId'>>;
  allAccounts?: Resolver<Maybe<ResolversTypes['AccountsConnection']>, ParentType, ContextType, RequireFields<QueryallAccountsArgs, 'orderBy'>>;
  allAccountsList?: Resolver<Maybe<Array<ResolversTypes['Account']>>, ParentType, ContextType, Partial<QueryallAccountsListArgs>>;
  allAgreements?: Resolver<Maybe<ResolversTypes['AgreementsConnection']>, ParentType, ContextType, RequireFields<QueryallAgreementsArgs, 'orderBy'>>;
  allAgreementsList?: Resolver<Maybe<Array<ResolversTypes['Agreement']>>, ParentType, ContextType, Partial<QueryallAgreementsListArgs>>;
  allAnalytics?: Resolver<Maybe<ResolversTypes['AnalyticsConnection']>, ParentType, ContextType, RequireFields<QueryallAnalyticsArgs, 'orderBy'>>;
  allAnalyticsList?: Resolver<Maybe<Array<ResolversTypes['Analytic']>>, ParentType, ContextType, Partial<QueryallAnalyticsListArgs>>;
  allApitokens?: Resolver<Maybe<ResolversTypes['ApitokensConnection']>, ParentType, ContextType, RequireFields<QueryallApitokensArgs, 'orderBy'>>;
  allApitokensList?: Resolver<Maybe<Array<ResolversTypes['Apitoken']>>, ParentType, ContextType, Partial<QueryallApitokensListArgs>>;
  allArticles?: Resolver<Maybe<ResolversTypes['ArticlesConnection']>, ParentType, ContextType, RequireFields<QueryallArticlesArgs, 'orderBy'>>;
  allArticlesList?: Resolver<Maybe<Array<ResolversTypes['Article']>>, ParentType, ContextType, Partial<QueryallArticlesListArgs>>;
  allAttributes?: Resolver<Maybe<ResolversTypes['AttributesConnection']>, ParentType, ContextType, RequireFields<QueryallAttributesArgs, 'orderBy'>>;
  allAttributesList?: Resolver<Maybe<Array<ResolversTypes['Attribute']>>, ParentType, ContextType, Partial<QueryallAttributesListArgs>>;
  allBrands?: Resolver<Maybe<ResolversTypes['BrandsConnection']>, ParentType, ContextType, RequireFields<QueryallBrandsArgs, 'orderBy'>>;
  allBrandsList?: Resolver<Maybe<Array<ResolversTypes['Brand']>>, ParentType, ContextType, Partial<QueryallBrandsListArgs>>;
  allCartPriceRules?: Resolver<Maybe<ResolversTypes['CartPriceRulesConnection']>, ParentType, ContextType, RequireFields<QueryallCartPriceRulesArgs, 'orderBy'>>;
  allCartPriceRulesList?: Resolver<Maybe<Array<ResolversTypes['CartPriceRule']>>, ParentType, ContextType, Partial<QueryallCartPriceRulesListArgs>>;
  allCases?: Resolver<Maybe<ResolversTypes['CasesConnection']>, ParentType, ContextType, RequireFields<QueryallCasesArgs, 'orderBy'>>;
  allCasesList?: Resolver<Maybe<Array<ResolversTypes['Case']>>, ParentType, ContextType, Partial<QueryallCasesListArgs>>;
  allCatalogPriceRules?: Resolver<Maybe<ResolversTypes['CatalogPriceRulesConnection']>, ParentType, ContextType, RequireFields<QueryallCatalogPriceRulesArgs, 'orderBy'>>;
  allCatalogPriceRulesList?: Resolver<Maybe<Array<ResolversTypes['CatalogPriceRule']>>, ParentType, ContextType, Partial<QueryallCatalogPriceRulesListArgs>>;
  allCategories?: Resolver<Maybe<ResolversTypes['CategoriesConnection']>, ParentType, ContextType, RequireFields<QueryallCategoriesArgs, 'orderBy'>>;
  allCategoriesList?: Resolver<Maybe<Array<ResolversTypes['Category']>>, ParentType, ContextType, Partial<QueryallCategoriesListArgs>>;
  allChannels?: Resolver<Maybe<ResolversTypes['ChannelsConnection']>, ParentType, ContextType, RequireFields<QueryallChannelsArgs, 'orderBy'>>;
  allChannelsList?: Resolver<Maybe<Array<ResolversTypes['Channel']>>, ParentType, ContextType, Partial<QueryallChannelsListArgs>>;
  allChecklists?: Resolver<Maybe<ResolversTypes['ChecklistsConnection']>, ParentType, ContextType, RequireFields<QueryallChecklistsArgs, 'orderBy'>>;
  allChecklistsList?: Resolver<Maybe<Array<ResolversTypes['Checklist']>>, ParentType, ContextType, Partial<QueryallChecklistsListArgs>>;
  allCities?: Resolver<Maybe<ResolversTypes['CitiesConnection']>, ParentType, ContextType, RequireFields<QueryallCitiesArgs, 'orderBy'>>;
  allCitiesList?: Resolver<Maybe<Array<ResolversTypes['City']>>, ParentType, ContextType, Partial<QueryallCitiesListArgs>>;
  allCollections?: Resolver<Maybe<ResolversTypes['CollectionsConnection']>, ParentType, ContextType, RequireFields<QueryallCollectionsArgs, 'orderBy'>>;
  allCollectionsList?: Resolver<Maybe<Array<ResolversTypes['Collection']>>, ParentType, ContextType, Partial<QueryallCollectionsListArgs>>;
  allComments?: Resolver<Maybe<ResolversTypes['CommentsConnection']>, ParentType, ContextType, RequireFields<QueryallCommentsArgs, 'orderBy'>>;
  allCommentsList?: Resolver<Maybe<Array<ResolversTypes['Comment']>>, ParentType, ContextType, Partial<QueryallCommentsListArgs>>;
  allContentTypes?: Resolver<Maybe<ResolversTypes['ContentTypesConnection']>, ParentType, ContextType, RequireFields<QueryallContentTypesArgs, 'orderBy'>>;
  allContentTypesList?: Resolver<Maybe<Array<ResolversTypes['ContentType']>>, ParentType, ContextType, Partial<QueryallContentTypesListArgs>>;
  allContracts?: Resolver<Maybe<ResolversTypes['ContractsConnection']>, ParentType, ContextType, RequireFields<QueryallContractsArgs, 'orderBy'>>;
  allContractsList?: Resolver<Maybe<Array<ResolversTypes['Contract']>>, ParentType, ContextType, Partial<QueryallContractsListArgs>>;
  allCountries?: Resolver<Maybe<ResolversTypes['CountriesConnection']>, ParentType, ContextType, RequireFields<QueryallCountriesArgs, 'orderBy'>>;
  allCountriesList?: Resolver<Maybe<Array<ResolversTypes['Country']>>, ParentType, ContextType, Partial<QueryallCountriesListArgs>>;
  allCoupons?: Resolver<Maybe<ResolversTypes['CouponsConnection']>, ParentType, ContextType, RequireFields<QueryallCouponsArgs, 'orderBy'>>;
  allCouponsList?: Resolver<Maybe<Array<ResolversTypes['Coupon']>>, ParentType, ContextType, Partial<QueryallCouponsListArgs>>;
  allCreditMemos?: Resolver<Maybe<ResolversTypes['CreditMemosConnection']>, ParentType, ContextType, RequireFields<QueryallCreditMemosArgs, 'orderBy'>>;
  allCreditMemosList?: Resolver<Maybe<Array<ResolversTypes['CreditMemo']>>, ParentType, ContextType, Partial<QueryallCreditMemosListArgs>>;
  allCurrencies?: Resolver<Maybe<ResolversTypes['CurrenciesConnection']>, ParentType, ContextType, RequireFields<QueryallCurrenciesArgs, 'orderBy'>>;
  allCurrenciesList?: Resolver<Maybe<Array<ResolversTypes['Currency']>>, ParentType, ContextType, Partial<QueryallCurrenciesListArgs>>;
  allCurrencyRates?: Resolver<Maybe<ResolversTypes['CurrencyRatesConnection']>, ParentType, ContextType, RequireFields<QueryallCurrencyRatesArgs, 'orderBy'>>;
  allCurrencyRatesList?: Resolver<Maybe<Array<ResolversTypes['CurrencyRate']>>, ParentType, ContextType, Partial<QueryallCurrencyRatesListArgs>>;
  allCurrencySymbols?: Resolver<Maybe<ResolversTypes['CurrencySymbolsConnection']>, ParentType, ContextType, RequireFields<QueryallCurrencySymbolsArgs, 'orderBy'>>;
  allCurrencySymbolsList?: Resolver<Maybe<Array<ResolversTypes['CurrencySymbol']>>, ParentType, ContextType, Partial<QueryallCurrencySymbolsListArgs>>;
  allCustomerGroups?: Resolver<Maybe<ResolversTypes['CustomerGroupsConnection']>, ParentType, ContextType, RequireFields<QueryallCustomerGroupsArgs, 'orderBy'>>;
  allCustomerGroupsList?: Resolver<Maybe<Array<ResolversTypes['CustomerGroup']>>, ParentType, ContextType, Partial<QueryallCustomerGroupsListArgs>>;
  allCustomers?: Resolver<Maybe<ResolversTypes['CustomersConnection']>, ParentType, ContextType, RequireFields<QueryallCustomersArgs, 'orderBy'>>;
  allCustomersList?: Resolver<Maybe<Array<ResolversTypes['Customer']>>, ParentType, ContextType, Partial<QueryallCustomersListArgs>>;
  allCustomizations?: Resolver<Maybe<ResolversTypes['CustomizationsConnection']>, ParentType, ContextType, RequireFields<QueryallCustomizationsArgs, 'orderBy'>>;
  allCustomizationsList?: Resolver<Maybe<Array<ResolversTypes['Customization']>>, ParentType, ContextType, Partial<QueryallCustomizationsListArgs>>;
  allDashboards?: Resolver<Maybe<ResolversTypes['DashboardsConnection']>, ParentType, ContextType, RequireFields<QueryallDashboardsArgs, 'orderBy'>>;
  allDashboardsList?: Resolver<Maybe<Array<ResolversTypes['Dashboard']>>, ParentType, ContextType, Partial<QueryallDashboardsListArgs>>;
  allDeepdives?: Resolver<Maybe<ResolversTypes['DeepdivesConnection']>, ParentType, ContextType, RequireFields<QueryallDeepdivesArgs, 'orderBy'>>;
  allDeepdivesList?: Resolver<Maybe<Array<ResolversTypes['Deepdive']>>, ParentType, ContextType, Partial<QueryallDeepdivesListArgs>>;
  allDigiboards?: Resolver<Maybe<ResolversTypes['DigiboardsConnection']>, ParentType, ContextType, RequireFields<QueryallDigiboardsArgs, 'orderBy'>>;
  allDigiboardsList?: Resolver<Maybe<Array<ResolversTypes['Digiboard']>>, ParentType, ContextType, Partial<QueryallDigiboardsListArgs>>;
  allEmails?: Resolver<Maybe<ResolversTypes['EmailsConnection']>, ParentType, ContextType, RequireFields<QueryallEmailsArgs, 'orderBy'>>;
  allEmailsList?: Resolver<Maybe<Array<ResolversTypes['Email']>>, ParentType, ContextType, Partial<QueryallEmailsListArgs>>;
  allEndofshifts?: Resolver<Maybe<ResolversTypes['EndofshiftsConnection']>, ParentType, ContextType, RequireFields<QueryallEndofshiftsArgs, 'orderBy'>>;
  allEndofshiftsList?: Resolver<Maybe<Array<ResolversTypes['Endofshift']>>, ParentType, ContextType, Partial<QueryallEndofshiftsListArgs>>;
  allEvents?: Resolver<Maybe<ResolversTypes['EventsConnection']>, ParentType, ContextType, RequireFields<QueryallEventsArgs, 'orderBy'>>;
  allEventsList?: Resolver<Maybe<Array<ResolversTypes['Event']>>, ParentType, ContextType, Partial<QueryallEventsListArgs>>;
  allFullfillments?: Resolver<Maybe<ResolversTypes['FullfillmentsConnection']>, ParentType, ContextType, RequireFields<QueryallFullfillmentsArgs, 'orderBy'>>;
  allFullfillmentsList?: Resolver<Maybe<Array<ResolversTypes['Fullfillment']>>, ParentType, ContextType, Partial<QueryallFullfillmentsListArgs>>;
  allGiftCertificates?: Resolver<Maybe<ResolversTypes['GiftCertificatesConnection']>, ParentType, ContextType, RequireFields<QueryallGiftCertificatesArgs, 'orderBy'>>;
  allGiftCertificatesList?: Resolver<Maybe<Array<ResolversTypes['GiftCertificate']>>, ParentType, ContextType, Partial<QueryallGiftCertificatesListArgs>>;
  allGlossaries?: Resolver<Maybe<ResolversTypes['GlossariesConnection']>, ParentType, ContextType, RequireFields<QueryallGlossariesArgs, 'orderBy'>>;
  allGlossariesList?: Resolver<Maybe<Array<ResolversTypes['Glossary']>>, ParentType, ContextType, Partial<QueryallGlossariesListArgs>>;
  allImportms?: Resolver<Maybe<ResolversTypes['ImportmsConnection']>, ParentType, ContextType, RequireFields<QueryallImportmsArgs, 'orderBy'>>;
  allImportmsList?: Resolver<Maybe<Array<ResolversTypes['Importm']>>, ParentType, ContextType, Partial<QueryallImportmsListArgs>>;
  allIntegrations?: Resolver<Maybe<ResolversTypes['IntegrationsConnection']>, ParentType, ContextType, RequireFields<QueryallIntegrationsArgs, 'orderBy'>>;
  allIntegrationsList?: Resolver<Maybe<Array<ResolversTypes['Integration']>>, ParentType, ContextType, Partial<QueryallIntegrationsListArgs>>;
  allInternalizations?: Resolver<Maybe<ResolversTypes['InternalizationsConnection']>, ParentType, ContextType, RequireFields<QueryallInternalizationsArgs, 'orderBy'>>;
  allInternalizationsList?: Resolver<Maybe<Array<ResolversTypes['Internalization']>>, ParentType, ContextType, Partial<QueryallInternalizationsListArgs>>;
  allInvitations?: Resolver<Maybe<ResolversTypes['InvitationsConnection']>, ParentType, ContextType, RequireFields<QueryallInvitationsArgs, 'orderBy'>>;
  allInvitationsList?: Resolver<Maybe<Array<ResolversTypes['Invitation']>>, ParentType, ContextType, Partial<QueryallInvitationsListArgs>>;
  allInvoices?: Resolver<Maybe<ResolversTypes['InvoicesConnection']>, ParentType, ContextType, RequireFields<QueryallInvoicesArgs, 'orderBy'>>;
  allInvoicesList?: Resolver<Maybe<Array<ResolversTypes['Invoice']>>, ParentType, ContextType, Partial<QueryallInvoicesListArgs>>;
  allLeads?: Resolver<Maybe<ResolversTypes['LeadsConnection']>, ParentType, ContextType, RequireFields<QueryallLeadsArgs, 'orderBy'>>;
  allLeadsList?: Resolver<Maybe<Array<ResolversTypes['Lead']>>, ParentType, ContextType, Partial<QueryallLeadsListArgs>>;
  allManufacturers?: Resolver<Maybe<ResolversTypes['ManufacturersConnection']>, ParentType, ContextType, RequireFields<QueryallManufacturersArgs, 'orderBy'>>;
  allManufacturersList?: Resolver<Maybe<Array<ResolversTypes['Manufacturer']>>, ParentType, ContextType, Partial<QueryallManufacturersListArgs>>;
  allMediamanagers?: Resolver<Maybe<ResolversTypes['MediamanagersConnection']>, ParentType, ContextType, RequireFields<QueryallMediamanagersArgs, 'orderBy'>>;
  allMediamanagersList?: Resolver<Maybe<Array<ResolversTypes['Mediamanager']>>, ParentType, ContextType, Partial<QueryallMediamanagersListArgs>>;
  allMeetings?: Resolver<Maybe<ResolversTypes['MeetingsConnection']>, ParentType, ContextType, RequireFields<QueryallMeetingsArgs, 'orderBy'>>;
  allMeetingsList?: Resolver<Maybe<Array<ResolversTypes['Meeting']>>, ParentType, ContextType, Partial<QueryallMeetingsListArgs>>;
  allMessages?: Resolver<Maybe<ResolversTypes['MessagesConnection']>, ParentType, ContextType, RequireFields<QueryallMessagesArgs, 'orderBy'>>;
  allMessagesList?: Resolver<Maybe<Array<ResolversTypes['Message']>>, ParentType, ContextType, Partial<QueryallMessagesListArgs>>;
  allNewsletters?: Resolver<Maybe<ResolversTypes['NewslettersConnection']>, ParentType, ContextType, RequireFields<QueryallNewslettersArgs, 'orderBy'>>;
  allNewslettersList?: Resolver<Maybe<Array<ResolversTypes['Newsletter']>>, ParentType, ContextType, Partial<QueryallNewslettersListArgs>>;
  allOotos?: Resolver<Maybe<ResolversTypes['OotosConnection']>, ParentType, ContextType, RequireFields<QueryallOotosArgs, 'orderBy'>>;
  allOotosList?: Resolver<Maybe<Array<ResolversTypes['Ooto']>>, ParentType, ContextType, Partial<QueryallOotosListArgs>>;
  allOpportunities?: Resolver<Maybe<ResolversTypes['OpportunitiesConnection']>, ParentType, ContextType, RequireFields<QueryallOpportunitiesArgs, 'orderBy'>>;
  allOpportunitiesList?: Resolver<Maybe<Array<ResolversTypes['Opportunity']>>, ParentType, ContextType, Partial<QueryallOpportunitiesListArgs>>;
  allOrders?: Resolver<Maybe<ResolversTypes['OrdersConnection']>, ParentType, ContextType, RequireFields<QueryallOrdersArgs, 'orderBy'>>;
  allOrdersList?: Resolver<Maybe<Array<ResolversTypes['Order']>>, ParentType, ContextType, Partial<QueryallOrdersListArgs>>;
  allPages?: Resolver<Maybe<ResolversTypes['PagesConnection']>, ParentType, ContextType, RequireFields<QueryallPagesArgs, 'orderBy'>>;
  allPagesList?: Resolver<Maybe<Array<ResolversTypes['Page']>>, ParentType, ContextType, Partial<QueryallPagesListArgs>>;
  allPartners?: Resolver<Maybe<ResolversTypes['PartnersConnection']>, ParentType, ContextType, RequireFields<QueryallPartnersArgs, 'orderBy'>>;
  allPartnersList?: Resolver<Maybe<Array<ResolversTypes['Partner']>>, ParentType, ContextType, Partial<QueryallPartnersListArgs>>;
  allPayments?: Resolver<Maybe<ResolversTypes['PaymentsConnection']>, ParentType, ContextType, RequireFields<QueryallPaymentsArgs, 'orderBy'>>;
  allPaymentsList?: Resolver<Maybe<Array<ResolversTypes['Payment']>>, ParentType, ContextType, Partial<QueryallPaymentsListArgs>>;
  allPermissions?: Resolver<Maybe<ResolversTypes['PermissionsConnection']>, ParentType, ContextType, RequireFields<QueryallPermissionsArgs, 'orderBy'>>;
  allPermissionsList?: Resolver<Maybe<Array<ResolversTypes['Permission']>>, ParentType, ContextType, Partial<QueryallPermissionsListArgs>>;
  allPlugins?: Resolver<Maybe<ResolversTypes['PluginsConnection']>, ParentType, ContextType, RequireFields<QueryallPluginsArgs, 'orderBy'>>;
  allPluginsList?: Resolver<Maybe<Array<ResolversTypes['Plugin']>>, ParentType, ContextType, Partial<QueryallPluginsListArgs>>;
  allPolls?: Resolver<Maybe<ResolversTypes['PollsConnection']>, ParentType, ContextType, RequireFields<QueryallPollsArgs, 'orderBy'>>;
  allPollsList?: Resolver<Maybe<Array<ResolversTypes['Poll']>>, ParentType, ContextType, Partial<QueryallPollsListArgs>>;
  allProductTypes?: Resolver<Maybe<ResolversTypes['ProductTypesConnection']>, ParentType, ContextType, RequireFields<QueryallProductTypesArgs, 'orderBy'>>;
  allProductTypesList?: Resolver<Maybe<Array<ResolversTypes['ProductType']>>, ParentType, ContextType, Partial<QueryallProductTypesListArgs>>;
  allProducts?: Resolver<Maybe<ResolversTypes['ProductsConnection']>, ParentType, ContextType, RequireFields<QueryallProductsArgs, 'orderBy'>>;
  allProductsList?: Resolver<Maybe<Array<ResolversTypes['Product']>>, ParentType, ContextType, Partial<QueryallProductsListArgs>>;
  allProjects?: Resolver<Maybe<ResolversTypes['ProjectsConnection']>, ParentType, ContextType, RequireFields<QueryallProjectsArgs, 'orderBy'>>;
  allProjectsList?: Resolver<Maybe<Array<ResolversTypes['Project']>>, ParentType, ContextType, Partial<QueryallProjectsListArgs>>;
  allProviders?: Resolver<Maybe<ResolversTypes['ProvidersConnection']>, ParentType, ContextType, RequireFields<QueryallProvidersArgs, 'orderBy'>>;
  allProvidersList?: Resolver<Maybe<Array<ResolversTypes['Provider']>>, ParentType, ContextType, Partial<QueryallProvidersListArgs>>;
  allQuotes?: Resolver<Maybe<ResolversTypes['QuotesConnection']>, ParentType, ContextType, RequireFields<QueryallQuotesArgs, 'orderBy'>>;
  allQuotesList?: Resolver<Maybe<Array<ResolversTypes['Quote']>>, ParentType, ContextType, Partial<QueryallQuotesListArgs>>;
  allRatings?: Resolver<Maybe<ResolversTypes['RatingsConnection']>, ParentType, ContextType, RequireFields<QueryallRatingsArgs, 'orderBy'>>;
  allRatingsList?: Resolver<Maybe<Array<ResolversTypes['Rating']>>, ParentType, ContextType, Partial<QueryallRatingsListArgs>>;
  allReports?: Resolver<Maybe<ResolversTypes['ReportsConnection']>, ParentType, ContextType, RequireFields<QueryallReportsArgs, 'orderBy'>>;
  allReportsList?: Resolver<Maybe<Array<ResolversTypes['Report']>>, ParentType, ContextType, Partial<QueryallReportsListArgs>>;
  allReturns?: Resolver<Maybe<ResolversTypes['ReturnsConnection']>, ParentType, ContextType, RequireFields<QueryallReturnsArgs, 'orderBy'>>;
  allReturnsList?: Resolver<Maybe<Array<ResolversTypes['Return']>>, ParentType, ContextType, Partial<QueryallReturnsListArgs>>;
  allReviews?: Resolver<Maybe<ResolversTypes['ReviewsConnection']>, ParentType, ContextType, RequireFields<QueryallReviewsArgs, 'orderBy'>>;
  allReviewsList?: Resolver<Maybe<Array<ResolversTypes['Review']>>, ParentType, ContextType, Partial<QueryallReviewsListArgs>>;
  allRewards?: Resolver<Maybe<ResolversTypes['RewardsConnection']>, ParentType, ContextType, RequireFields<QueryallRewardsArgs, 'orderBy'>>;
  allRewardsList?: Resolver<Maybe<Array<ResolversTypes['Reward']>>, ParentType, ContextType, Partial<QueryallRewardsListArgs>>;
  allRoles?: Resolver<Maybe<ResolversTypes['RolesConnection']>, ParentType, ContextType, RequireFields<QueryallRolesArgs, 'orderBy'>>;
  allRolesList?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType, Partial<QueryallRolesListArgs>>;
  allSchedulers?: Resolver<Maybe<ResolversTypes['SchedulersConnection']>, ParentType, ContextType, RequireFields<QueryallSchedulersArgs, 'orderBy'>>;
  allSchedulersList?: Resolver<Maybe<Array<ResolversTypes['Scheduler']>>, ParentType, ContextType, Partial<QueryallSchedulersListArgs>>;
  allSegments?: Resolver<Maybe<ResolversTypes['SegmentsConnection']>, ParentType, ContextType, RequireFields<QueryallSegmentsArgs, 'orderBy'>>;
  allSegmentsList?: Resolver<Maybe<Array<ResolversTypes['Segment']>>, ParentType, ContextType, Partial<QueryallSegmentsListArgs>>;
  allSettings?: Resolver<Maybe<ResolversTypes['SettingsConnection']>, ParentType, ContextType, RequireFields<QueryallSettingsArgs, 'orderBy'>>;
  allSettingsList?: Resolver<Maybe<Array<ResolversTypes['Setting']>>, ParentType, ContextType, Partial<QueryallSettingsListArgs>>;
  allShipments?: Resolver<Maybe<ResolversTypes['ShipmentsConnection']>, ParentType, ContextType, RequireFields<QueryallShipmentsArgs, 'orderBy'>>;
  allShipmentsList?: Resolver<Maybe<Array<ResolversTypes['Shipment']>>, ParentType, ContextType, Partial<QueryallShipmentsListArgs>>;
  allSpecialDiscounts?: Resolver<Maybe<ResolversTypes['SpecialDiscountsConnection']>, ParentType, ContextType, RequireFields<QueryallSpecialDiscountsArgs, 'orderBy'>>;
  allSpecialDiscountsList?: Resolver<Maybe<Array<ResolversTypes['SpecialDiscount']>>, ParentType, ContextType, Partial<QueryallSpecialDiscountsListArgs>>;
  allStates?: Resolver<Maybe<ResolversTypes['StatesConnection']>, ParentType, ContextType, RequireFields<QueryallStatesArgs, 'orderBy'>>;
  allStatesList?: Resolver<Maybe<Array<ResolversTypes['State']>>, ParentType, ContextType, Partial<QueryallStatesListArgs>>;
  allStatistics?: Resolver<Maybe<ResolversTypes['StatisticsConnection']>, ParentType, ContextType, RequireFields<QueryallStatisticsArgs, 'orderBy'>>;
  allStatisticsList?: Resolver<Maybe<Array<ResolversTypes['Statistic']>>, ParentType, ContextType, Partial<QueryallStatisticsListArgs>>;
  allStocks?: Resolver<Maybe<ResolversTypes['StocksConnection']>, ParentType, ContextType, RequireFields<QueryallStocksArgs, 'orderBy'>>;
  allStocksList?: Resolver<Maybe<Array<ResolversTypes['Stock']>>, ParentType, ContextType, Partial<QueryallStocksListArgs>>;
  allSurveys?: Resolver<Maybe<ResolversTypes['SurveysConnection']>, ParentType, ContextType, RequireFields<QueryallSurveysArgs, 'orderBy'>>;
  allSurveysList?: Resolver<Maybe<Array<ResolversTypes['Survey']>>, ParentType, ContextType, Partial<QueryallSurveysListArgs>>;
  allTags?: Resolver<Maybe<ResolversTypes['TagsConnection']>, ParentType, ContextType, RequireFields<QueryallTagsArgs, 'orderBy'>>;
  allTagsList?: Resolver<Maybe<Array<ResolversTypes['Tag']>>, ParentType, ContextType, Partial<QueryallTagsListArgs>>;
  allTargets?: Resolver<Maybe<ResolversTypes['TargetsConnection']>, ParentType, ContextType, RequireFields<QueryallTargetsArgs, 'orderBy'>>;
  allTargetsList?: Resolver<Maybe<Array<ResolversTypes['Target']>>, ParentType, ContextType, Partial<QueryallTargetsListArgs>>;
  allTaxCategories?: Resolver<Maybe<ResolversTypes['TaxCategoriesConnection']>, ParentType, ContextType, RequireFields<QueryallTaxCategoriesArgs, 'orderBy'>>;
  allTaxCategoriesList?: Resolver<Maybe<Array<ResolversTypes['TaxCategory']>>, ParentType, ContextType, Partial<QueryallTaxCategoriesListArgs>>;
  allTaxRates?: Resolver<Maybe<ResolversTypes['TaxRatesConnection']>, ParentType, ContextType, RequireFields<QueryallTaxRatesArgs, 'orderBy'>>;
  allTaxRatesList?: Resolver<Maybe<Array<ResolversTypes['TaxRate']>>, ParentType, ContextType, Partial<QueryallTaxRatesListArgs>>;
  allTaxRules?: Resolver<Maybe<ResolversTypes['TaxRulesConnection']>, ParentType, ContextType, RequireFields<QueryallTaxRulesArgs, 'orderBy'>>;
  allTaxRulesList?: Resolver<Maybe<Array<ResolversTypes['TaxRule']>>, ParentType, ContextType, Partial<QueryallTaxRulesListArgs>>;
  allTemplates?: Resolver<Maybe<ResolversTypes['TemplatesConnection']>, ParentType, ContextType, RequireFields<QueryallTemplatesArgs, 'orderBy'>>;
  allTemplatesList?: Resolver<Maybe<Array<ResolversTypes['Template']>>, ParentType, ContextType, Partial<QueryallTemplatesListArgs>>;
  allThemes?: Resolver<Maybe<ResolversTypes['ThemesConnection']>, ParentType, ContextType, RequireFields<QueryallThemesArgs, 'orderBy'>>;
  allThemesList?: Resolver<Maybe<Array<ResolversTypes['Theme']>>, ParentType, ContextType, Partial<QueryallThemesListArgs>>;
  allTicketings?: Resolver<Maybe<ResolversTypes['TicketingsConnection']>, ParentType, ContextType, RequireFields<QueryallTicketingsArgs, 'orderBy'>>;
  allTicketingsList?: Resolver<Maybe<Array<ResolversTypes['Ticketing']>>, ParentType, ContextType, Partial<QueryallTicketingsListArgs>>;
  allTrainings?: Resolver<Maybe<ResolversTypes['TrainingsConnection']>, ParentType, ContextType, RequireFields<QueryallTrainingsArgs, 'orderBy'>>;
  allTrainingsList?: Resolver<Maybe<Array<ResolversTypes['Training']>>, ParentType, ContextType, Partial<QueryallTrainingsListArgs>>;
  allTransactions?: Resolver<Maybe<ResolversTypes['TransactionsConnection']>, ParentType, ContextType, RequireFields<QueryallTransactionsArgs, 'orderBy'>>;
  allTransactionsList?: Resolver<Maybe<Array<ResolversTypes['Transaction']>>, ParentType, ContextType, Partial<QueryallTransactionsListArgs>>;
  allUploadFiles?: Resolver<Maybe<ResolversTypes['UploadFilesConnection']>, ParentType, ContextType, RequireFields<QueryallUploadFilesArgs, 'orderBy'>>;
  allUploadFilesList?: Resolver<Maybe<Array<ResolversTypes['UploadFile']>>, ParentType, ContextType, Partial<QueryallUploadFilesListArgs>>;
  allUsers?: Resolver<Maybe<ResolversTypes['UsersConnection']>, ParentType, ContextType, RequireFields<QueryallUsersArgs, 'orderBy'>>;
  allUsersList?: Resolver<Maybe<Array<ResolversTypes['User']>>, ParentType, ContextType, Partial<QueryallUsersListArgs>>;
  allVendors?: Resolver<Maybe<ResolversTypes['VendorsConnection']>, ParentType, ContextType, RequireFields<QueryallVendorsArgs, 'orderBy'>>;
  allVendorsList?: Resolver<Maybe<Array<ResolversTypes['Vendor']>>, ParentType, ContextType, Partial<QueryallVendorsListArgs>>;
  allVisits?: Resolver<Maybe<ResolversTypes['VisitsConnection']>, ParentType, ContextType, RequireFields<QueryallVisitsArgs, 'orderBy'>>;
  allVisitsList?: Resolver<Maybe<Array<ResolversTypes['Visit']>>, ParentType, ContextType, Partial<QueryallVisitsListArgs>>;
  allWarehouses?: Resolver<Maybe<ResolversTypes['WarehousesConnection']>, ParentType, ContextType, RequireFields<QueryallWarehousesArgs, 'orderBy'>>;
  allWarehousesList?: Resolver<Maybe<Array<ResolversTypes['Warehouse']>>, ParentType, ContextType, Partial<QueryallWarehousesListArgs>>;
  allWebhooks?: Resolver<Maybe<ResolversTypes['WebhooksConnection']>, ParentType, ContextType, RequireFields<QueryallWebhooksArgs, 'orderBy'>>;
  allWebhooksList?: Resolver<Maybe<Array<ResolversTypes['Webhook']>>, ParentType, ContextType, Partial<QueryallWebhooksListArgs>>;
  allWebsites?: Resolver<Maybe<ResolversTypes['WebsitesConnection']>, ParentType, ContextType, RequireFields<QueryallWebsitesArgs, 'orderBy'>>;
  allWebsitesList?: Resolver<Maybe<Array<ResolversTypes['Website']>>, ParentType, ContextType, Partial<QueryallWebsitesListArgs>>;
  allWishlists?: Resolver<Maybe<ResolversTypes['WishlistsConnection']>, ParentType, ContextType, RequireFields<QueryallWishlistsArgs, 'orderBy'>>;
  allWishlistsList?: Resolver<Maybe<Array<ResolversTypes['Wishlist']>>, ParentType, ContextType, Partial<QueryallWishlistsListArgs>>;
  allWorkspaces?: Resolver<Maybe<ResolversTypes['WorkspacesConnection']>, ParentType, ContextType, RequireFields<QueryallWorkspacesArgs, 'orderBy'>>;
  allWorkspacesList?: Resolver<Maybe<Array<ResolversTypes['Workspace']>>, ParentType, ContextType, Partial<QueryallWorkspacesListArgs>>;
  allZones?: Resolver<Maybe<ResolversTypes['ZonesConnection']>, ParentType, ContextType, RequireFields<QueryallZonesArgs, 'orderBy'>>;
  allZonesList?: Resolver<Maybe<Array<ResolversTypes['Zone']>>, ParentType, ContextType, Partial<QueryallZonesListArgs>>;
  accountById?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType, RequireFields<QueryaccountByIdArgs, 'id'>>;
  agreementById?: Resolver<Maybe<ResolversTypes['Agreement']>, ParentType, ContextType, RequireFields<QueryagreementByIdArgs, 'id'>>;
  analyticById?: Resolver<Maybe<ResolversTypes['Analytic']>, ParentType, ContextType, RequireFields<QueryanalyticByIdArgs, 'id'>>;
  apitokenById?: Resolver<Maybe<ResolversTypes['Apitoken']>, ParentType, ContextType, RequireFields<QueryapitokenByIdArgs, 'id'>>;
  articleById?: Resolver<Maybe<ResolversTypes['Article']>, ParentType, ContextType, RequireFields<QueryarticleByIdArgs, 'id'>>;
  attributeById?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType, RequireFields<QueryattributeByIdArgs, 'id'>>;
  brandById?: Resolver<Maybe<ResolversTypes['Brand']>, ParentType, ContextType, RequireFields<QuerybrandByIdArgs, 'id'>>;
  cartPriceRuleById?: Resolver<Maybe<ResolversTypes['CartPriceRule']>, ParentType, ContextType, RequireFields<QuerycartPriceRuleByIdArgs, 'id'>>;
  caseById?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType, RequireFields<QuerycaseByIdArgs, 'id'>>;
  catalogPriceRuleById?: Resolver<Maybe<ResolversTypes['CatalogPriceRule']>, ParentType, ContextType, RequireFields<QuerycatalogPriceRuleByIdArgs, 'id'>>;
  categoryById?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType, RequireFields<QuerycategoryByIdArgs, 'id'>>;
  channelById?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<QuerychannelByIdArgs, 'id'>>;
  checklistById?: Resolver<Maybe<ResolversTypes['Checklist']>, ParentType, ContextType, RequireFields<QuerychecklistByIdArgs, 'id'>>;
  cityById?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, RequireFields<QuerycityByIdArgs, 'id'>>;
  collectionById?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType, RequireFields<QuerycollectionByIdArgs, 'id'>>;
  commentById?: Resolver<Maybe<ResolversTypes['Comment']>, ParentType, ContextType, RequireFields<QuerycommentByIdArgs, 'id'>>;
  contentTypeById?: Resolver<Maybe<ResolversTypes['ContentType']>, ParentType, ContextType, RequireFields<QuerycontentTypeByIdArgs, 'id'>>;
  contractById?: Resolver<Maybe<ResolversTypes['Contract']>, ParentType, ContextType, RequireFields<QuerycontractByIdArgs, 'id'>>;
  countryById?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, RequireFields<QuerycountryByIdArgs, 'id'>>;
  couponById?: Resolver<Maybe<ResolversTypes['Coupon']>, ParentType, ContextType, RequireFields<QuerycouponByIdArgs, 'id'>>;
  creditMemoByCreditMemoAndId?: Resolver<Maybe<ResolversTypes['CreditMemo']>, ParentType, ContextType, RequireFields<QuerycreditMemoByCreditMemoAndIdArgs, 'creditMemo' | 'id'>>;
  currencyById?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<QuerycurrencyByIdArgs, 'id'>>;
  currencyRateByImportService?: Resolver<Maybe<ResolversTypes['CurrencyRate']>, ParentType, ContextType, RequireFields<QuerycurrencyRateByImportServiceArgs, 'importService'>>;
  currencySymbolBySymbol?: Resolver<Maybe<ResolversTypes['CurrencySymbol']>, ParentType, ContextType, RequireFields<QuerycurrencySymbolBySymbolArgs, 'symbol'>>;
  customerGroupById?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType, RequireFields<QuerycustomerGroupByIdArgs, 'id'>>;
  customerById?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<QuerycustomerByIdArgs, 'id'>>;
  customizationById?: Resolver<Maybe<ResolversTypes['Customization']>, ParentType, ContextType, RequireFields<QuerycustomizationByIdArgs, 'id'>>;
  dashboardById?: Resolver<Maybe<ResolversTypes['Dashboard']>, ParentType, ContextType, RequireFields<QuerydashboardByIdArgs, 'id'>>;
  deepdiveById?: Resolver<Maybe<ResolversTypes['Deepdive']>, ParentType, ContextType, RequireFields<QuerydeepdiveByIdArgs, 'id'>>;
  digiboardById?: Resolver<Maybe<ResolversTypes['Digiboard']>, ParentType, ContextType, RequireFields<QuerydigiboardByIdArgs, 'id'>>;
  emailById?: Resolver<Maybe<ResolversTypes['Email']>, ParentType, ContextType, RequireFields<QueryemailByIdArgs, 'id'>>;
  endofshiftById?: Resolver<Maybe<ResolversTypes['Endofshift']>, ParentType, ContextType, RequireFields<QueryendofshiftByIdArgs, 'id'>>;
  eventById?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<QueryeventByIdArgs, 'id'>>;
  fullfillmentById?: Resolver<Maybe<ResolversTypes['Fullfillment']>, ParentType, ContextType, RequireFields<QueryfullfillmentByIdArgs, 'id'>>;
  giftCertificateById?: Resolver<Maybe<ResolversTypes['GiftCertificate']>, ParentType, ContextType, RequireFields<QuerygiftCertificateByIdArgs, 'id'>>;
  glossaryById?: Resolver<Maybe<ResolversTypes['Glossary']>, ParentType, ContextType, RequireFields<QueryglossaryByIdArgs, 'id'>>;
  importmById?: Resolver<Maybe<ResolversTypes['Importm']>, ParentType, ContextType, RequireFields<QueryimportmByIdArgs, 'id'>>;
  integrationById?: Resolver<Maybe<ResolversTypes['Integration']>, ParentType, ContextType, RequireFields<QueryintegrationByIdArgs, 'id'>>;
  internalizationById?: Resolver<Maybe<ResolversTypes['Internalization']>, ParentType, ContextType, RequireFields<QueryinternalizationByIdArgs, 'id'>>;
  invitationById?: Resolver<Maybe<ResolversTypes['Invitation']>, ParentType, ContextType, RequireFields<QueryinvitationByIdArgs, 'id'>>;
  invoiceById?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType, RequireFields<QueryinvoiceByIdArgs, 'id'>>;
  leadById?: Resolver<Maybe<ResolversTypes['Lead']>, ParentType, ContextType, RequireFields<QueryleadByIdArgs, 'id'>>;
  manufacturerById?: Resolver<Maybe<ResolversTypes['Manufacturer']>, ParentType, ContextType, RequireFields<QuerymanufacturerByIdArgs, 'id'>>;
  mediamanagerById?: Resolver<Maybe<ResolversTypes['Mediamanager']>, ParentType, ContextType, RequireFields<QuerymediamanagerByIdArgs, 'id'>>;
  meetingById?: Resolver<Maybe<ResolversTypes['Meeting']>, ParentType, ContextType, RequireFields<QuerymeetingByIdArgs, 'id'>>;
  messageById?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType, RequireFields<QuerymessageByIdArgs, 'id'>>;
  newsletterById?: Resolver<Maybe<ResolversTypes['Newsletter']>, ParentType, ContextType, RequireFields<QuerynewsletterByIdArgs, 'id'>>;
  ootoById?: Resolver<Maybe<ResolversTypes['Ooto']>, ParentType, ContextType, RequireFields<QueryootoByIdArgs, 'id'>>;
  opportunityById?: Resolver<Maybe<ResolversTypes['Opportunity']>, ParentType, ContextType, RequireFields<QueryopportunityByIdArgs, 'id'>>;
  orderById?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<QueryorderByIdArgs, 'id'>>;
  pageById?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType, RequireFields<QuerypageByIdArgs, 'id'>>;
  partnerById?: Resolver<Maybe<ResolversTypes['Partner']>, ParentType, ContextType, RequireFields<QuerypartnerByIdArgs, 'id'>>;
  paymentById?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType, RequireFields<QuerypaymentByIdArgs, 'id'>>;
  permissionById?: Resolver<Maybe<ResolversTypes['Permission']>, ParentType, ContextType, RequireFields<QuerypermissionByIdArgs, 'id'>>;
  pluginById?: Resolver<Maybe<ResolversTypes['Plugin']>, ParentType, ContextType, RequireFields<QuerypluginByIdArgs, 'id'>>;
  pollById?: Resolver<Maybe<ResolversTypes['Poll']>, ParentType, ContextType, RequireFields<QuerypollByIdArgs, 'id'>>;
  productTypeById?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType, RequireFields<QueryproductTypeByIdArgs, 'id'>>;
  productById?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, RequireFields<QueryproductByIdArgs, 'id'>>;
  projectById?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType, RequireFields<QueryprojectByIdArgs, 'id'>>;
  providerById?: Resolver<Maybe<ResolversTypes['Provider']>, ParentType, ContextType, RequireFields<QueryproviderByIdArgs, 'id'>>;
  quoteById?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, RequireFields<QueryquoteByIdArgs, 'id'>>;
  ratingById?: Resolver<Maybe<ResolversTypes['Rating']>, ParentType, ContextType, RequireFields<QueryratingByIdArgs, 'id'>>;
  reportById?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, RequireFields<QueryreportByIdArgs, 'id'>>;
  returnById?: Resolver<Maybe<ResolversTypes['Return']>, ParentType, ContextType, RequireFields<QueryreturnByIdArgs, 'id'>>;
  reviewById?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<QueryreviewByIdArgs, 'id'>>;
  rewardById?: Resolver<Maybe<ResolversTypes['Reward']>, ParentType, ContextType, RequireFields<QueryrewardByIdArgs, 'id'>>;
  roleById?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, RequireFields<QueryroleByIdArgs, 'id'>>;
  schedulerById?: Resolver<Maybe<ResolversTypes['Scheduler']>, ParentType, ContextType, RequireFields<QueryschedulerByIdArgs, 'id'>>;
  segmentById?: Resolver<Maybe<ResolversTypes['Segment']>, ParentType, ContextType, RequireFields<QuerysegmentByIdArgs, 'id'>>;
  settingById?: Resolver<Maybe<ResolversTypes['Setting']>, ParentType, ContextType, RequireFields<QuerysettingByIdArgs, 'id'>>;
  shipmentById?: Resolver<Maybe<ResolversTypes['Shipment']>, ParentType, ContextType, RequireFields<QueryshipmentByIdArgs, 'id'>>;
  specialDiscountById?: Resolver<Maybe<ResolversTypes['SpecialDiscount']>, ParentType, ContextType, RequireFields<QueryspecialDiscountByIdArgs, 'id'>>;
  stateById?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType, RequireFields<QuerystateByIdArgs, 'id'>>;
  statisticById?: Resolver<Maybe<ResolversTypes['Statistic']>, ParentType, ContextType, RequireFields<QuerystatisticByIdArgs, 'id'>>;
  stockById?: Resolver<Maybe<ResolversTypes['Stock']>, ParentType, ContextType, RequireFields<QuerystockByIdArgs, 'id'>>;
  surveyById?: Resolver<Maybe<ResolversTypes['Survey']>, ParentType, ContextType, RequireFields<QuerysurveyByIdArgs, 'id'>>;
  tagById?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType, RequireFields<QuerytagByIdArgs, 'id'>>;
  targetById?: Resolver<Maybe<ResolversTypes['Target']>, ParentType, ContextType, RequireFields<QuerytargetByIdArgs, 'id'>>;
  taxCategoryById?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType, RequireFields<QuerytaxCategoryByIdArgs, 'id'>>;
  taxRateById?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType, RequireFields<QuerytaxRateByIdArgs, 'id'>>;
  taxRuleById?: Resolver<Maybe<ResolversTypes['TaxRule']>, ParentType, ContextType, RequireFields<QuerytaxRuleByIdArgs, 'id'>>;
  templateById?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType, RequireFields<QuerytemplateByIdArgs, 'id'>>;
  themeById?: Resolver<Maybe<ResolversTypes['Theme']>, ParentType, ContextType, RequireFields<QuerythemeByIdArgs, 'id'>>;
  ticketingById?: Resolver<Maybe<ResolversTypes['Ticketing']>, ParentType, ContextType, RequireFields<QueryticketingByIdArgs, 'id'>>;
  trainingById?: Resolver<Maybe<ResolversTypes['Training']>, ParentType, ContextType, RequireFields<QuerytrainingByIdArgs, 'id'>>;
  transactionById?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<QuerytransactionByIdArgs, 'id'>>;
  uploadFileById?: Resolver<Maybe<ResolversTypes['UploadFile']>, ParentType, ContextType, RequireFields<QueryuploadFileByIdArgs, 'id'>>;
  userById?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryuserByIdArgs, 'id'>>;
  vendorById?: Resolver<Maybe<ResolversTypes['Vendor']>, ParentType, ContextType, RequireFields<QueryvendorByIdArgs, 'id'>>;
  visitById?: Resolver<Maybe<ResolversTypes['Visit']>, ParentType, ContextType, RequireFields<QueryvisitByIdArgs, 'id'>>;
  warehouseById?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType, RequireFields<QuerywarehouseByIdArgs, 'id'>>;
  webhookById?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType, RequireFields<QuerywebhookByIdArgs, 'id'>>;
  websiteById?: Resolver<Maybe<ResolversTypes['Website']>, ParentType, ContextType, RequireFields<QuerywebsiteByIdArgs, 'id'>>;
  wishlistById?: Resolver<Maybe<ResolversTypes['Wishlist']>, ParentType, ContextType, RequireFields<QuerywishlistByIdArgs, 'id'>>;
  workspaceById?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<QueryworkspaceByIdArgs, 'id'>>;
  zoneById?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType, RequireFields<QueryzoneByIdArgs, 'id'>>;
  account?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType, RequireFields<QueryaccountArgs, 'nodeId'>>;
  agreement?: Resolver<Maybe<ResolversTypes['Agreement']>, ParentType, ContextType, RequireFields<QueryagreementArgs, 'nodeId'>>;
  analytic?: Resolver<Maybe<ResolversTypes['Analytic']>, ParentType, ContextType, RequireFields<QueryanalyticArgs, 'nodeId'>>;
  apitoken?: Resolver<Maybe<ResolversTypes['Apitoken']>, ParentType, ContextType, RequireFields<QueryapitokenArgs, 'nodeId'>>;
  article?: Resolver<Maybe<ResolversTypes['Article']>, ParentType, ContextType, RequireFields<QueryarticleArgs, 'nodeId'>>;
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType, RequireFields<QueryattributeArgs, 'nodeId'>>;
  brand?: Resolver<Maybe<ResolversTypes['Brand']>, ParentType, ContextType, RequireFields<QuerybrandArgs, 'nodeId'>>;
  cartPriceRule?: Resolver<Maybe<ResolversTypes['CartPriceRule']>, ParentType, ContextType, RequireFields<QuerycartPriceRuleArgs, 'nodeId'>>;
  case?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType, RequireFields<QuerycaseArgs, 'nodeId'>>;
  catalogPriceRule?: Resolver<Maybe<ResolversTypes['CatalogPriceRule']>, ParentType, ContextType, RequireFields<QuerycatalogPriceRuleArgs, 'nodeId'>>;
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType, RequireFields<QuerycategoryArgs, 'nodeId'>>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<QuerychannelArgs, 'nodeId'>>;
  checklist?: Resolver<Maybe<ResolversTypes['Checklist']>, ParentType, ContextType, RequireFields<QuerychecklistArgs, 'nodeId'>>;
  city?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, RequireFields<QuerycityArgs, 'nodeId'>>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType, RequireFields<QuerycollectionArgs, 'nodeId'>>;
  comment?: Resolver<Maybe<ResolversTypes['Comment']>, ParentType, ContextType, RequireFields<QuerycommentArgs, 'nodeId'>>;
  contentType?: Resolver<Maybe<ResolversTypes['ContentType']>, ParentType, ContextType, RequireFields<QuerycontentTypeArgs, 'nodeId'>>;
  contract?: Resolver<Maybe<ResolversTypes['Contract']>, ParentType, ContextType, RequireFields<QuerycontractArgs, 'nodeId'>>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, RequireFields<QuerycountryArgs, 'nodeId'>>;
  coupon?: Resolver<Maybe<ResolversTypes['Coupon']>, ParentType, ContextType, RequireFields<QuerycouponArgs, 'nodeId'>>;
  creditMemo?: Resolver<Maybe<ResolversTypes['CreditMemo']>, ParentType, ContextType, RequireFields<QuerycreditMemoArgs, 'nodeId'>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<QuerycurrencyArgs, 'nodeId'>>;
  currencyRate?: Resolver<Maybe<ResolversTypes['CurrencyRate']>, ParentType, ContextType, RequireFields<QuerycurrencyRateArgs, 'nodeId'>>;
  currencySymbol?: Resolver<Maybe<ResolversTypes['CurrencySymbol']>, ParentType, ContextType, RequireFields<QuerycurrencySymbolArgs, 'nodeId'>>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType, RequireFields<QuerycustomerGroupArgs, 'nodeId'>>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<QuerycustomerArgs, 'nodeId'>>;
  customization?: Resolver<Maybe<ResolversTypes['Customization']>, ParentType, ContextType, RequireFields<QuerycustomizationArgs, 'nodeId'>>;
  dashboard?: Resolver<Maybe<ResolversTypes['Dashboard']>, ParentType, ContextType, RequireFields<QuerydashboardArgs, 'nodeId'>>;
  deepdive?: Resolver<Maybe<ResolversTypes['Deepdive']>, ParentType, ContextType, RequireFields<QuerydeepdiveArgs, 'nodeId'>>;
  digiboard?: Resolver<Maybe<ResolversTypes['Digiboard']>, ParentType, ContextType, RequireFields<QuerydigiboardArgs, 'nodeId'>>;
  email?: Resolver<Maybe<ResolversTypes['Email']>, ParentType, ContextType, RequireFields<QueryemailArgs, 'nodeId'>>;
  endofshift?: Resolver<Maybe<ResolversTypes['Endofshift']>, ParentType, ContextType, RequireFields<QueryendofshiftArgs, 'nodeId'>>;
  event?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<QueryeventArgs, 'nodeId'>>;
  fullfillment?: Resolver<Maybe<ResolversTypes['Fullfillment']>, ParentType, ContextType, RequireFields<QueryfullfillmentArgs, 'nodeId'>>;
  giftCertificate?: Resolver<Maybe<ResolversTypes['GiftCertificate']>, ParentType, ContextType, RequireFields<QuerygiftCertificateArgs, 'nodeId'>>;
  glossary?: Resolver<Maybe<ResolversTypes['Glossary']>, ParentType, ContextType, RequireFields<QueryglossaryArgs, 'nodeId'>>;
  importm?: Resolver<Maybe<ResolversTypes['Importm']>, ParentType, ContextType, RequireFields<QueryimportmArgs, 'nodeId'>>;
  integration?: Resolver<Maybe<ResolversTypes['Integration']>, ParentType, ContextType, RequireFields<QueryintegrationArgs, 'nodeId'>>;
  internalization?: Resolver<Maybe<ResolversTypes['Internalization']>, ParentType, ContextType, RequireFields<QueryinternalizationArgs, 'nodeId'>>;
  invitation?: Resolver<Maybe<ResolversTypes['Invitation']>, ParentType, ContextType, RequireFields<QueryinvitationArgs, 'nodeId'>>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType, RequireFields<QueryinvoiceArgs, 'nodeId'>>;
  lead?: Resolver<Maybe<ResolversTypes['Lead']>, ParentType, ContextType, RequireFields<QueryleadArgs, 'nodeId'>>;
  manufacturer?: Resolver<Maybe<ResolversTypes['Manufacturer']>, ParentType, ContextType, RequireFields<QuerymanufacturerArgs, 'nodeId'>>;
  mediamanager?: Resolver<Maybe<ResolversTypes['Mediamanager']>, ParentType, ContextType, RequireFields<QuerymediamanagerArgs, 'nodeId'>>;
  meeting?: Resolver<Maybe<ResolversTypes['Meeting']>, ParentType, ContextType, RequireFields<QuerymeetingArgs, 'nodeId'>>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType, RequireFields<QuerymessageArgs, 'nodeId'>>;
  newsletter?: Resolver<Maybe<ResolversTypes['Newsletter']>, ParentType, ContextType, RequireFields<QuerynewsletterArgs, 'nodeId'>>;
  ooto?: Resolver<Maybe<ResolversTypes['Ooto']>, ParentType, ContextType, RequireFields<QueryootoArgs, 'nodeId'>>;
  opportunity?: Resolver<Maybe<ResolversTypes['Opportunity']>, ParentType, ContextType, RequireFields<QueryopportunityArgs, 'nodeId'>>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<QueryorderArgs, 'nodeId'>>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType, RequireFields<QuerypageArgs, 'nodeId'>>;
  partner?: Resolver<Maybe<ResolversTypes['Partner']>, ParentType, ContextType, RequireFields<QuerypartnerArgs, 'nodeId'>>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType, RequireFields<QuerypaymentArgs, 'nodeId'>>;
  permission?: Resolver<Maybe<ResolversTypes['Permission']>, ParentType, ContextType, RequireFields<QuerypermissionArgs, 'nodeId'>>;
  plugin?: Resolver<Maybe<ResolversTypes['Plugin']>, ParentType, ContextType, RequireFields<QuerypluginArgs, 'nodeId'>>;
  poll?: Resolver<Maybe<ResolversTypes['Poll']>, ParentType, ContextType, RequireFields<QuerypollArgs, 'nodeId'>>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType, RequireFields<QueryproductTypeArgs, 'nodeId'>>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, RequireFields<QueryproductArgs, 'nodeId'>>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType, RequireFields<QueryprojectArgs, 'nodeId'>>;
  provider?: Resolver<Maybe<ResolversTypes['Provider']>, ParentType, ContextType, RequireFields<QueryproviderArgs, 'nodeId'>>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, RequireFields<QueryquoteArgs, 'nodeId'>>;
  rating?: Resolver<Maybe<ResolversTypes['Rating']>, ParentType, ContextType, RequireFields<QueryratingArgs, 'nodeId'>>;
  report?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, RequireFields<QueryreportArgs, 'nodeId'>>;
  return?: Resolver<Maybe<ResolversTypes['Return']>, ParentType, ContextType, RequireFields<QueryreturnArgs, 'nodeId'>>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<QueryreviewArgs, 'nodeId'>>;
  reward?: Resolver<Maybe<ResolversTypes['Reward']>, ParentType, ContextType, RequireFields<QueryrewardArgs, 'nodeId'>>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, RequireFields<QueryroleArgs, 'nodeId'>>;
  scheduler?: Resolver<Maybe<ResolversTypes['Scheduler']>, ParentType, ContextType, RequireFields<QueryschedulerArgs, 'nodeId'>>;
  segment?: Resolver<Maybe<ResolversTypes['Segment']>, ParentType, ContextType, RequireFields<QuerysegmentArgs, 'nodeId'>>;
  setting?: Resolver<Maybe<ResolversTypes['Setting']>, ParentType, ContextType, RequireFields<QuerysettingArgs, 'nodeId'>>;
  shipment?: Resolver<Maybe<ResolversTypes['Shipment']>, ParentType, ContextType, RequireFields<QueryshipmentArgs, 'nodeId'>>;
  specialDiscount?: Resolver<Maybe<ResolversTypes['SpecialDiscount']>, ParentType, ContextType, RequireFields<QueryspecialDiscountArgs, 'nodeId'>>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType, RequireFields<QuerystateArgs, 'nodeId'>>;
  statistic?: Resolver<Maybe<ResolversTypes['Statistic']>, ParentType, ContextType, RequireFields<QuerystatisticArgs, 'nodeId'>>;
  stock?: Resolver<Maybe<ResolversTypes['Stock']>, ParentType, ContextType, RequireFields<QuerystockArgs, 'nodeId'>>;
  survey?: Resolver<Maybe<ResolversTypes['Survey']>, ParentType, ContextType, RequireFields<QuerysurveyArgs, 'nodeId'>>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType, RequireFields<QuerytagArgs, 'nodeId'>>;
  target?: Resolver<Maybe<ResolversTypes['Target']>, ParentType, ContextType, RequireFields<QuerytargetArgs, 'nodeId'>>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType, RequireFields<QuerytaxCategoryArgs, 'nodeId'>>;
  taxRate?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType, RequireFields<QuerytaxRateArgs, 'nodeId'>>;
  taxRule?: Resolver<Maybe<ResolversTypes['TaxRule']>, ParentType, ContextType, RequireFields<QuerytaxRuleArgs, 'nodeId'>>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType, RequireFields<QuerytemplateArgs, 'nodeId'>>;
  theme?: Resolver<Maybe<ResolversTypes['Theme']>, ParentType, ContextType, RequireFields<QuerythemeArgs, 'nodeId'>>;
  ticketing?: Resolver<Maybe<ResolversTypes['Ticketing']>, ParentType, ContextType, RequireFields<QueryticketingArgs, 'nodeId'>>;
  training?: Resolver<Maybe<ResolversTypes['Training']>, ParentType, ContextType, RequireFields<QuerytrainingArgs, 'nodeId'>>;
  transaction?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<QuerytransactionArgs, 'nodeId'>>;
  uploadFile?: Resolver<Maybe<ResolversTypes['UploadFile']>, ParentType, ContextType, RequireFields<QueryuploadFileArgs, 'nodeId'>>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryuserArgs, 'nodeId'>>;
  vendor?: Resolver<Maybe<ResolversTypes['Vendor']>, ParentType, ContextType, RequireFields<QueryvendorArgs, 'nodeId'>>;
  visit?: Resolver<Maybe<ResolversTypes['Visit']>, ParentType, ContextType, RequireFields<QueryvisitArgs, 'nodeId'>>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType, RequireFields<QuerywarehouseArgs, 'nodeId'>>;
  webhook?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType, RequireFields<QuerywebhookArgs, 'nodeId'>>;
  website?: Resolver<Maybe<ResolversTypes['Website']>, ParentType, ContextType, RequireFields<QuerywebsiteArgs, 'nodeId'>>;
  wishlist?: Resolver<Maybe<ResolversTypes['Wishlist']>, ParentType, ContextType, RequireFields<QuerywishlistArgs, 'nodeId'>>;
  workspace?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<QueryworkspaceArgs, 'nodeId'>>;
  zone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType, RequireFields<QueryzoneArgs, 'nodeId'>>;
}>;

export type NodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Query' | 'Account' | 'Agreement' | 'Analytic' | 'Apitoken' | 'Article' | 'Attribute' | 'Brand' | 'CartPriceRule' | 'Case' | 'CatalogPriceRule' | 'Category' | 'Channel' | 'Checklist' | 'City' | 'Collection' | 'Comment' | 'ContentType' | 'Contract' | 'Country' | 'Coupon' | 'CreditMemo' | 'Currency' | 'CurrencyRate' | 'CurrencySymbol' | 'CustomerGroup' | 'Customer' | 'Customization' | 'Dashboard' | 'Deepdive' | 'Digiboard' | 'Email' | 'Endofshift' | 'Event' | 'Fullfillment' | 'GiftCertificate' | 'Glossary' | 'Importm' | 'Integration' | 'Internalization' | 'Invitation' | 'Invoice' | 'Lead' | 'Manufacturer' | 'Mediamanager' | 'Meeting' | 'Message' | 'Newsletter' | 'Ooto' | 'Opportunity' | 'Order' | 'Page' | 'Partner' | 'Payment' | 'Permission' | 'Plugin' | 'Poll' | 'ProductType' | 'Product' | 'Project' | 'Provider' | 'Quote' | 'Rating' | 'Report' | 'Return' | 'Review' | 'Reward' | 'Role' | 'Scheduler' | 'Segment' | 'Setting' | 'Shipment' | 'SpecialDiscount' | 'State' | 'Statistic' | 'Stock' | 'Survey' | 'Tag' | 'Target' | 'TaxCategory' | 'TaxRate' | 'TaxRule' | 'Template' | 'Theme' | 'Ticketing' | 'Training' | 'Transaction' | 'UploadFile' | 'User' | 'Vendor' | 'Visit' | 'Warehouse' | 'Webhook' | 'Website' | 'Wishlist' | 'Workspace' | 'Zone', ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type AccountsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AccountsConnection'] = ResolversParentTypes['AccountsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Account']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['AccountsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  officePhone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postalcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altPostalcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altCity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altCountry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  industry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  employees?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  annualRevenue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  memberOf?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  campaign?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export interface DatetimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Datetime'], any> {
  name: 'Datetime';
}

export type AccountsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AccountsEdge'] = ResolversParentTypes['AccountsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface CursorScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Cursor'], any> {
  name: 'Cursor';
}

export type PageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = ResolversObject<{
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  endCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AccountsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', OFFICE_PHONE_ASC: '[object Object]', OFFICE_PHONE_DESC: '[object Object]', FAX_ASC: '[object Object]', FAX_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', ADDRESS_ASC: '[object Object]', ADDRESS_DESC: '[object Object]', POSTALCODE_ASC: '[object Object]', POSTALCODE_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', ASSIGNED_TO_ASC: '[object Object]', ASSIGNED_TO_DESC: '[object Object]', ALT_ADDRESS_ASC: '[object Object]', ALT_ADDRESS_DESC: '[object Object]', ALT_POSTALCODE_ASC: '[object Object]', ALT_POSTALCODE_DESC: '[object Object]', ALT_CITY_ASC: '[object Object]', ALT_CITY_DESC: '[object Object]', ALT_STATE_ASC: '[object Object]', ALT_STATE_DESC: '[object Object]', ALT_COUNTRY_ASC: '[object Object]', ALT_COUNTRY_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', INDUSTRY_ASC: '[object Object]', INDUSTRY_DESC: '[object Object]', EMPLOYEES_ASC: '[object Object]', EMPLOYEES_DESC: '[object Object]', ANNUAL_REVENUE_ASC: '[object Object]', ANNUAL_REVENUE_DESC: '[object Object]', MEMBER_OF_ASC: '[object Object]', MEMBER_OF_DESC: '[object Object]', CAMPAIGN_ASC: '[object Object]', CAMPAIGN_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type AgreementsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AgreementsConnection'] = ResolversParentTypes['AgreementsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Agreement']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['AgreementsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AgreementResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Agreement'] = ResolversParentTypes['Agreement']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  referenceId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shopId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AgreementsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AgreementsEdge'] = ResolversParentTypes['AgreementsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Agreement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AgreementsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', REFERENCE_ID_ASC: '[object Object]', REFERENCE_ID_DESC: '[object Object]', CREATED_ASC: '[object Object]', CREATED_DESC: '[object Object]', UPDATED_ASC: '[object Object]', UPDATED_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', EXCERPT_ASC: '[object Object]', EXCERPT_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', USER_ID_ASC: '[object Object]', USER_ID_DESC: '[object Object]', SHOP_ID_ASC: '[object Object]', SHOP_ID_DESC: '[object Object]', MEDIAMANAGER_ASC: '[object Object]', MEDIAMANAGER_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type AnalyticsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AnalyticsConnection'] = ResolversParentTypes['AnalyticsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Analytic']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['AnalyticsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AnalyticResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Analytic'] = ResolversParentTypes['Analytic']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shareData?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  websiteName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trackingId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  propertyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultView?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  propertyHit?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trackingCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataCollection?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  dataRetention?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  searchAnalytics?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AnalyticsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AnalyticsEdge'] = ResolversParentTypes['AnalyticsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Analytic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AnalyticsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', SHARE_DATA_ASC: '[object Object]', SHARE_DATA_DESC: '[object Object]', WEBSITE_NAME_ASC: '[object Object]', WEBSITE_NAME_DESC: '[object Object]', CLIENT_ID_ASC: '[object Object]', CLIENT_ID_DESC: '[object Object]', CLIENT_SECRET_ASC: '[object Object]', CLIENT_SECRET_DESC: '[object Object]', TRACKING_ID_ASC: '[object Object]', TRACKING_ID_DESC: '[object Object]', PROPERTY_NAME_ASC: '[object Object]', PROPERTY_NAME_DESC: '[object Object]', URL_ASC: '[object Object]', URL_DESC: '[object Object]', DEFAULT_VIEW_ASC: '[object Object]', DEFAULT_VIEW_DESC: '[object Object]', CATEGORY_ASC: '[object Object]', CATEGORY_DESC: '[object Object]', PROPERTY_HIT_ASC: '[object Object]', PROPERTY_HIT_DESC: '[object Object]', TRACKING_CODE_ASC: '[object Object]', TRACKING_CODE_DESC: '[object Object]', DATA_COLLECTION_ASC: '[object Object]', DATA_COLLECTION_DESC: '[object Object]', DATA_RETENTION_ASC: '[object Object]', DATA_RETENTION_DESC: '[object Object]', SEARCH_ANALYTICS_ASC: '[object Object]', SEARCH_ANALYTICS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ApitokensConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ApitokensConnection'] = ResolversParentTypes['ApitokensConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Apitoken']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApitokensEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ApitokenResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Apitoken'] = ResolversParentTypes['Apitoken']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tokenType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  token?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ApitokensEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ApitokensEdge'] = ResolversParentTypes['ApitokensEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Apitoken']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ApitokensOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', TOKEN_TYPE_ASC: '[object Object]', TOKEN_TYPE_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', TOKEN_ASC: '[object Object]', TOKEN_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ArticlesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ArticlesConnection'] = ResolversParentTypes['ArticlesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Article']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ArticlesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ArticleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Article'] = ResolversParentTypes['Article']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ArticlesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ArticlesEdge'] = ResolversParentTypes['ArticlesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Article']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ArticlesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', EXCERPT_ASC: '[object Object]', EXCERPT_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PUBLISHED_ASC: '[object Object]', PUBLISHED_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', META_DESCRIPTION_ASC: '[object Object]', META_DESCRIPTION_DESC: '[object Object]', META_NAME_ASC: '[object Object]', META_NAME_DESC: '[object Object]', META_URL_ASC: '[object Object]', META_URL_DESC: '[object Object]', TAGS_ASC: '[object Object]', TAGS_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type AttributesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AttributesConnection'] = ResolversParentTypes['AttributesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Attribute']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['AttributesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttributeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Attribute'] = ResolversParentTypes['Attribute']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  defaultLabel?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  attributeCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filterOptions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  useSearch?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  layeredNavigation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  searchResultsLayeredNavigation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  promoRuleConditions?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  allowHtmlTagsStorefront?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  visibleCatalogPagesStorefront?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  usedProductListing?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  usedSortingProductListing?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  attributeClass?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  attributeValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  columnOptions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  facetedNavigation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaName?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  metaUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productAttributeSet?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttributesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AttributesEdge'] = ResolversParentTypes['AttributesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttributesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', DEFAULT_LABEL_ASC: '[object Object]', DEFAULT_LABEL_DESC: '[object Object]', ATTRIBUTE_CODE_ASC: '[object Object]', ATTRIBUTE_CODE_DESC: '[object Object]', FILTER_OPTIONS_ASC: '[object Object]', FILTER_OPTIONS_DESC: '[object Object]', USE_SEARCH_ASC: '[object Object]', USE_SEARCH_DESC: '[object Object]', LAYERED_NAVIGATION_ASC: '[object Object]', LAYERED_NAVIGATION_DESC: '[object Object]', SEARCH_RESULTS_LAYERED_NAVIGATION_ASC: '[object Object]', SEARCH_RESULTS_LAYERED_NAVIGATION_DESC: '[object Object]', POSITION_ASC: '[object Object]', POSITION_DESC: '[object Object]', PROMO_RULE_CONDITIONS_ASC: '[object Object]', PROMO_RULE_CONDITIONS_DESC: '[object Object]', ALLOW_HTML_TAGS_STOREFRONT_ASC: '[object Object]', ALLOW_HTML_TAGS_STOREFRONT_DESC: '[object Object]', VISIBLE_CATALOG_PAGES_STOREFRONT_ASC: '[object Object]', VISIBLE_CATALOG_PAGES_STOREFRONT_DESC: '[object Object]', USED_PRODUCT_LISTING_ASC: '[object Object]', USED_PRODUCT_LISTING_DESC: '[object Object]', USED_SORTING_PRODUCT_LISTING_ASC: '[object Object]', USED_SORTING_PRODUCT_LISTING_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', ATTRIBUTE_CLASS_ASC: '[object Object]', ATTRIBUTE_CLASS_DESC: '[object Object]', ATTRIBUTE_VALUE_ASC: '[object Object]', ATTRIBUTE_VALUE_DESC: '[object Object]', COLUMN_OPTIONS_ASC: '[object Object]', COLUMN_OPTIONS_DESC: '[object Object]', FACETED_NAVIGATION_ASC: '[object Object]', FACETED_NAVIGATION_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', META_DESCRIPTION_ASC: '[object Object]', META_DESCRIPTION_DESC: '[object Object]', META_NAME_ASC: '[object Object]', META_NAME_DESC: '[object Object]', META_URL_ASC: '[object Object]', META_URL_DESC: '[object Object]', PRODUCT_ATTRIBUTE_SET_ASC: '[object Object]', PRODUCT_ATTRIBUTE_SET_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type BrandsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BrandsConnection'] = ResolversParentTypes['BrandsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Brand']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['BrandsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BrandResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Brand'] = ResolversParentTypes['Brand']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BrandsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['BrandsEdge'] = ResolversParentTypes['BrandsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Brand']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BrandsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CODE_ASC: '[object Object]', CODE_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', PRODUCT_ASC: '[object Object]', PRODUCT_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', MEDIAMANAGER_ASC: '[object Object]', MEDIAMANAGER_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', WORKSPACES_ASC: '[object Object]', WORKSPACES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CartPriceRulesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CartPriceRulesConnection'] = ResolversParentTypes['CartPriceRulesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['CartPriceRule']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CartPriceRulesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CartPriceRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CartPriceRule'] = ResolversParentTypes['CartPriceRule']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  rule?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  active?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  coupon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  usesPerCustomer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionsApply?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionsDiscountAmount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  actionsDiscardSubsequentRules?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  actionsMaxQtyDiscountIsAppliedTo?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  actionsDiscountQtyStep?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  actionsApplyShippingAmount?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export interface BigFloatScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigFloat'], any> {
  name: 'BigFloat';
}

export type CartPriceRulesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CartPriceRulesEdge'] = ResolversParentTypes['CartPriceRulesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CartPriceRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CartPriceRulesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', RULE_ASC: '[object Object]', RULE_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', ACTIVE_ASC: '[object Object]', ACTIVE_DESC: '[object Object]', COUPON_ASC: '[object Object]', COUPON_DESC: '[object Object]', USES_PER_CUSTOMER_ASC: '[object Object]', USES_PER_CUSTOMER_DESC: '[object Object]', PRIORITY_ASC: '[object Object]', PRIORITY_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', ACTIONS_APPLY_ASC: '[object Object]', ACTIONS_APPLY_DESC: '[object Object]', ACTIONS_DISCOUNT_AMOUNT_ASC: '[object Object]', ACTIONS_DISCOUNT_AMOUNT_DESC: '[object Object]', ACTIONS_DISCARD_SUBSEQUENT_RULES_ASC: '[object Object]', ACTIONS_DISCARD_SUBSEQUENT_RULES_DESC: '[object Object]', ACTIONS_MAX_QTY_DISCOUNT_IS_APPLIED_TO_ASC: '[object Object]', ACTIONS_MAX_QTY_DISCOUNT_IS_APPLIED_TO_DESC: '[object Object]', ACTIONS_DISCOUNT_QTY_STEP_ASC: '[object Object]', ACTIONS_DISCOUNT_QTY_STEP_DESC: '[object Object]', ACTIONS_APPLY_SHIPPING_AMOUNT_ASC: '[object Object]', ACTIONS_APPLY_SHIPPING_AMOUNT_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CasesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CasesConnection'] = ResolversParentTypes['CasesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Case']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CasesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CaseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Case'] = ResolversParentTypes['Case']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  caseNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resolution?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateModified?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CasesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CasesEdge'] = ResolversParentTypes['CasesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CasesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CASE_NUMBER_ASC: '[object Object]', CASE_NUMBER_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', SUBJECT_ASC: '[object Object]', SUBJECT_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', RESOLUTION_ASC: '[object Object]', RESOLUTION_DESC: '[object Object]', PRIORITY_ASC: '[object Object]', PRIORITY_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', ACCOUNT_NAME_ASC: '[object Object]', ACCOUNT_NAME_DESC: '[object Object]', ASSIGNED_TO_ASC: '[object Object]', ASSIGNED_TO_DESC: '[object Object]', DATE_MODIFIED_ASC: '[object Object]', DATE_MODIFIED_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CatalogPriceRulesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CatalogPriceRulesConnection'] = ResolversParentTypes['CatalogPriceRulesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['CatalogPriceRule']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CatalogPriceRulesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CatalogPriceRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CatalogPriceRule'] = ResolversParentTypes['CatalogPriceRule']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  rule?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  active?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  customerGroups?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionsApply?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionsDiscountAmount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  actionsDiscardSubsequentRules?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CatalogPriceRulesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CatalogPriceRulesEdge'] = ResolversParentTypes['CatalogPriceRulesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CatalogPriceRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CatalogPriceRulesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', RULE_ASC: '[object Object]', RULE_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', ACTIVE_ASC: '[object Object]', ACTIVE_DESC: '[object Object]', CUSTOMER_GROUPS_ASC: '[object Object]', CUSTOMER_GROUPS_DESC: '[object Object]', PRIORITY_ASC: '[object Object]', PRIORITY_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', ACTIONS_APPLY_ASC: '[object Object]', ACTIONS_APPLY_DESC: '[object Object]', ACTIONS_DISCOUNT_AMOUNT_ASC: '[object Object]', ACTIONS_DISCOUNT_AMOUNT_DESC: '[object Object]', ACTIONS_DISCARD_SUBSEQUENT_RULES_ASC: '[object Object]', ACTIONS_DISCARD_SUBSEQUENT_RULES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CategoriesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CategoriesConnection'] = ResolversParentTypes['CategoriesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Category']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CategoriesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CategoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Category'] = ResolversParentTypes['Category']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  websites?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaKeywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CategoriesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CategoriesEdge'] = ResolversParentTypes['CategoriesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CategoriesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', THUMBNAIL_ASC: '[object Object]', THUMBNAIL_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', VISIBILITY_ASC: '[object Object]', VISIBILITY_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', WEBSITES_ASC: '[object Object]', WEBSITES_DESC: '[object Object]', PRODUCT_ASC: '[object Object]', PRODUCT_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', META_TITLE_ASC: '[object Object]', META_TITLE_DESC: '[object Object]', META_KEYWORDS_ASC: '[object Object]', META_KEYWORDS_DESC: '[object Object]', META_DESCRIPTION_ASC: '[object Object]', META_DESCRIPTION_DESC: '[object Object]', META_URL_ASC: '[object Object]', META_URL_DESC: '[object Object]', WORKSPACES_ASC: '[object Object]', WORKSPACES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ChannelsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChannelsConnection'] = ResolversParentTypes['ChannelsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Channel']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ChannelsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChannelResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Channel'] = ResolversParentTypes['Channel']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultLang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  includeTax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultZone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultShipping?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChannelsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChannelsEdge'] = ResolversParentTypes['ChannelsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChannelsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CODE_ASC: '[object Object]', CODE_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', CURRENCY_ASC: '[object Object]', CURRENCY_DESC: '[object Object]', DEFAULT_LANG_ASC: '[object Object]', DEFAULT_LANG_DESC: '[object Object]', INCLUDE_TAX_ASC: '[object Object]', INCLUDE_TAX_DESC: '[object Object]', DEFAULT_ZONE_ASC: '[object Object]', DEFAULT_ZONE_DESC: '[object Object]', DEFAULT_SHIPPING_ASC: '[object Object]', DEFAULT_SHIPPING_DESC: '[object Object]', CLIENT_ID_ASC: '[object Object]', CLIENT_ID_DESC: '[object Object]', CLIENT_SECRET_ASC: '[object Object]', CLIENT_SECRET_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ChecklistsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChecklistsConnection'] = ResolversParentTypes['ChecklistsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Checklist']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ChecklistsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChecklistResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Checklist'] = ResolversParentTypes['Checklist']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  regionalManager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ticket?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prodId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trainings?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  task?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChecklistsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ChecklistsEdge'] = ResolversParentTypes['ChecklistsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Checklist']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChecklistsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', USERNAME_ASC: '[object Object]', USERNAME_DESC: '[object Object]', LOCATION_ASC: '[object Object]', LOCATION_DESC: '[object Object]', REGIONAL_MANAGER_ASC: '[object Object]', REGIONAL_MANAGER_DESC: '[object Object]', MANAGER_ASC: '[object Object]', MANAGER_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', TICKET_ASC: '[object Object]', TICKET_DESC: '[object Object]', PROJECT_ASC: '[object Object]', PROJECT_DESC: '[object Object]', REGION_ASC: '[object Object]', REGION_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', TRAININGS_ASC: '[object Object]', TRAININGS_DESC: '[object Object]', TASK_ASC: '[object Object]', TASK_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CitiesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CitiesConnection'] = ResolversParentTypes['CitiesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['City']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CitiesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['City'] = ResolversParentTypes['City']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postalCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CitiesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CitiesEdge'] = ResolversParentTypes['CitiesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CitiesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', POSTAL_CODE_ASC: '[object Object]', POSTAL_CODE_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CollectionsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CollectionsConnection'] = ResolversParentTypes['CollectionsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Collection']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CollectionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CollectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Collection'] = ResolversParentTypes['Collection']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaKeywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CollectionsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CollectionsEdge'] = ResolversParentTypes['CollectionsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CollectionsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PRODUCT_ASC: '[object Object]', PRODUCT_DESC: '[object Object]', META_TITLE_ASC: '[object Object]', META_TITLE_DESC: '[object Object]', META_KEYWORDS_ASC: '[object Object]', META_KEYWORDS_DESC: '[object Object]', META_DESCRIPTION_ASC: '[object Object]', META_DESCRIPTION_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CommentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommentsConnection'] = ResolversParentTypes['CommentsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Comment']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CommentsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Comment'] = ResolversParentTypes['Comment']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  customerName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  response?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  custId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trainings?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommentsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommentsEdge'] = ResolversParentTypes['CommentsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Comment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommentsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CUSTOMER_NAME_ASC: '[object Object]', CUSTOMER_NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', RESPONSE_ASC: '[object Object]', RESPONSE_DESC: '[object Object]', PUBLISHED_ASC: '[object Object]', PUBLISHED_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', MEDIAMANAGER_ASC: '[object Object]', MEDIAMANAGER_DESC: '[object Object]', TRAININGS_ASC: '[object Object]', TRAININGS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ContentTypesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContentTypesConnection'] = ResolversParentTypes['ContentTypesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['ContentType']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ContentTypesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContentTypeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContentType'] = ResolversParentTypes['ContentType']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  number?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  json?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  link?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  time?: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  boolean?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  richText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  password?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  databaseName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface JSONScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
  name: 'Time';
}

export type ContentTypesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContentTypesEdge'] = ResolversParentTypes['ContentTypesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ContentType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContentTypesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', TEXT_ASC: '[object Object]', TEXT_DESC: '[object Object]', NUMBER_ASC: '[object Object]', NUMBER_DESC: '[object Object]', JSON_ASC: '[object Object]', JSON_DESC: '[object Object]', LINK_ASC: '[object Object]', LINK_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', UID_ASC: '[object Object]', UID_DESC: '[object Object]', DATE_ASC: '[object Object]', DATE_DESC: '[object Object]', TIME_ASC: '[object Object]', TIME_DESC: '[object Object]', TIMESTAMP_ASC: '[object Object]', TIMESTAMP_DESC: '[object Object]', BOOLEAN_ASC: '[object Object]', BOOLEAN_DESC: '[object Object]', RICH_TEXT_ASC: '[object Object]', RICH_TEXT_DESC: '[object Object]', PASSWORD_ASC: '[object Object]', PASSWORD_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', DATABASE_NAME_ASC: '[object Object]', DATABASE_NAME_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ContractsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContractsConnection'] = ResolversParentTypes['ContractsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Contract']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ContractsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContractResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Contract'] = ResolversParentTypes['Contract']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  contractTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contractValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  renewalReminder?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerSignedDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  companySignedDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contractManager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  account?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  opportunity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contractType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItems?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subtotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shipping?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingTax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grandTotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContractsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ContractsEdge'] = ResolversParentTypes['ContractsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Contract']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContractsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CONTRACT_TITLE_ASC: '[object Object]', CONTRACT_TITLE_DESC: '[object Object]', CONTRACT_VALUE_ASC: '[object Object]', CONTRACT_VALUE_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', RENEWAL_REMINDER_ASC: '[object Object]', RENEWAL_REMINDER_DESC: '[object Object]', CUSTOMER_SIGNED_DATE_ASC: '[object Object]', CUSTOMER_SIGNED_DATE_DESC: '[object Object]', COMPANY_SIGNED_DATE_ASC: '[object Object]', COMPANY_SIGNED_DATE_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', CONTRACT_MANAGER_ASC: '[object Object]', CONTRACT_MANAGER_DESC: '[object Object]', ACCOUNT_ASC: '[object Object]', ACCOUNT_DESC: '[object Object]', CONTACT_ASC: '[object Object]', CONTACT_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', OPPORTUNITY_ASC: '[object Object]', OPPORTUNITY_DESC: '[object Object]', CONTRACT_TYPE_ASC: '[object Object]', CONTRACT_TYPE_DESC: '[object Object]', CURRENCY_ASC: '[object Object]', CURRENCY_DESC: '[object Object]', LINE_ITEMS_ASC: '[object Object]', LINE_ITEMS_DESC: '[object Object]', TOTAL_ASC: '[object Object]', TOTAL_DESC: '[object Object]', DISCOUNT_ASC: '[object Object]', DISCOUNT_DESC: '[object Object]', SUBTOTAL_ASC: '[object Object]', SUBTOTAL_DESC: '[object Object]', SHIPPING_ASC: '[object Object]', SHIPPING_DESC: '[object Object]', SHIPPING_TAX_ASC: '[object Object]', SHIPPING_TAX_DESC: '[object Object]', TAX_ASC: '[object Object]', TAX_DESC: '[object Object]', GRAND_TOTAL_ASC: '[object Object]', GRAND_TOTAL_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CountriesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CountriesConnection'] = ResolversParentTypes['CountriesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Country']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CountriesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CountryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Country'] = ResolversParentTypes['Country']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trainings?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CountriesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CountriesEdge'] = ResolversParentTypes['CountriesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CountriesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', REGION_ASC: '[object Object]', REGION_DESC: '[object Object]', TRAININGS_ASC: '[object Object]', TRAININGS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CouponsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CouponsConnection'] = ResolversParentTypes['CouponsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Coupon']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CouponsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CouponResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Coupon'] = ResolversParentTypes['Coupon']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  expiration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  productsCouponsToproducts?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CouponsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CouponsEdge'] = ResolversParentTypes['CouponsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Coupon']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CouponsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', EXCERPT_ASC: '[object Object]', EXCERPT_DESC: '[object Object]', DISCOUNT_ASC: '[object Object]', DISCOUNT_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PUBLISHED_ASC: '[object Object]', PUBLISHED_DESC: '[object Object]', EXPIRATION_ASC: '[object Object]', EXPIRATION_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', PRODUCTS_COUPONS_TOPRODUCTS_ASC: '[object Object]', PRODUCTS_COUPONS_TOPRODUCTS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CreditMemosConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreditMemosConnection'] = ResolversParentTypes['CreditMemosConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['CreditMemo']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CreditMemosEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreditMemoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreditMemo'] = ResolversParentTypes['CreditMemo']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  creditMemo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  orderNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  billToName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refunded?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  action?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  custId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreditMemosEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreditMemosEdge'] = ResolversParentTypes['CreditMemosEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CreditMemo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreditMemosOrderByResolvers = { NATURAL: '[object Object]', CREDIT_MEMO_ASC: '[object Object]', CREDIT_MEMO_DESC: '[object Object]', ORDER_NUMBER_ASC: '[object Object]', ORDER_NUMBER_DESC: '[object Object]', CREATED_ASC: '[object Object]', CREATED_DESC: '[object Object]', BILL_TO_NAME_ASC: '[object Object]', BILL_TO_NAME_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', REFUNDED_ASC: '[object Object]', REFUNDED_DESC: '[object Object]', ACTION_ASC: '[object Object]', ACTION_DESC: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CurrenciesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrenciesConnection'] = ResolversParentTypes['CurrenciesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Currency']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CurrenciesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrencyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Currency'] = ResolversParentTypes['Currency']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrenciesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrenciesEdge'] = ResolversParentTypes['CurrenciesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrenciesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CODE_ASC: '[object Object]', CODE_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', REGION_ASC: '[object Object]', REGION_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CurrencyRatesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrencyRatesConnection'] = ResolversParentTypes['CurrencyRatesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['CurrencyRate']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CurrencyRatesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrencyRateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrencyRate'] = ResolversParentTypes['CurrencyRate']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importService?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  usd?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrencyRatesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrencyRatesEdge'] = ResolversParentTypes['CurrencyRatesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CurrencyRate']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrencyRatesOrderByResolvers = { NATURAL: '[object Object]', IMPORT_SERVICE_ASC: '[object Object]', IMPORT_SERVICE_DESC: '[object Object]', USD_ASC: '[object Object]', USD_DESC: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CurrencySymbolsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrencySymbolsConnection'] = ResolversParentTypes['CurrencySymbolsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['CurrencySymbol']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CurrencySymbolsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrencySymbolResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrencySymbol'] = ResolversParentTypes['CurrencySymbol']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  useStandard?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrencySymbolsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CurrencySymbolsEdge'] = ResolversParentTypes['CurrencySymbolsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CurrencySymbol']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CurrencySymbolsOrderByResolvers = { NATURAL: '[object Object]', SYMBOL_ASC: '[object Object]', SYMBOL_DESC: '[object Object]', USE_STANDARD_ASC: '[object Object]', USE_STANDARD_DESC: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CustomerGroupsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CustomerGroupsConnection'] = ResolversParentTypes['CustomerGroupsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['CustomerGroup']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CustomerGroupsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomerGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CustomerGroup'] = ResolversParentTypes['CustomerGroup']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxClass?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coverPhoto?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomerGroupsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CustomerGroupsEdge'] = ResolversParentTypes['CustomerGroupsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomerGroupsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', TAX_CLASS_ASC: '[object Object]', TAX_CLASS_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', COVER_PHOTO_ASC: '[object Object]', COVER_PHOTO_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CustomersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CustomersConnection'] = ResolversParentTypes['CustomersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Customer']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CustomersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Customer'] = ResolversParentTypes['Customer']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  namePrefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  middleName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  phone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  zipcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nameSuffix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  websites?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerSince?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  confirmedEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateOfBirth?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxVatNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  addressTwo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  password?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comments?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  creditMemos?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerPayment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emails?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  newsletterSubscribers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orders?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projects?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quotes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returns?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CustomersEdge'] = ResolversParentTypes['CustomersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', THUMBNAIL_ASC: '[object Object]', THUMBNAIL_DESC: '[object Object]', NAME_PREFIX_ASC: '[object Object]', NAME_PREFIX_DESC: '[object Object]', FIRST_NAME_ASC: '[object Object]', FIRST_NAME_DESC: '[object Object]', MIDDLE_NAME_ASC: '[object Object]', MIDDLE_NAME_DESC: '[object Object]', LAST_NAME_ASC: '[object Object]', LAST_NAME_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', CUSTOMER_GROUP_ASC: '[object Object]', CUSTOMER_GROUP_DESC: '[object Object]', PHONE_ASC: '[object Object]', PHONE_DESC: '[object Object]', ZIPCODE_ASC: '[object Object]', ZIPCODE_DESC: '[object Object]', NAME_SUFFIX_ASC: '[object Object]', NAME_SUFFIX_DESC: '[object Object]', WEBSITES_ASC: '[object Object]', WEBSITES_DESC: '[object Object]', PRODUCT_ASC: '[object Object]', PRODUCT_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', CUSTOMER_SINCE_ASC: '[object Object]', CUSTOMER_SINCE_DESC: '[object Object]', CONFIRMED_EMAIL_ASC: '[object Object]', CONFIRMED_EMAIL_DESC: '[object Object]', DATE_OF_BIRTH_ASC: '[object Object]', DATE_OF_BIRTH_DESC: '[object Object]', TAX_VAT_NUMBER_ASC: '[object Object]', TAX_VAT_NUMBER_DESC: '[object Object]', GENDER_ASC: '[object Object]', GENDER_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', SHORT_DESCRIPTION_ASC: '[object Object]', SHORT_DESCRIPTION_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', ADDRESS_ASC: '[object Object]', ADDRESS_DESC: '[object Object]', ADDRESS_TWO_ASC: '[object Object]', ADDRESS_TWO_DESC: '[object Object]', PAYMENT_TYPE_ASC: '[object Object]', PAYMENT_TYPE_DESC: '[object Object]', USERNAME_ASC: '[object Object]', USERNAME_DESC: '[object Object]', PASSWORD_ASC: '[object Object]', PASSWORD_DESC: '[object Object]', COMMENTS_ASC: '[object Object]', COMMENTS_DESC: '[object Object]', CREDIT_MEMOS_ASC: '[object Object]', CREDIT_MEMOS_DESC: '[object Object]', CUSTOMER_PAYMENT_ASC: '[object Object]', CUSTOMER_PAYMENT_DESC: '[object Object]', EMAILS_ASC: '[object Object]', EMAILS_DESC: '[object Object]', MEDIAMANAGER_ASC: '[object Object]', MEDIAMANAGER_DESC: '[object Object]', MESSAGES_ASC: '[object Object]', MESSAGES_DESC: '[object Object]', NEWSLETTER_SUBSCRIBERS_ASC: '[object Object]', NEWSLETTER_SUBSCRIBERS_DESC: '[object Object]', ORDERS_ASC: '[object Object]', ORDERS_DESC: '[object Object]', PROJECTS_ASC: '[object Object]', PROJECTS_DESC: '[object Object]', QUOTES_ASC: '[object Object]', QUOTES_DESC: '[object Object]', RETURNS_ASC: '[object Object]', RETURNS_DESC: '[object Object]', WORKSPACES_ASC: '[object Object]', WORKSPACES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type CustomizationsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CustomizationsConnection'] = ResolversParentTypes['CustomizationsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Customization']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['CustomizationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomizationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Customization'] = ResolversParentTypes['Customization']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  siteName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  navLink?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  banner?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  footerLink?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  siteUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  allowSignup?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomizationsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CustomizationsEdge'] = ResolversParentTypes['CustomizationsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Customization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CustomizationsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', SITE_NAME_ASC: '[object Object]', SITE_NAME_DESC: '[object Object]', NAV_LINK_ASC: '[object Object]', NAV_LINK_DESC: '[object Object]', NOTIFICATION_ASC: '[object Object]', NOTIFICATION_DESC: '[object Object]', BANNER_ASC: '[object Object]', BANNER_DESC: '[object Object]', FOOTER_LINK_ASC: '[object Object]', FOOTER_LINK_DESC: '[object Object]', ANNOUNCEMENT_ASC: '[object Object]', ANNOUNCEMENT_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', SITE_URL_ASC: '[object Object]', SITE_URL_DESC: '[object Object]', ALLOW_SIGNUP_ASC: '[object Object]', ALLOW_SIGNUP_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type DashboardsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DashboardsConnection'] = ResolversParentTypes['DashboardsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Dashboard']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['DashboardsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DashboardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Dashboard'] = ResolversParentTypes['Dashboard']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  privacy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  task?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tasks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projects?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tickets?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  checklists?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visits?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sales?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DashboardsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DashboardsEdge'] = ResolversParentTypes['DashboardsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Dashboard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DashboardsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', CLIENT_ID_ASC: '[object Object]', CLIENT_ID_DESC: '[object Object]', CLIENT_SECRET_ASC: '[object Object]', CLIENT_SECRET_DESC: '[object Object]', PRIVACY_ASC: '[object Object]', PRIVACY_DESC: '[object Object]', CATEGORY_ASC: '[object Object]', CATEGORY_DESC: '[object Object]', URL_ASC: '[object Object]', URL_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', TASK_ASC: '[object Object]', TASK_DESC: '[object Object]', REPORTS_ASC: '[object Object]', REPORTS_DESC: '[object Object]', TASKS_ASC: '[object Object]', TASKS_DESC: '[object Object]', PROJECTS_ASC: '[object Object]', PROJECTS_DESC: '[object Object]', TICKETS_ASC: '[object Object]', TICKETS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', CHECKLISTS_ASC: '[object Object]', CHECKLISTS_DESC: '[object Object]', VISITS_ASC: '[object Object]', VISITS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', SALES_ASC: '[object Object]', SALES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type DeepdivesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeepdivesConnection'] = ResolversParentTypes['DeepdivesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Deepdive']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['DeepdivesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeepdiveResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Deepdive'] = ResolversParentTypes['Deepdive']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  attendees?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  whid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeepdivesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeepdivesEdge'] = ResolversParentTypes['DeepdivesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Deepdive']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeepdivesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', ATTENDEES_ASC: '[object Object]', ATTENDEES_DESC: '[object Object]', LOGIN_ASC: '[object Object]', LOGIN_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', WHID_ASC: '[object Object]', WHID_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type DigiboardsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DigiboardsConnection'] = ResolversParentTypes['DigiboardsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Digiboard']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['DigiboardsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DigiboardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Digiboard'] = ResolversParentTypes['Digiboard']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  board?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  student?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  course?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DigiboardsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DigiboardsEdge'] = ResolversParentTypes['DigiboardsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Digiboard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DigiboardsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', BOARD_ASC: '[object Object]', BOARD_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', STUDENT_ASC: '[object Object]', STUDENT_DESC: '[object Object]', COURSE_ASC: '[object Object]', COURSE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type EmailsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EmailsConnection'] = ResolversParentTypes['EmailsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Email']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['EmailsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EmailResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Email'] = ResolversParentTypes['Email']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  bcc?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cc?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  staffId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EmailsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EmailsEdge'] = ResolversParentTypes['EmailsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Email']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EmailsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', SUBJECT_ASC: '[object Object]', SUBJECT_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', BCC_ASC: '[object Object]', BCC_DESC: '[object Object]', CC_ASC: '[object Object]', CC_DESC: '[object Object]', FROM_ASC: '[object Object]', FROM_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', STAFF_ID_ASC: '[object Object]', STAFF_ID_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type EndofshiftsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EndofshiftsConnection'] = ResolversParentTypes['EndofshiftsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Endofshift']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['EndofshiftsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EndofshiftResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Endofshift'] = ResolversParentTypes['Endofshift']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mcms?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nextShift?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projects?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tickets?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  whid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EndofshiftsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EndofshiftsEdge'] = ResolversParentTypes['EndofshiftsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Endofshift']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EndofshiftsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', LOGIN_ASC: '[object Object]', LOGIN_DESC: '[object Object]', MCMS_ASC: '[object Object]', MCMS_DESC: '[object Object]', NEXT_SHIFT_ASC: '[object Object]', NEXT_SHIFT_DESC: '[object Object]', PROJECTS_ASC: '[object Object]', PROJECTS_DESC: '[object Object]', TICKETS_ASC: '[object Object]', TICKETS_DESC: '[object Object]', WHID_ASC: '[object Object]', WHID_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type EventsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsConnection'] = ResolversParentTypes['EventsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Event']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['EventsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Event'] = ResolversParentTypes['Event']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tickets?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  start?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  end?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postalcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['EventsEdge'] = ResolversParentTypes['EventsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', TICKETS_ASC: '[object Object]', TICKETS_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', START_ASC: '[object Object]', START_DESC: '[object Object]', END_ASC: '[object Object]', END_DESC: '[object Object]', CATEGORY_ASC: '[object Object]', CATEGORY_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', POSTALCODE_ASC: '[object Object]', POSTALCODE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type FullfillmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FullfillmentsConnection'] = ResolversParentTypes['FullfillmentsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Fullfillment']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['FullfillmentsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FullfillmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Fullfillment'] = ResolversParentTypes['Fullfillment']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingZones?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  company?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  addressTwo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  zipcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryArea?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  phone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pickup?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stock?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FullfillmentsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['FullfillmentsEdge'] = ResolversParentTypes['FullfillmentsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Fullfillment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FullfillmentsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', SHIPPING_ZONES_ASC: '[object Object]', SHIPPING_ZONES_DESC: '[object Object]', COMPANY_ASC: '[object Object]', COMPANY_DESC: '[object Object]', ADDRESS_ASC: '[object Object]', ADDRESS_DESC: '[object Object]', ADDRESS_TWO_ASC: '[object Object]', ADDRESS_TWO_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', ZIPCODE_ASC: '[object Object]', ZIPCODE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', COUNTRY_AREA_ASC: '[object Object]', COUNTRY_AREA_DESC: '[object Object]', PHONE_ASC: '[object Object]', PHONE_DESC: '[object Object]', PICKUP_ASC: '[object Object]', PICKUP_DESC: '[object Object]', STOCK_ASC: '[object Object]', STOCK_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type GiftCertificatesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GiftCertificatesConnection'] = ResolversParentTypes['GiftCertificatesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['GiftCertificate']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['GiftCertificatesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GiftCertificateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GiftCertificate'] = ResolversParentTypes['GiftCertificate']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  specialOffers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rewards?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coupons?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GiftCertificatesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GiftCertificatesEdge'] = ResolversParentTypes['GiftCertificatesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['GiftCertificate']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GiftCertificatesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', EXCERPT_ASC: '[object Object]', EXCERPT_DESC: '[object Object]', DISCOUNT_ASC: '[object Object]', DISCOUNT_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PUBLISHED_ASC: '[object Object]', PUBLISHED_DESC: '[object Object]', SPECIAL_OFFERS_ASC: '[object Object]', SPECIAL_OFFERS_DESC: '[object Object]', REWARDS_ASC: '[object Object]', REWARDS_DESC: '[object Object]', COUPONS_ASC: '[object Object]', COUPONS_DESC: '[object Object]', EXPIRATION_ASC: '[object Object]', EXPIRATION_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type GlossariesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GlossariesConnection'] = ResolversParentTypes['GlossariesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Glossary']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['GlossariesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GlossaryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Glossary'] = ResolversParentTypes['Glossary']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GlossariesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['GlossariesEdge'] = ResolversParentTypes['GlossariesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Glossary']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GlossariesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PUBLISHED_ASC: '[object Object]', PUBLISHED_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ImportmsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ImportmsConnection'] = ResolversParentTypes['ImportmsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Importm']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ImportmsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ImportmResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Importm'] = ResolversParentTypes['Importm']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ImportmsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ImportmsEdge'] = ResolversParentTypes['ImportmsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Importm']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ImportmsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', FILE_ASC: '[object Object]', FILE_DESC: '[object Object]', URL_ASC: '[object Object]', URL_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type IntegrationsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IntegrationsConnection'] = ResolversParentTypes['IntegrationsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Integration']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['IntegrationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IntegrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Integration'] = ResolversParentTypes['Integration']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IntegrationsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['IntegrationsEdge'] = ResolversParentTypes['IntegrationsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Integration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IntegrationsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', LOCATION_ASC: '[object Object]', LOCATION_DESC: '[object Object]', CATEGORY_ASC: '[object Object]', CATEGORY_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type InternalizationsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InternalizationsConnection'] = ResolversParentTypes['InternalizationsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Internalization']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['InternalizationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InternalizationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Internalization'] = ResolversParentTypes['Internalization']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InternalizationsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InternalizationsEdge'] = ResolversParentTypes['InternalizationsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Internalization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InternalizationsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', REGION_ASC: '[object Object]', REGION_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', DEFAULT_ASC: '[object Object]', DEFAULT_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type InvitationsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InvitationsConnection'] = ResolversParentTypes['InvitationsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Invitation']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['InvitationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Invitation'] = ResolversParentTypes['Invitation']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  invoiceDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grandTotalPurchased?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentMethod?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InvitationsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InvitationsEdge'] = ResolversParentTypes['InvitationsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Invitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InvitationsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', INVOICE_DATE_ASC: '[object Object]', INVOICE_DATE_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', BILLING_ADDRESS_ASC: '[object Object]', BILLING_ADDRESS_DESC: '[object Object]', SHIPPING_ADDRESS_ASC: '[object Object]', SHIPPING_ADDRESS_DESC: '[object Object]', ORDER_NUMBER_ASC: '[object Object]', ORDER_NUMBER_DESC: '[object Object]', GRAND_TOTAL_PURCHASED_ASC: '[object Object]', GRAND_TOTAL_PURCHASED_DESC: '[object Object]', PAYMENT_METHOD_ASC: '[object Object]', PAYMENT_METHOD_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type InvoicesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InvoicesConnection'] = ResolversParentTypes['InvoicesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Invoice']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['InvoicesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InvoiceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Invoice'] = ResolversParentTypes['Invoice']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoice?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  orderNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  invoiceDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  billToName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  billingAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grandTotalBase?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grandTotalPurchased?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentMethod?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingInformation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subtotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingAndHandling?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InvoicesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['InvoicesEdge'] = ResolversParentTypes['InvoicesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InvoicesOrderByResolvers = { NATURAL: '[object Object]', INVOICE_ASC: '[object Object]', INVOICE_DESC: '[object Object]', ORDER_NUMBER_ASC: '[object Object]', ORDER_NUMBER_DESC: '[object Object]', INVOICE_DATE_ASC: '[object Object]', INVOICE_DATE_DESC: '[object Object]', BILL_TO_NAME_ASC: '[object Object]', BILL_TO_NAME_DESC: '[object Object]', BILLING_ADDRESS_ASC: '[object Object]', BILLING_ADDRESS_DESC: '[object Object]', GRAND_TOTAL_BASE_ASC: '[object Object]', GRAND_TOTAL_BASE_DESC: '[object Object]', GRAND_TOTAL_PURCHASED_ASC: '[object Object]', GRAND_TOTAL_PURCHASED_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', SHIPPING_ADDRESS_ASC: '[object Object]', SHIPPING_ADDRESS_DESC: '[object Object]', CUSTOMER_NAME_ASC: '[object Object]', CUSTOMER_NAME_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', CUSTOMER_GROUP_ASC: '[object Object]', CUSTOMER_GROUP_DESC: '[object Object]', PAYMENT_METHOD_ASC: '[object Object]', PAYMENT_METHOD_DESC: '[object Object]', SHIPPING_INFORMATION_ASC: '[object Object]', SHIPPING_INFORMATION_DESC: '[object Object]', SUBTOTAL_ASC: '[object Object]', SUBTOTAL_DESC: '[object Object]', SHIPPING_AND_HANDLING_ASC: '[object Object]', SHIPPING_AND_HANDLING_DESC: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type LeadsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LeadsConnection'] = ResolversParentTypes['LeadsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Lead']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['LeadsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LeadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Lead'] = ResolversParentTypes['Lead']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  department?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postalcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mobile?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jobTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altPostalcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altCity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altCountry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  officePhone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  statusDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  opportunityAmount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  campaign?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  leadSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  leadSourceDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  referredBy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LeadsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LeadsEdge'] = ResolversParentTypes['LeadsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Lead']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LeadsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', PREFIX_ASC: '[object Object]', PREFIX_DESC: '[object Object]', FIRST_NAME_ASC: '[object Object]', FIRST_NAME_DESC: '[object Object]', LAST_NAME_ASC: '[object Object]', LAST_NAME_DESC: '[object Object]', DEPARTMENT_ASC: '[object Object]', DEPARTMENT_DESC: '[object Object]', ACCOUNT_NAME_ASC: '[object Object]', ACCOUNT_NAME_DESC: '[object Object]', ADDRESS_ASC: '[object Object]', ADDRESS_DESC: '[object Object]', POSTALCODE_ASC: '[object Object]', POSTALCODE_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', FAX_ASC: '[object Object]', FAX_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', MOBILE_ASC: '[object Object]', MOBILE_DESC: '[object Object]', JOB_TITLE_ASC: '[object Object]', JOB_TITLE_DESC: '[object Object]', ALT_ADDRESS_ASC: '[object Object]', ALT_ADDRESS_DESC: '[object Object]', ALT_POSTALCODE_ASC: '[object Object]', ALT_POSTALCODE_DESC: '[object Object]', ALT_CITY_ASC: '[object Object]', ALT_CITY_DESC: '[object Object]', ALT_STATE_ASC: '[object Object]', ALT_STATE_DESC: '[object Object]', ALT_COUNTRY_ASC: '[object Object]', ALT_COUNTRY_DESC: '[object Object]', OFFICE_PHONE_ASC: '[object Object]', OFFICE_PHONE_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', STATUS_DESCRIPTION_ASC: '[object Object]', STATUS_DESCRIPTION_DESC: '[object Object]', OPPORTUNITY_AMOUNT_ASC: '[object Object]', OPPORTUNITY_AMOUNT_DESC: '[object Object]', CAMPAIGN_ASC: '[object Object]', CAMPAIGN_DESC: '[object Object]', LEAD_SOURCE_ASC: '[object Object]', LEAD_SOURCE_DESC: '[object Object]', LEAD_SOURCE_DESCRIPTION_ASC: '[object Object]', LEAD_SOURCE_DESCRIPTION_DESC: '[object Object]', REFERRED_BY_ASC: '[object Object]', REFERRED_BY_DESC: '[object Object]', CUSTOMER_NAME_ASC: '[object Object]', CUSTOMER_NAME_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ManufacturersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManufacturersConnection'] = ResolversParentTypes['ManufacturersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Manufacturer']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ManufacturersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ManufacturerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Manufacturer'] = ResolversParentTypes['Manufacturer']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ManufacturersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ManufacturersEdge'] = ResolversParentTypes['ManufacturersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Manufacturer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ManufacturersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CODE_ASC: '[object Object]', CODE_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', PRODUCT_ASC: '[object Object]', PRODUCT_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type MediamanagersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MediamanagersConnection'] = ResolversParentTypes['MediamanagersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Mediamanager']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['MediamanagersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MediamanagerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Mediamanager'] = ResolversParentTypes['Mediamanager']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  keywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brands?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expirationDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  copyright?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dimensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  contentType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  versions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  watermarkName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  watermarkDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  watermarkMedia?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  agreements?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  albums?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  workspace?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taskName?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  taskDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taskType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  members?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  agreementsAgreementsTomediamanager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brandsBrandsTomediamanager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comments?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productsMediamanagerToproducts?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tasks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MediamanagersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MediamanagersEdge'] = ResolversParentTypes['MediamanagersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Mediamanager']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MediamanagersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', KEYWORDS_ASC: '[object Object]', KEYWORDS_DESC: '[object Object]', TAGS_ASC: '[object Object]', TAGS_DESC: '[object Object]', BRANDS_ASC: '[object Object]', BRANDS_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', EXPIRATION_DATE_ASC: '[object Object]', EXPIRATION_DATE_DESC: '[object Object]', COPYRIGHT_ASC: '[object Object]', COPYRIGHT_DESC: '[object Object]', DIMENSIONS_ASC: '[object Object]', DIMENSIONS_DESC: '[object Object]', AUTHOR_ASC: '[object Object]', AUTHOR_DESC: '[object Object]', CONTENT_TYPE_ASC: '[object Object]', CONTENT_TYPE_DESC: '[object Object]', VERSIONS_ASC: '[object Object]', VERSIONS_DESC: '[object Object]', WATERMARK_NAME_ASC: '[object Object]', WATERMARK_NAME_DESC: '[object Object]', WATERMARK_DESCRIPTION_ASC: '[object Object]', WATERMARK_DESCRIPTION_DESC: '[object Object]', WATERMARK_MEDIA_ASC: '[object Object]', WATERMARK_MEDIA_DESC: '[object Object]', AGREEMENTS_ASC: '[object Object]', AGREEMENTS_DESC: '[object Object]', ALBUMS_ASC: '[object Object]', ALBUMS_DESC: '[object Object]', COMMENT_ASC: '[object Object]', COMMENT_DESC: '[object Object]', WORKSPACE_ASC: '[object Object]', WORKSPACE_DESC: '[object Object]', TASK_NAME_ASC: '[object Object]', TASK_NAME_DESC: '[object Object]', TASK_DESCRIPTION_ASC: '[object Object]', TASK_DESCRIPTION_DESC: '[object Object]', TASK_TYPE_ASC: '[object Object]', TASK_TYPE_DESC: '[object Object]', MEMBERS_ASC: '[object Object]', MEMBERS_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', AGREEMENTS_AGREEMENTS_TOMEDIAMANAGER_ASC: '[object Object]', AGREEMENTS_AGREEMENTS_TOMEDIAMANAGER_DESC: '[object Object]', BRANDS_BRANDS_TOMEDIAMANAGER_ASC: '[object Object]', BRANDS_BRANDS_TOMEDIAMANAGER_DESC: '[object Object]', COMMENTS_ASC: '[object Object]', COMMENTS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', PRODUCTS_MEDIAMANAGER_TOPRODUCTS_ASC: '[object Object]', PRODUCTS_MEDIAMANAGER_TOPRODUCTS_DESC: '[object Object]', TASKS_ASC: '[object Object]', TASKS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type MeetingsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MeetingsConnection'] = ResolversParentTypes['MeetingsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Meeting']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['MeetingsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MeetingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Meeting'] = ResolversParentTypes['Meeting']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  duration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  relatedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reminders?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitees?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scheduling?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MeetingsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MeetingsEdge'] = ResolversParentTypes['MeetingsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Meeting']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MeetingsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', SUBJECT_ASC: '[object Object]', SUBJECT_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', DURATION_ASC: '[object Object]', DURATION_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', RELATED_TO_ASC: '[object Object]', RELATED_TO_DESC: '[object Object]', REMINDERS_ASC: '[object Object]', REMINDERS_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', ASSIGNED_TO_ASC: '[object Object]', ASSIGNED_TO_DESC: '[object Object]', INVITEES_ASC: '[object Object]', INVITEES_DESC: '[object Object]', SCHEDULING_ASC: '[object Object]', SCHEDULING_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type MessagesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MessagesConnection'] = ResolversParentTypes['MessagesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Message']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['MessagesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MessageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Message'] = ResolversParentTypes['Message']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  staffId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MessagesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['MessagesEdge'] = ResolversParentTypes['MessagesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MessagesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', FROM_ASC: '[object Object]', FROM_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', SUBJECT_ASC: '[object Object]', SUBJECT_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', SENDER_ASC: '[object Object]', SENDER_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', STAFF_ID_ASC: '[object Object]', STAFF_ID_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type NewslettersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NewslettersConnection'] = ResolversParentTypes['NewslettersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Newsletter']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['NewslettersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NewsletterResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Newsletter'] = ResolversParentTypes['Newsletter']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  customerFirstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerLastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  store?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  websites?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  custId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NewslettersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NewslettersEdge'] = ResolversParentTypes['NewslettersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Newsletter']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NewslettersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', CUSTOMER_FIRST_NAME_ASC: '[object Object]', CUSTOMER_FIRST_NAME_DESC: '[object Object]', CUSTOMER_LAST_NAME_ASC: '[object Object]', CUSTOMER_LAST_NAME_DESC: '[object Object]', STORE_ASC: '[object Object]', STORE_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', WEBSITES_ASC: '[object Object]', WEBSITES_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type OotosConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OotosConnection'] = ResolversParentTypes['OotosConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Ooto']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['OotosEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OotoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Ooto'] = ResolversParentTypes['Ooto']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  usingTime?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OotosEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OotosEdge'] = ResolversParentTypes['OotosEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Ooto']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OotosOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', LOGIN_ASC: '[object Object]', LOGIN_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', NOTE_ASC: '[object Object]', NOTE_DESC: '[object Object]', USING_TIME_ASC: '[object Object]', USING_TIME_DESC: '[object Object]', LOCATION_ASC: '[object Object]', LOCATION_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type OpportunitiesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OpportunitiesConnection'] = ResolversParentTypes['OpportunitiesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Opportunity']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['OpportunitiesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OpportunityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Opportunity'] = ResolversParentTypes['Opportunity']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  amount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  salesStage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  probability?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nextStep?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  leadSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  campaign?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expectedCloseDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OpportunitiesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OpportunitiesEdge'] = ResolversParentTypes['OpportunitiesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Opportunity']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OpportunitiesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', AMOUNT_ASC: '[object Object]', AMOUNT_DESC: '[object Object]', SALES_STAGE_ASC: '[object Object]', SALES_STAGE_DESC: '[object Object]', CURRENCY_ASC: '[object Object]', CURRENCY_DESC: '[object Object]', PROBABILITY_ASC: '[object Object]', PROBABILITY_DESC: '[object Object]', NEXT_STEP_ASC: '[object Object]', NEXT_STEP_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', ASSIGNED_TO_ASC: '[object Object]', ASSIGNED_TO_DESC: '[object Object]', LEAD_SOURCE_ASC: '[object Object]', LEAD_SOURCE_DESC: '[object Object]', CAMPAIGN_ASC: '[object Object]', CAMPAIGN_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', ACCOUNT_NAME_ASC: '[object Object]', ACCOUNT_NAME_DESC: '[object Object]', EXPECTED_CLOSE_DATE_ASC: '[object Object]', EXPECTED_CLOSE_DATE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type OrdersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrdersConnection'] = ResolversParentTypes['OrdersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Order']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['OrdersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Order'] = ResolversParentTypes['Order']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  purchasePoint?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  purchaseDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  billToName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shipToName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grandTotalBase?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  grandTotalPurchased?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  action?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  allocatedSources?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  braintreeTransactionSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quotes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transactions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrdersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['OrdersEdge'] = ResolversParentTypes['OrdersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrdersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', PURCHASE_POINT_ASC: '[object Object]', PURCHASE_POINT_DESC: '[object Object]', PURCHASE_DATE_ASC: '[object Object]', PURCHASE_DATE_DESC: '[object Object]', BILL_TO_NAME_ASC: '[object Object]', BILL_TO_NAME_DESC: '[object Object]', SHIP_TO_NAME_ASC: '[object Object]', SHIP_TO_NAME_DESC: '[object Object]', GRAND_TOTAL_BASE_ASC: '[object Object]', GRAND_TOTAL_BASE_DESC: '[object Object]', GRAND_TOTAL_PURCHASED_ASC: '[object Object]', GRAND_TOTAL_PURCHASED_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', ACTION_ASC: '[object Object]', ACTION_DESC: '[object Object]', ALLOCATED_SOURCES_ASC: '[object Object]', ALLOCATED_SOURCES_DESC: '[object Object]', BRAINTREE_TRANSACTION_SOURCE_ASC: '[object Object]', BRAINTREE_TRANSACTION_SOURCE_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', QUOTES_ASC: '[object Object]', QUOTES_DESC: '[object Object]', TRANSACTIONS_ASC: '[object Object]', TRANSACTIONS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type PagesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PagesConnection'] = ResolversParentTypes['PagesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Page']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PagesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Page'] = ResolversParentTypes['Page']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  enablePage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  contentTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  urlKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaKeywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PagesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PagesEdge'] = ResolversParentTypes['PagesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PagesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', ENABLE_PAGE_ASC: '[object Object]', ENABLE_PAGE_DESC: '[object Object]', TITLE_ASC: '[object Object]', TITLE_DESC: '[object Object]', CONTENT_TITLE_ASC: '[object Object]', CONTENT_TITLE_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', URL_KEY_ASC: '[object Object]', URL_KEY_DESC: '[object Object]', META_TITLE_ASC: '[object Object]', META_TITLE_DESC: '[object Object]', META_KEYWORDS_ASC: '[object Object]', META_KEYWORDS_DESC: '[object Object]', META_DESCRIPTION_ASC: '[object Object]', META_DESCRIPTION_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type PartnersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PartnersConnection'] = ResolversParentTypes['PartnersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Partner']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PartnersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PartnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Partner'] = ResolversParentTypes['Partner']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  businessType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PartnersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PartnersEdge'] = ResolversParentTypes['PartnersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Partner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PartnersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', ADDRESS_ASC: '[object Object]', ADDRESS_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', BUSINESS_TYPE_ASC: '[object Object]', BUSINESS_TYPE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type PaymentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaymentsConnection'] = ResolversParentTypes['PaymentsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Payment']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PaymentsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PaymentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Payment'] = ResolversParentTypes['Payment']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hostUri?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  redirectUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  redirectUrlApp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  active?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PaymentsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PaymentsEdge'] = ResolversParentTypes['PaymentsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PaymentsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CLIENT_ID_ASC: '[object Object]', CLIENT_ID_DESC: '[object Object]', CLIENT_SECRET_ASC: '[object Object]', CLIENT_SECRET_DESC: '[object Object]', HOST_URI_ASC: '[object Object]', HOST_URI_DESC: '[object Object]', REDIRECT_URL_ASC: '[object Object]', REDIRECT_URL_DESC: '[object Object]', REDIRECT_URL_APP_ASC: '[object Object]', REDIRECT_URL_APP_DESC: '[object Object]', ICON_ASC: '[object Object]', ICON_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', ACTIVE_ASC: '[object Object]', ACTIVE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type PermissionsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PermissionsConnection'] = ResolversParentTypes['PermissionsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Permission']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PermissionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PermissionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Permission'] = ResolversParentTypes['Permission']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  create?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  delete?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  read?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  update?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PermissionsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PermissionsEdge'] = ResolversParentTypes['PermissionsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Permission']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PermissionsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', CREATE_ASC: '[object Object]', CREATE_DESC: '[object Object]', DELETE_ASC: '[object Object]', DELETE_DESC: '[object Object]', READ_ASC: '[object Object]', READ_DESC: '[object Object]', ROLE_ASC: '[object Object]', ROLE_DESC: '[object Object]', UPDATE_ASC: '[object Object]', UPDATE_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type PluginsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PluginsConnection'] = ResolversParentTypes['PluginsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Plugin']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PluginsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PluginResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Plugin'] = ResolversParentTypes['Plugin']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  githubLink?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  screenshots?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastUpdated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  publisherName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  agreeTerms?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  publisherEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PluginsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PluginsEdge'] = ResolversParentTypes['PluginsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Plugin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PluginsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', URL_ASC: '[object Object]', URL_DESC: '[object Object]', GITHUB_LINK_ASC: '[object Object]', GITHUB_LINK_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', LOGO_ASC: '[object Object]', LOGO_DESC: '[object Object]', SCREENSHOTS_ASC: '[object Object]', SCREENSHOTS_DESC: '[object Object]', LAST_UPDATED_ASC: '[object Object]', LAST_UPDATED_DESC: '[object Object]', PUBLISHER_NAME_ASC: '[object Object]', PUBLISHER_NAME_DESC: '[object Object]', AGREE_TERMS_ASC: '[object Object]', AGREE_TERMS_DESC: '[object Object]', PUBLISHER_EMAIL_ASC: '[object Object]', PUBLISHER_EMAIL_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type PollsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PollsConnection'] = ResolversParentTypes['PollsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Poll']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PollsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PollResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Poll'] = ResolversParentTypes['Poll']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  question?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  response?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PollsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PollsEdge'] = ResolversParentTypes['PollsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Poll']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PollsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', EXCERPT_ASC: '[object Object]', EXCERPT_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PUBLISHED_ASC: '[object Object]', PUBLISHED_DESC: '[object Object]', QUESTION_ASC: '[object Object]', QUESTION_DESC: '[object Object]', RESPONSE_ASC: '[object Object]', RESPONSE_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ProductTypesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProductTypesConnection'] = ResolversParentTypes['ProductTypesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['ProductType']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ProductTypesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProductTypeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProductType'] = ResolversParentTypes['ProductType']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  typeName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isShippable?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filterOptions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProductTypesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProductTypesEdge'] = ResolversParentTypes['ProductTypesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProductTypesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', TYPE_NAME_ASC: '[object Object]', TYPE_NAME_DESC: '[object Object]', TAXES_ASC: '[object Object]', TAXES_DESC: '[object Object]', IS_SHIPPABLE_ASC: '[object Object]', IS_SHIPPABLE_DESC: '[object Object]', META_URL_ASC: '[object Object]', META_URL_DESC: '[object Object]', META_DESCRIPTION_ASC: '[object Object]', META_DESCRIPTION_DESC: '[object Object]', FILTER_OPTIONS_ASC: '[object Object]', FILTER_OPTIONS_DESC: '[object Object]', PRODUCT_TYPE_ASC: '[object Object]', PRODUCT_TYPE_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ProductsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProductsConnection'] = ResolversParentTypes['ProductsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Product']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ProductsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProductResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Product'] = ResolversParentTypes['Product']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  sku?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  price?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantityPerSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  salableQuantity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  websites?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxClass?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stockStatus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  weight?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  format?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  height?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaKeywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metaUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacture?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  attributes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brand?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contract?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  costString?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  family?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturerPartNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  occassions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  partNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  relatedProduct?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  types?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  variants?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  zone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brands?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coupons?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  creditMemos?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  occassionsOccassionsToproducts?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orders?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  otherProducts?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productAttribute?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productTypes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quotes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rating?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returns?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxRule?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trainings?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProductsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProductsEdge'] = ResolversParentTypes['ProductsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProductsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', SKU_ASC: '[object Object]', SKU_DESC: '[object Object]', THUMBNAIL_ASC: '[object Object]', THUMBNAIL_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', PRICE_ASC: '[object Object]', PRICE_DESC: '[object Object]', QUANTITY_PER_SOURCE_ASC: '[object Object]', QUANTITY_PER_SOURCE_DESC: '[object Object]', SALABLE_QUANTITY_ASC: '[object Object]', SALABLE_QUANTITY_DESC: '[object Object]', VISIBILITY_ASC: '[object Object]', VISIBILITY_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', WEBSITES_ASC: '[object Object]', WEBSITES_DESC: '[object Object]', PRODUCT_ASC: '[object Object]', PRODUCT_DESC: '[object Object]', TAX_CLASS_ASC: '[object Object]', TAX_CLASS_DESC: '[object Object]', STOCK_STATUS_ASC: '[object Object]', STOCK_STATUS_DESC: '[object Object]', WEIGHT_ASC: '[object Object]', WEIGHT_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', SIZE_ASC: '[object Object]', SIZE_DESC: '[object Object]', FORMAT_ASC: '[object Object]', FORMAT_DESC: '[object Object]', HEIGHT_ASC: '[object Object]', HEIGHT_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', SHORT_DESCRIPTION_ASC: '[object Object]', SHORT_DESCRIPTION_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', META_TITLE_ASC: '[object Object]', META_TITLE_DESC: '[object Object]', META_KEYWORDS_ASC: '[object Object]', META_KEYWORDS_DESC: '[object Object]', META_DESCRIPTION_ASC: '[object Object]', META_DESCRIPTION_DESC: '[object Object]', META_URL_ASC: '[object Object]', META_URL_DESC: '[object Object]', FILE_ASC: '[object Object]', FILE_DESC: '[object Object]', MANUFACTURE_ASC: '[object Object]', MANUFACTURE_DESC: '[object Object]', ATTRIBUTES_ASC: '[object Object]', ATTRIBUTES_DESC: '[object Object]', BRAND_ASC: '[object Object]', BRAND_DESC: '[object Object]', CONTRACT_ASC: '[object Object]', CONTRACT_DESC: '[object Object]', COST_STRING_ASC: '[object Object]', COST_STRING_DESC: '[object Object]', CUSTOMER_TYPE_ASC: '[object Object]', CUSTOMER_TYPE_DESC: '[object Object]', FAMILY_ASC: '[object Object]', FAMILY_DESC: '[object Object]', MANUFACTURER_PART_NUMBER_ASC: '[object Object]', MANUFACTURER_PART_NUMBER_DESC: '[object Object]', OCCASSIONS_ASC: '[object Object]', OCCASSIONS_DESC: '[object Object]', PART_NUMBER_ASC: '[object Object]', PART_NUMBER_DESC: '[object Object]', RELATED_PRODUCT_ASC: '[object Object]', RELATED_PRODUCT_DESC: '[object Object]', TAGS_ASC: '[object Object]', TAGS_DESC: '[object Object]', TYPES_ASC: '[object Object]', TYPES_DESC: '[object Object]', VARIANTS_ASC: '[object Object]', VARIANTS_DESC: '[object Object]', ZONE_ASC: '[object Object]', ZONE_DESC: '[object Object]', BRANDS_ASC: '[object Object]', BRANDS_DESC: '[object Object]', COUPONS_ASC: '[object Object]', COUPONS_DESC: '[object Object]', CREDIT_MEMOS_ASC: '[object Object]', CREDIT_MEMOS_DESC: '[object Object]', MANUFACTURER_ASC: '[object Object]', MANUFACTURER_DESC: '[object Object]', MEDIAMANAGER_ASC: '[object Object]', MEDIAMANAGER_DESC: '[object Object]', OCCASSIONS_OCCASSIONS_TOPRODUCTS_ASC: '[object Object]', OCCASSIONS_OCCASSIONS_TOPRODUCTS_DESC: '[object Object]', ORDERS_ASC: '[object Object]', ORDERS_DESC: '[object Object]', OTHER_PRODUCTS_ASC: '[object Object]', OTHER_PRODUCTS_DESC: '[object Object]', PRODUCT_ATTRIBUTE_ASC: '[object Object]', PRODUCT_ATTRIBUTE_DESC: '[object Object]', PRODUCT_TYPES_ASC: '[object Object]', PRODUCT_TYPES_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', QUOTES_ASC: '[object Object]', QUOTES_DESC: '[object Object]', RATING_ASC: '[object Object]', RATING_DESC: '[object Object]', RETURNS_ASC: '[object Object]', RETURNS_DESC: '[object Object]', TAX_RATE_ASC: '[object Object]', TAX_RATE_DESC: '[object Object]', TAX_RULE_ASC: '[object Object]', TAX_RULE_DESC: '[object Object]', TRAININGS_ASC: '[object Object]', TRAININGS_DESC: '[object Object]', WORKSPACES_ASC: '[object Object]', WORKSPACES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ProjectsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectsConnection'] = ResolversParentTypes['ProjectsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Project']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ProjectsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Project'] = ResolversParentTypes['Project']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectManager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  considerworkingdays?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectTemplate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  assignee?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  doing?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  done?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  goalCollaborators?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  goalMeasurement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  goalName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  goalPrivacy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  goalProgressSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  goalTimeperiod?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  goalUpdatemethod?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sectionRule?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  staffId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  taskId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  ticketId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tasks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ticketing?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  websites?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  method?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  zone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  company?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProjectsEdge'] = ResolversParentTypes['ProjectsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProjectsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', PROJECT_MANAGER_ASC: '[object Object]', PROJECT_MANAGER_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', RESOURCE_ASC: '[object Object]', RESOURCE_DESC: '[object Object]', CONSIDERWORKINGDAYS_ASC: '[object Object]', CONSIDERWORKINGDAYS_DESC: '[object Object]', PROJECT_TEMPLATE_ASC: '[object Object]', PROJECT_TEMPLATE_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', ASSIGNEE_ASC: '[object Object]', ASSIGNEE_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', DOING_ASC: '[object Object]', DOING_DESC: '[object Object]', DONE_ASC: '[object Object]', DONE_DESC: '[object Object]', GOAL_COLLABORATORS_ASC: '[object Object]', GOAL_COLLABORATORS_DESC: '[object Object]', GOAL_MEASUREMENT_ASC: '[object Object]', GOAL_MEASUREMENT_DESC: '[object Object]', GOAL_NAME_ASC: '[object Object]', GOAL_NAME_DESC: '[object Object]', GOAL_PRIVACY_ASC: '[object Object]', GOAL_PRIVACY_DESC: '[object Object]', GOAL_PROGRESS_SOURCE_ASC: '[object Object]', GOAL_PROGRESS_SOURCE_DESC: '[object Object]', GOAL_TIMEPERIOD_ASC: '[object Object]', GOAL_TIMEPERIOD_DESC: '[object Object]', GOAL_UPDATEMETHOD_ASC: '[object Object]', GOAL_UPDATEMETHOD_DESC: '[object Object]', PRIORITY_ASC: '[object Object]', PRIORITY_DESC: '[object Object]', SECTION_RULE_ASC: '[object Object]', SECTION_RULE_DESC: '[object Object]', STAFF_ID_ASC: '[object Object]', STAFF_ID_DESC: '[object Object]', TASK_ID_ASC: '[object Object]', TASK_ID_DESC: '[object Object]', TICKET_ID_ASC: '[object Object]', TICKET_ID_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', TASKS_ASC: '[object Object]', TASKS_DESC: '[object Object]', TICKETING_ASC: '[object Object]', TICKETING_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', WORKSPACES_ASC: '[object Object]', WORKSPACES_DESC: '[object Object]', TAGS_ASC: '[object Object]', TAGS_DESC: '[object Object]', PRODUCT_ASC: '[object Object]', PRODUCT_DESC: '[object Object]', WEBSITES_ASC: '[object Object]', WEBSITES_DESC: '[object Object]', METHOD_ASC: '[object Object]', METHOD_DESC: '[object Object]', ZONE_ASC: '[object Object]', ZONE_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', TEAM_ASC: '[object Object]', TEAM_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', COMPANY_ASC: '[object Object]', COMPANY_DESC: '[object Object]', FILE_ASC: '[object Object]', FILE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ProvidersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersConnection'] = ResolversParentTypes['ProvidersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Provider']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ProvidersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Provider'] = ResolversParentTypes['Provider']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hostUri?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  redirectUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  redirectUrlApp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  active?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ProvidersEdge'] = ResolversParentTypes['ProvidersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Provider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProvidersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CLIENT_ID_ASC: '[object Object]', CLIENT_ID_DESC: '[object Object]', CLIENT_SECRET_ASC: '[object Object]', CLIENT_SECRET_DESC: '[object Object]', HOST_URI_ASC: '[object Object]', HOST_URI_DESC: '[object Object]', REDIRECT_URL_ASC: '[object Object]', REDIRECT_URL_DESC: '[object Object]', REDIRECT_URL_APP_ASC: '[object Object]', REDIRECT_URL_APP_DESC: '[object Object]', ICON_ASC: '[object Object]', ICON_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', ACTIVE_ASC: '[object Object]', ACTIVE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type QuotesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QuotesConnection'] = ResolversParentTypes['QuotesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Quote']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['QuotesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QuoteResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Quote'] = ResolversParentTypes['Quote']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  grandTotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quoteStage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  orderId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  account?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  approvalIssues?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  approvalStatus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingCity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingCountry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingPostal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingStreet?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invoiceStatus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemDiscount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemGroupTotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemSubtotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemTax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemTotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentTerms?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shipping?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingCity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingCountry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingPostal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingStreet?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingTax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subtotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customersCustomersToquotes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orders?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productsProductsToquotes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QuotesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['QuotesEdge'] = ResolversParentTypes['QuotesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QuotesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', GRAND_TOTAL_ASC: '[object Object]', GRAND_TOTAL_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', VALID_UNTIL_ASC: '[object Object]', VALID_UNTIL_DESC: '[object Object]', QUOTE_STAGE_ASC: '[object Object]', QUOTE_STAGE_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', CUST_ID_ASC: '[object Object]', CUST_ID_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', ORDER_ID_ASC: '[object Object]', ORDER_ID_DESC: '[object Object]', ACCOUNT_ASC: '[object Object]', ACCOUNT_DESC: '[object Object]', APPROVAL_ISSUES_ASC: '[object Object]', APPROVAL_ISSUES_DESC: '[object Object]', APPROVAL_STATUS_ASC: '[object Object]', APPROVAL_STATUS_DESC: '[object Object]', ASSIGNED_TO_ASC: '[object Object]', ASSIGNED_TO_DESC: '[object Object]', BILLING_CITY_ASC: '[object Object]', BILLING_CITY_DESC: '[object Object]', BILLING_COUNTRY_ASC: '[object Object]', BILLING_COUNTRY_DESC: '[object Object]', BILLING_POSTAL_ASC: '[object Object]', BILLING_POSTAL_DESC: '[object Object]', BILLING_STATE_ASC: '[object Object]', BILLING_STATE_DESC: '[object Object]', BILLING_STREET_ASC: '[object Object]', BILLING_STREET_DESC: '[object Object]', CONTACT_ASC: '[object Object]', CONTACT_DESC: '[object Object]', CURRENCY_ASC: '[object Object]', CURRENCY_DESC: '[object Object]', DISCOUNT_ASC: '[object Object]', DISCOUNT_DESC: '[object Object]', INVOICE_STATUS_ASC: '[object Object]', INVOICE_STATUS_DESC: '[object Object]', LINE_ITEM_DISCOUNT_ASC: '[object Object]', LINE_ITEM_DISCOUNT_DESC: '[object Object]', LINE_ITEM_GROUP_TOTAL_ASC: '[object Object]', LINE_ITEM_GROUP_TOTAL_DESC: '[object Object]', LINE_ITEM_NAME_ASC: '[object Object]', LINE_ITEM_NAME_DESC: '[object Object]', LINE_ITEM_SUBTOTAL_ASC: '[object Object]', LINE_ITEM_SUBTOTAL_DESC: '[object Object]', LINE_ITEM_TAX_ASC: '[object Object]', LINE_ITEM_TAX_DESC: '[object Object]', LINE_ITEM_TOTAL_ASC: '[object Object]', LINE_ITEM_TOTAL_DESC: '[object Object]', PAYMENT_TERMS_ASC: '[object Object]', PAYMENT_TERMS_DESC: '[object Object]', SHIPPING_ASC: '[object Object]', SHIPPING_DESC: '[object Object]', SHIPPING_CITY_ASC: '[object Object]', SHIPPING_CITY_DESC: '[object Object]', SHIPPING_COUNTRY_ASC: '[object Object]', SHIPPING_COUNTRY_DESC: '[object Object]', SHIPPING_POSTAL_ASC: '[object Object]', SHIPPING_POSTAL_DESC: '[object Object]', SHIPPING_STATE_ASC: '[object Object]', SHIPPING_STATE_DESC: '[object Object]', SHIPPING_STREET_ASC: '[object Object]', SHIPPING_STREET_DESC: '[object Object]', SHIPPING_TAX_ASC: '[object Object]', SHIPPING_TAX_DESC: '[object Object]', SUBTOTAL_ASC: '[object Object]', SUBTOTAL_DESC: '[object Object]', TAX_ASC: '[object Object]', TAX_DESC: '[object Object]', TOTAL_ASC: '[object Object]', TOTAL_DESC: '[object Object]', CUSTOMERS_CUSTOMERS_TOQUOTES_ASC: '[object Object]', CUSTOMERS_CUSTOMERS_TOQUOTES_DESC: '[object Object]', ORDERS_ASC: '[object Object]', ORDERS_DESC: '[object Object]', PRODUCTS_PRODUCTS_TOQUOTES_ASC: '[object Object]', PRODUCTS_PRODUCTS_TOQUOTES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type RatingsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RatingsConnection'] = ResolversParentTypes['RatingsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Rating']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['RatingsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RatingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Rating'] = ResolversParentTypes['Rating']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  defaultValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultStoreView?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ratingVisibility?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  active?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  sortOrder?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RatingsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RatingsEdge'] = ResolversParentTypes['RatingsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Rating']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RatingsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', DEFAULT_VALUE_ASC: '[object Object]', DEFAULT_VALUE_DESC: '[object Object]', DEFAULT_STORE_VIEW_ASC: '[object Object]', DEFAULT_STORE_VIEW_DESC: '[object Object]', RATING_VISIBILITY_ASC: '[object Object]', RATING_VISIBILITY_DESC: '[object Object]', ACTIVE_ASC: '[object Object]', ACTIVE_DESC: '[object Object]', SORT_ORDER_ASC: '[object Object]', SORT_ORDER_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ReportsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReportsConnection'] = ResolversParentTypes['ReportsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Report']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReportsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReportResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Report'] = ResolversParentTypes['Report']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  subtotal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  appliedCoupon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  ipAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReportsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReportsEdge'] = ResolversParentTypes['ReportsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReportsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CUSTOMER_ASC: '[object Object]', CUSTOMER_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', QUANTITY_ASC: '[object Object]', QUANTITY_DESC: '[object Object]', SUBTOTAL_ASC: '[object Object]', SUBTOTAL_DESC: '[object Object]', APPLIED_COUPON_ASC: '[object Object]', APPLIED_COUPON_DESC: '[object Object]', CREATED_ASC: '[object Object]', CREATED_DESC: '[object Object]', UPDATED_ASC: '[object Object]', UPDATED_DESC: '[object Object]', IP_ADDRESS_ASC: '[object Object]', IP_ADDRESS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ReturnsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReturnsConnection'] = ResolversParentTypes['ReturnsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Return']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReturnsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReturnResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Return'] = ResolversParentTypes['Return']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  validity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returnPrefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  liquidationReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  weight?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  height?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  howShipped?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shipTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  caseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReturnsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReturnsEdge'] = ResolversParentTypes['ReturnsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Return']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReturnsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', VALIDITY_ASC: '[object Object]', VALIDITY_DESC: '[object Object]', RETURN_PREFIX_ASC: '[object Object]', RETURN_PREFIX_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', SHIPPING_NUMBER_ASC: '[object Object]', SHIPPING_NUMBER_DESC: '[object Object]', SHIPPING_DESCRIPTION_ASC: '[object Object]', SHIPPING_DESCRIPTION_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', LIQUIDATION_REASON_ASC: '[object Object]', LIQUIDATION_REASON_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', WEIGHT_ASC: '[object Object]', WEIGHT_DESC: '[object Object]', HEIGHT_ASC: '[object Object]', HEIGHT_DESC: '[object Object]', HOW_SHIPPED_ASC: '[object Object]', HOW_SHIPPED_DESC: '[object Object]', LOCATION_ASC: '[object Object]', LOCATION_DESC: '[object Object]', SHIP_TO_ASC: '[object Object]', SHIP_TO_DESC: '[object Object]', CASE_ID_ASC: '[object Object]', CASE_ID_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ReviewsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewsConnection'] = ResolversParentTypes['ReviewsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Review']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReviewsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Review'] = ResolversParentTypes['Review']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  websites?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  shopId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commentId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ReviewsEdge'] = ResolversParentTypes['ReviewsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReviewsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', FIRST_NAME_ASC: '[object Object]', FIRST_NAME_DESC: '[object Object]', LAST_NAME_ASC: '[object Object]', LAST_NAME_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', WEBSITES_ASC: '[object Object]', WEBSITES_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', SHOP_ID_ASC: '[object Object]', SHOP_ID_DESC: '[object Object]', COMMENT_ID_ASC: '[object Object]', COMMENT_ID_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type RewardsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RewardsConnection'] = ResolversParentTypes['RewardsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Reward']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['RewardsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RewardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Reward'] = ResolversParentTypes['Reward']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  coupons?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RewardsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RewardsEdge'] = ResolversParentTypes['RewardsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Reward']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RewardsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', SLUG_ASC: '[object Object]', SLUG_DESC: '[object Object]', LEVEL_ASC: '[object Object]', LEVEL_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', COUPONS_ASC: '[object Object]', COUPONS_DESC: '[object Object]', EXPIRATION_ASC: '[object Object]', EXPIRATION_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type RolesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RolesConnection'] = ResolversParentTypes['RolesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Role']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['RolesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Role'] = ResolversParentTypes['Role']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  roleName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RolesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['RolesEdge'] = ResolversParentTypes['RolesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RolesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', ROLE_NAME_ASC: '[object Object]', ROLE_NAME_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type SchedulersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SchedulersConnection'] = ResolversParentTypes['SchedulersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Scheduler']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['SchedulersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SchedulerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Scheduler'] = ResolversParentTypes['Scheduler']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  whid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SchedulersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SchedulersEdge'] = ResolversParentTypes['SchedulersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Scheduler']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SchedulersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', LEVEL_ASC: '[object Object]', LEVEL_DESC: '[object Object]', LOGIN_ASC: '[object Object]', LOGIN_DESC: '[object Object]', NOTES_ASC: '[object Object]', NOTES_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', WHID_ASC: '[object Object]', WHID_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type SegmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SegmentsConnection'] = ResolversParentTypes['SegmentsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Segment']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['SegmentsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SegmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Segment'] = ResolversParentTypes['Segment']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applyTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SegmentsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SegmentsEdge'] = ResolversParentTypes['SegmentsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Segment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SegmentsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', APPLY_TO_ASC: '[object Object]', APPLY_TO_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type SettingsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SettingsConnection'] = ResolversParentTypes['SettingsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Setting']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['SettingsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SettingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Setting'] = ResolversParentTypes['Setting']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  storeName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  storePhone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  storeHours?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  zipcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  addressTwo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vatNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  allowState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stateRequiredFor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  allowCountries?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultCountry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  optionalZip?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  europeanUnionCountries?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  topDestinations?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  baseCurrency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultCurrency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  allowedCurrency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  siteName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  siteWebsite?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sentryDsn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  awsS3?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  databaseUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  googleAnalytics?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  searchSetting?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mailServer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  youtubeVideos?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  siteTagline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  googleDrive?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  disqusKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SettingsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SettingsEdge'] = ResolversParentTypes['SettingsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Setting']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SettingsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', STORE_NAME_ASC: '[object Object]', STORE_NAME_DESC: '[object Object]', STORE_PHONE_ASC: '[object Object]', STORE_PHONE_DESC: '[object Object]', STORE_HOURS_ASC: '[object Object]', STORE_HOURS_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', REGION_ASC: '[object Object]', REGION_DESC: '[object Object]', ZIPCODE_ASC: '[object Object]', ZIPCODE_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', ADDRESS_ASC: '[object Object]', ADDRESS_DESC: '[object Object]', ADDRESS_TWO_ASC: '[object Object]', ADDRESS_TWO_DESC: '[object Object]', VAT_NUMBER_ASC: '[object Object]', VAT_NUMBER_DESC: '[object Object]', ALLOW_STATE_ASC: '[object Object]', ALLOW_STATE_DESC: '[object Object]', STATE_REQUIRED_FOR_ASC: '[object Object]', STATE_REQUIRED_FOR_DESC: '[object Object]', ALLOW_COUNTRIES_ASC: '[object Object]', ALLOW_COUNTRIES_DESC: '[object Object]', DEFAULT_COUNTRY_ASC: '[object Object]', DEFAULT_COUNTRY_DESC: '[object Object]', OPTIONAL_ZIP_ASC: '[object Object]', OPTIONAL_ZIP_DESC: '[object Object]', EUROPEAN_UNION_COUNTRIES_ASC: '[object Object]', EUROPEAN_UNION_COUNTRIES_DESC: '[object Object]', TOP_DESTINATIONS_ASC: '[object Object]', TOP_DESTINATIONS_DESC: '[object Object]', BASE_CURRENCY_ASC: '[object Object]', BASE_CURRENCY_DESC: '[object Object]', DEFAULT_CURRENCY_ASC: '[object Object]', DEFAULT_CURRENCY_DESC: '[object Object]', ALLOWED_CURRENCY_ASC: '[object Object]', ALLOWED_CURRENCY_DESC: '[object Object]', SITE_NAME_ASC: '[object Object]', SITE_NAME_DESC: '[object Object]', SITE_WEBSITE_ASC: '[object Object]', SITE_WEBSITE_DESC: '[object Object]', SENTRY_DSN_ASC: '[object Object]', SENTRY_DSN_DESC: '[object Object]', AWS_S3_ASC: '[object Object]', AWS_S3_DESC: '[object Object]', DATABASE_URL_ASC: '[object Object]', DATABASE_URL_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', GOOGLE_ANALYTICS_ASC: '[object Object]', GOOGLE_ANALYTICS_DESC: '[object Object]', SEARCH_SETTING_ASC: '[object Object]', SEARCH_SETTING_DESC: '[object Object]', MAIL_SERVER_ASC: '[object Object]', MAIL_SERVER_DESC: '[object Object]', YOUTUBE_VIDEOS_ASC: '[object Object]', YOUTUBE_VIDEOS_DESC: '[object Object]', SITE_TAGLINE_ASC: '[object Object]', SITE_TAGLINE_DESC: '[object Object]', GOOGLE_DRIVE_ASC: '[object Object]', GOOGLE_DRIVE_DESC: '[object Object]', DISQUS_KEY_ASC: '[object Object]', DISQUS_KEY_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ShipmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShipmentsConnection'] = ResolversParentTypes['ShipmentsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Shipment']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ShipmentsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ShipmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Shipment'] = ResolversParentTypes['Shipment']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  speedGrade?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shipDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  carrierName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  transitTime?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trackingUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  clientSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ShipmentsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShipmentsEdge'] = ResolversParentTypes['ShipmentsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Shipment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ShipmentsOrderByResolvers = { NATURAL: '[object Object]', PRODUCT_ASC: '[object Object]', PRODUCT_DESC: '[object Object]', SPEED_GRADE_ASC: '[object Object]', SPEED_GRADE_DESC: '[object Object]', SHIP_DATE_ASC: '[object Object]', SHIP_DATE_DESC: '[object Object]', CARRIER_NAME_ASC: '[object Object]', CARRIER_NAME_DESC: '[object Object]', TRANSIT_TIME_ASC: '[object Object]', TRANSIT_TIME_DESC: '[object Object]', TRACKING_URL_ASC: '[object Object]', TRACKING_URL_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CLIENT_ID_ASC: '[object Object]', CLIENT_ID_DESC: '[object Object]', CLIENT_SECRET_ASC: '[object Object]', CLIENT_SECRET_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type SpecialDiscountsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SpecialDiscountsConnection'] = ResolversParentTypes['SpecialDiscountsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['SpecialDiscount']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['SpecialDiscountsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SpecialDiscountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SpecialDiscount'] = ResolversParentTypes['SpecialDiscount']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  rewards?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coupons?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiration?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SpecialDiscountsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SpecialDiscountsEdge'] = ResolversParentTypes['SpecialDiscountsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SpecialDiscount']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SpecialDiscountsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', EXCERPT_ASC: '[object Object]', EXCERPT_DESC: '[object Object]', DISCOUNT_ASC: '[object Object]', DISCOUNT_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PUBLISHED_ASC: '[object Object]', PUBLISHED_DESC: '[object Object]', REWARDS_ASC: '[object Object]', REWARDS_DESC: '[object Object]', COUPONS_ASC: '[object Object]', COUPONS_DESC: '[object Object]', EXPIRATION_ASC: '[object Object]', EXPIRATION_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type StatesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatesConnection'] = ResolversParentTypes['StatesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['State']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['StatesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['State'] = ResolversParentTypes['State']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trainings?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatesEdge'] = ResolversParentTypes['StatesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', TRAININGS_ASC: '[object Object]', TRAININGS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type StatisticsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatisticsConnection'] = ResolversParentTypes['StatisticsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Statistic']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['StatisticsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatisticResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Statistic'] = ResolversParentTypes['Statistic']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  specialOffers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rewards?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coupons?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiration?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatisticsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StatisticsEdge'] = ResolversParentTypes['StatisticsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Statistic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatisticsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', EXCERPT_ASC: '[object Object]', EXCERPT_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PUBLISHED_ASC: '[object Object]', PUBLISHED_DESC: '[object Object]', SPECIAL_OFFERS_ASC: '[object Object]', SPECIAL_OFFERS_DESC: '[object Object]', REPORTS_ASC: '[object Object]', REPORTS_DESC: '[object Object]', REWARDS_ASC: '[object Object]', REWARDS_DESC: '[object Object]', COUPONS_ASC: '[object Object]', COUPONS_DESC: '[object Object]', EXPIRATION_ASC: '[object Object]', EXPIRATION_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type StocksConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StocksConnection'] = ResolversParentTypes['StocksConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Stock']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['StocksEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StockResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Stock'] = ResolversParentTypes['Stock']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sources?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StocksEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['StocksEdge'] = ResolversParentTypes['StocksEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Stock']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StocksOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', ENABLED_ASC: '[object Object]', ENABLED_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', SOURCES_ASC: '[object Object]', SOURCES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type SurveysConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SurveysConnection'] = ResolversParentTypes['SurveysConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Survey']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['SurveysEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SurveyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Survey'] = ResolversParentTypes['Survey']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  question?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  answer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  submitText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  satisfiedText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  neitherText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dissatisfiedText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SurveysEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SurveysEdge'] = ResolversParentTypes['SurveysEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Survey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SurveysOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', ASSIGNED_TO_ASC: '[object Object]', ASSIGNED_TO_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', QUESTION_ASC: '[object Object]', QUESTION_DESC: '[object Object]', ANSWER_ASC: '[object Object]', ANSWER_DESC: '[object Object]', SUBMIT_TEXT_ASC: '[object Object]', SUBMIT_TEXT_DESC: '[object Object]', SATISFIED_TEXT_ASC: '[object Object]', SATISFIED_TEXT_DESC: '[object Object]', NEITHER_TEXT_ASC: '[object Object]', NEITHER_TEXT_DESC: '[object Object]', DISSATISFIED_TEXT_ASC: '[object Object]', DISSATISFIED_TEXT_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TagsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TagsConnection'] = ResolversParentTypes['TagsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Tag']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TagsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Tag'] = ResolversParentTypes['Tag']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TagsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TagsEdge'] = ResolversParentTypes['TagsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TagsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', EXCERPT_ASC: '[object Object]', EXCERPT_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TargetsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TargetsConnection'] = ResolversParentTypes['TargetsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Target']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TargetsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TargetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Target'] = ResolversParentTypes['Target']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  department?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postalcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mobile?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jobTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altPostalcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altCity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  altCountry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  officePhone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emailOptOut?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  donotcall?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TargetsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TargetsEdge'] = ResolversParentTypes['TargetsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Target']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TargetsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', PREFIX_ASC: '[object Object]', PREFIX_DESC: '[object Object]', FIRST_NAME_ASC: '[object Object]', FIRST_NAME_DESC: '[object Object]', LAST_NAME_ASC: '[object Object]', LAST_NAME_DESC: '[object Object]', DEPARTMENT_ASC: '[object Object]', DEPARTMENT_DESC: '[object Object]', ACCOUNT_NAME_ASC: '[object Object]', ACCOUNT_NAME_DESC: '[object Object]', ADDRESS_ASC: '[object Object]', ADDRESS_DESC: '[object Object]', POSTALCODE_ASC: '[object Object]', POSTALCODE_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', FAX_ASC: '[object Object]', FAX_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', MOBILE_ASC: '[object Object]', MOBILE_DESC: '[object Object]', JOB_TITLE_ASC: '[object Object]', JOB_TITLE_DESC: '[object Object]', ALT_ADDRESS_ASC: '[object Object]', ALT_ADDRESS_DESC: '[object Object]', ALT_POSTALCODE_ASC: '[object Object]', ALT_POSTALCODE_DESC: '[object Object]', ALT_CITY_ASC: '[object Object]', ALT_CITY_DESC: '[object Object]', ALT_STATE_ASC: '[object Object]', ALT_STATE_DESC: '[object Object]', ALT_COUNTRY_ASC: '[object Object]', ALT_COUNTRY_DESC: '[object Object]', OFFICE_PHONE_ASC: '[object Object]', OFFICE_PHONE_DESC: '[object Object]', CUSTOMER_NAME_ASC: '[object Object]', CUSTOMER_NAME_DESC: '[object Object]', EMAIL_OPT_OUT_ASC: '[object Object]', EMAIL_OPT_OUT_DESC: '[object Object]', DONOTCALL_ASC: '[object Object]', DONOTCALL_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TaxCategoriesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxCategoriesConnection'] = ResolversParentTypes['TaxCategoriesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['TaxCategory']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TaxCategoriesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxCategoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxCategory'] = ResolversParentTypes['TaxCategory']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxCategoriesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxCategoriesEdge'] = ResolversParentTypes['TaxCategoriesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxCategoriesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DEFAULT_ASC: '[object Object]', DEFAULT_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TaxRatesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxRatesConnection'] = ResolversParentTypes['TaxRatesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['TaxRate']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TaxRatesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxRateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxRate'] = ResolversParentTypes['TaxRate']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  taxIdentifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  zipPostIsRange?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  postcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ratePercent?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultStoreView?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxRatesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxRatesEdge'] = ResolversParentTypes['TaxRatesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxRatesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', TAX_IDENTIFIER_ASC: '[object Object]', TAX_IDENTIFIER_DESC: '[object Object]', ZIP_POST_IS_RANGE_ASC: '[object Object]', ZIP_POST_IS_RANGE_DESC: '[object Object]', POSTCODE_ASC: '[object Object]', POSTCODE_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', RATE_PERCENT_ASC: '[object Object]', RATE_PERCENT_DESC: '[object Object]', DEFAULT_STORE_VIEW_ASC: '[object Object]', DEFAULT_STORE_VIEW_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TaxRulesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxRulesConnection'] = ResolversParentTypes['TaxRulesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['TaxRule']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TaxRulesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxRule'] = ResolversParentTypes['TaxRule']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prodId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxRulesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TaxRulesEdge'] = ResolversParentTypes['TaxRulesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TaxRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxRulesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', TAX_RATE_ASC: '[object Object]', TAX_RATE_DESC: '[object Object]', PROD_ID_ASC: '[object Object]', PROD_ID_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TemplatesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TemplatesConnection'] = ResolversParentTypes['TemplatesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Template']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TemplatesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TemplateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Template'] = ResolversParentTypes['Template']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  active?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pageSize?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orientation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  header?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  footer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  marginLeft?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  marginRight?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  marginTop?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  marginBottom?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  marginHeader?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  marginFooter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TemplatesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TemplatesEdge'] = ResolversParentTypes['TemplatesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TemplatesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', ASSIGNED_TO_ASC: '[object Object]', ASSIGNED_TO_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', ACTIVE_ASC: '[object Object]', ACTIVE_DESC: '[object Object]', PAGE_SIZE_ASC: '[object Object]', PAGE_SIZE_DESC: '[object Object]', ORIENTATION_ASC: '[object Object]', ORIENTATION_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', HEADER_ASC: '[object Object]', HEADER_DESC: '[object Object]', FOOTER_ASC: '[object Object]', FOOTER_DESC: '[object Object]', MARGIN_LEFT_ASC: '[object Object]', MARGIN_LEFT_DESC: '[object Object]', MARGIN_RIGHT_ASC: '[object Object]', MARGIN_RIGHT_DESC: '[object Object]', MARGIN_TOP_ASC: '[object Object]', MARGIN_TOP_DESC: '[object Object]', MARGIN_BOTTOM_ASC: '[object Object]', MARGIN_BOTTOM_DESC: '[object Object]', MARGIN_HEADER_ASC: '[object Object]', MARGIN_HEADER_DESC: '[object Object]', MARGIN_FOOTER_ASC: '[object Object]', MARGIN_FOOTER_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ThemesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ThemesConnection'] = ResolversParentTypes['ThemesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Theme']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ThemesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ThemeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Theme'] = ResolversParentTypes['Theme']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentTheme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  themePath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  action?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  websiteId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  websites?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ThemesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ThemesEdge'] = ResolversParentTypes['ThemesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Theme']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ThemesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', TITLE_ASC: '[object Object]', TITLE_DESC: '[object Object]', PARENT_THEME_ASC: '[object Object]', PARENT_THEME_DESC: '[object Object]', THEME_PATH_ASC: '[object Object]', THEME_PATH_DESC: '[object Object]', ACTION_ASC: '[object Object]', ACTION_DESC: '[object Object]', WEBSITE_ID_ASC: '[object Object]', WEBSITE_ID_DESC: '[object Object]', WEBSITES_ASC: '[object Object]', WEBSITES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TicketingsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TicketingsConnection'] = ResolversParentTypes['TicketingsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Ticketing']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TicketingsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TicketingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Ticketing'] = ResolversParentTypes['Ticketing']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  severity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  requester?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  requesterEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  department?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projects?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ticketType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resolution?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateModified?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  accountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectsProjectsToticketing?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TicketingsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TicketingsEdge'] = ResolversParentTypes['TicketingsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Ticketing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TicketingsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', LOCATION_ASC: '[object Object]', LOCATION_DESC: '[object Object]', DATE_ASC: '[object Object]', DATE_DESC: '[object Object]', SEVERITY_ASC: '[object Object]', SEVERITY_DESC: '[object Object]', TEAM_ASC: '[object Object]', TEAM_DESC: '[object Object]', REQUESTER_ASC: '[object Object]', REQUESTER_DESC: '[object Object]', REQUESTER_EMAIL_ASC: '[object Object]', REQUESTER_EMAIL_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', DEPARTMENT_ASC: '[object Object]', DEPARTMENT_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', PROJECTS_ASC: '[object Object]', PROJECTS_DESC: '[object Object]', TICKET_TYPE_ASC: '[object Object]', TICKET_TYPE_DESC: '[object Object]', COMMENT_ASC: '[object Object]', COMMENT_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', PRIORITY_ASC: '[object Object]', PRIORITY_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', RESOLUTION_ASC: '[object Object]', RESOLUTION_DESC: '[object Object]', ASSIGNED_TO_ASC: '[object Object]', ASSIGNED_TO_DESC: '[object Object]', DATE_MODIFIED_ASC: '[object Object]', DATE_MODIFIED_DESC: '[object Object]', ACCOUNT_NAME_ASC: '[object Object]', ACCOUNT_NAME_DESC: '[object Object]', LEVEL_ASC: '[object Object]', LEVEL_DESC: '[object Object]', PROJECTS_PROJECTS_TOTICKETING_ASC: '[object Object]', PROJECTS_PROJECTS_TOTICKETING_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TrainingsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TrainingsConnection'] = ResolversParentTypes['TrainingsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Training']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TrainingsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TrainingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Training'] = ResolversParentTypes['Training']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  link?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  steps?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  analytics?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  competency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  course?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grade?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  school?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  postal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teacher?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  student?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  badges?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isCompleted?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  speakers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fieldTrips?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignments?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assignmentsDueDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  origanalityReport?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  faqs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  languages?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  checklists?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  meetups?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lab?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  digiboards?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countries?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  states?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TrainingsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TrainingsEdge'] = ResolversParentTypes['TrainingsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Training']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TrainingsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', SUBJECT_ASC: '[object Object]', SUBJECT_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', LINK_ASC: '[object Object]', LINK_DESC: '[object Object]', STEPS_ASC: '[object Object]', STEPS_DESC: '[object Object]', UPDATED_ASC: '[object Object]', UPDATED_DESC: '[object Object]', ANALYTICS_ASC: '[object Object]', ANALYTICS_DESC: '[object Object]', COMPETENCY_ASC: '[object Object]', COMPETENCY_DESC: '[object Object]', COURSE_ASC: '[object Object]', COURSE_DESC: '[object Object]', GRADE_ASC: '[object Object]', GRADE_DESC: '[object Object]', SCHOOL_ASC: '[object Object]', SCHOOL_DESC: '[object Object]', COMMENT_ASC: '[object Object]', COMMENT_DESC: '[object Object]', ADDRESS_ASC: '[object Object]', ADDRESS_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', POSTAL_ASC: '[object Object]', POSTAL_DESC: '[object Object]', TEACHER_ASC: '[object Object]', TEACHER_DESC: '[object Object]', STUDENT_ASC: '[object Object]', STUDENT_DESC: '[object Object]', ANNOUNCEMENT_ASC: '[object Object]', ANNOUNCEMENT_DESC: '[object Object]', RESOURCE_ASC: '[object Object]', RESOURCE_DESC: '[object Object]', BADGES_ASC: '[object Object]', BADGES_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', IS_COMPLETED_ASC: '[object Object]', IS_COMPLETED_DESC: '[object Object]', SPEAKERS_ASC: '[object Object]', SPEAKERS_DESC: '[object Object]', FIELD_TRIPS_ASC: '[object Object]', FIELD_TRIPS_DESC: '[object Object]', ASSIGNMENTS_ASC: '[object Object]', ASSIGNMENTS_DESC: '[object Object]', ASSIGNMENTS_DUE_DATE_ASC: '[object Object]', ASSIGNMENTS_DUE_DATE_DESC: '[object Object]', ORIGANALITY_REPORT_ASC: '[object Object]', ORIGANALITY_REPORT_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', FAQS_ASC: '[object Object]', FAQS_DESC: '[object Object]', LANGUAGES_ASC: '[object Object]', LANGUAGES_DESC: '[object Object]', CHECKLISTS_ASC: '[object Object]', CHECKLISTS_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', MEETUPS_ASC: '[object Object]', MEETUPS_DESC: '[object Object]', LAB_ASC: '[object Object]', LAB_DESC: '[object Object]', DIGIBOARDS_ASC: '[object Object]', DIGIBOARDS_DESC: '[object Object]', COUNTRIES_ASC: '[object Object]', COUNTRIES_DESC: '[object Object]', STATES_ASC: '[object Object]', STATES_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type TransactionsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionsConnection'] = ResolversParentTypes['TransactionsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Transaction']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TransactionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransactionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Transaction'] = ResolversParentTypes['Transaction']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  orderId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  transactionId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  parentTransactionId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  paymentMethod?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  closed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerPayment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orders?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransactionsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionsEdge'] = ResolversParentTypes['TransactionsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TransactionsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', ORDER_ID_ASC: '[object Object]', ORDER_ID_DESC: '[object Object]', TRANSACTION_ID_ASC: '[object Object]', TRANSACTION_ID_DESC: '[object Object]', PARENT_TRANSACTION_ID_ASC: '[object Object]', PARENT_TRANSACTION_ID_DESC: '[object Object]', CREATED_ASC: '[object Object]', CREATED_DESC: '[object Object]', PAYMENT_METHOD_ASC: '[object Object]', PAYMENT_METHOD_DESC: '[object Object]', CLOSED_ASC: '[object Object]', CLOSED_DESC: '[object Object]', CUSTOMER_PAYMENT_ASC: '[object Object]', CUSTOMER_PAYMENT_DESC: '[object Object]', ORDERS_ASC: '[object Object]', ORDERS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type UploadFilesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UploadFilesConnection'] = ResolversParentTypes['UploadFilesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['UploadFile']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['UploadFilesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UploadFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UploadFile'] = ResolversParentTypes['UploadFile']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  alternativeText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  width?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  height?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  formats?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ext?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mime?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  size?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  previewUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  providerMetadata?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedBy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UploadFilesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UploadFilesEdge'] = ResolversParentTypes['UploadFilesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UploadFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UploadFilesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', ALTERNATIVE_TEXT_ASC: '[object Object]', ALTERNATIVE_TEXT_DESC: '[object Object]', CAPTION_ASC: '[object Object]', CAPTION_DESC: '[object Object]', WIDTH_ASC: '[object Object]', WIDTH_DESC: '[object Object]', HEIGHT_ASC: '[object Object]', HEIGHT_DESC: '[object Object]', FORMATS_ASC: '[object Object]', FORMATS_DESC: '[object Object]', HASH_ASC: '[object Object]', HASH_DESC: '[object Object]', EXT_ASC: '[object Object]', EXT_DESC: '[object Object]', MIME_ASC: '[object Object]', MIME_DESC: '[object Object]', SIZE_ASC: '[object Object]', SIZE_DESC: '[object Object]', URL_ASC: '[object Object]', URL_DESC: '[object Object]', PREVIEW_URL_ASC: '[object Object]', PREVIEW_URL_DESC: '[object Object]', PROVIDER_ASC: '[object Object]', PROVIDER_DESC: '[object Object]', PROVIDER_METADATA_ASC: '[object Object]', PROVIDER_METADATA_DESC: '[object Object]', CREATED_BY_ASC: '[object Object]', CREATED_BY_DESC: '[object Object]', UPDATED_BY_ASC: '[object Object]', UPDATED_BY_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', UPDATED_AT_ASC: '[object Object]', UPDATED_AT_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type UsersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UsersConnection'] = ResolversParentTypes['UsersConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['User']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['UsersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  password?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  interfaceLocale?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  emails?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projects?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UsersEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UsersEdge'] = ResolversParentTypes['UsersEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UsersOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', USERNAME_ASC: '[object Object]', USERNAME_DESC: '[object Object]', FIRST_NAME_ASC: '[object Object]', FIRST_NAME_DESC: '[object Object]', LAST_NAME_ASC: '[object Object]', LAST_NAME_DESC: '[object Object]', EMAIL_ASC: '[object Object]', EMAIL_DESC: '[object Object]', PASSWORD_ASC: '[object Object]', PASSWORD_DESC: '[object Object]', INTERFACE_LOCALE_ASC: '[object Object]', INTERFACE_LOCALE_DESC: '[object Object]', VALUE_ASC: '[object Object]', VALUE_DESC: '[object Object]', PERMISSIONS_ASC: '[object Object]', PERMISSIONS_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', EMAILS_ASC: '[object Object]', EMAILS_DESC: '[object Object]', MEDIAMANAGER_ASC: '[object Object]', MEDIAMANAGER_DESC: '[object Object]', MESSAGES_ASC: '[object Object]', MESSAGES_DESC: '[object Object]', PROJECTS_ASC: '[object Object]', PROJECTS_DESC: '[object Object]', WORKSPACES_ASC: '[object Object]', WORKSPACES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type VendorsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VendorsConnection'] = ResolversParentTypes['VendorsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Vendor']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['VendorsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VendorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Vendor'] = ResolversParentTypes['Vendor']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  articles?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comments?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coupons?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  polls?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quotes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviews?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  giftCertificates?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rating?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invoices?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rewardPoints?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  specialDiscounts?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stocks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  physicalStore?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VendorsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VendorsEdge'] = ResolversParentTypes['VendorsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Vendor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VendorsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', WEBSITE_ASC: '[object Object]', WEBSITE_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', ARTICLES_ASC: '[object Object]', ARTICLES_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', COMMENTS_ASC: '[object Object]', COMMENTS_DESC: '[object Object]', COUPONS_ASC: '[object Object]', COUPONS_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', POLLS_ASC: '[object Object]', POLLS_DESC: '[object Object]', QUOTES_ASC: '[object Object]', QUOTES_DESC: '[object Object]', REVIEWS_ASC: '[object Object]', REVIEWS_DESC: '[object Object]', GIFT_CERTIFICATES_ASC: '[object Object]', GIFT_CERTIFICATES_DESC: '[object Object]', RATING_ASC: '[object Object]', RATING_DESC: '[object Object]', TAGS_ASC: '[object Object]', TAGS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', INVOICES_ASC: '[object Object]', INVOICES_DESC: '[object Object]', REPORTS_ASC: '[object Object]', REPORTS_DESC: '[object Object]', REWARD_POINTS_ASC: '[object Object]', REWARD_POINTS_DESC: '[object Object]', SPECIAL_DISCOUNTS_ASC: '[object Object]', SPECIAL_DISCOUNTS_DESC: '[object Object]', STATISTICS_ASC: '[object Object]', STATISTICS_DESC: '[object Object]', STOCKS_ASC: '[object Object]', STOCKS_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', PHYSICAL_STORE_ASC: '[object Object]', PHYSICAL_STORE_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', WORKSPACES_ASC: '[object Object]', WORKSPACES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type VisitsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VisitsConnection'] = ResolversParentTypes['VisitsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Visit']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['VisitsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VisitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Visit'] = ResolversParentTypes['Visit']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emergency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  task?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  meeting?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VisitsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VisitsEdge'] = ResolversParentTypes['VisitsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Visit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VisitsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', LOCATION_ASC: '[object Object]', LOCATION_DESC: '[object Object]', USERNAME_ASC: '[object Object]', USERNAME_DESC: '[object Object]', REASON_ASC: '[object Object]', REASON_DESC: '[object Object]', CONTENT_ASC: '[object Object]', CONTENT_DESC: '[object Object]', EMERGENCY_ASC: '[object Object]', EMERGENCY_DESC: '[object Object]', START_DATE_ASC: '[object Object]', START_DATE_DESC: '[object Object]', END_DATE_ASC: '[object Object]', END_DATE_DESC: '[object Object]', TASK_ASC: '[object Object]', TASK_DESC: '[object Object]', MEETING_ASC: '[object Object]', MEETING_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type WarehousesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WarehousesConnection'] = ResolversParentTypes['WarehousesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Warehouse']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['WarehousesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WarehouseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Warehouse'] = ResolversParentTypes['Warehouse']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WarehousesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WarehousesEdge'] = ResolversParentTypes['WarehousesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WarehousesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', CITY_ASC: '[object Object]', CITY_DESC: '[object Object]', STATE_ASC: '[object Object]', STATE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', POSTAL_ASC: '[object Object]', POSTAL_DESC: '[object Object]', STATUS_ASC: '[object Object]', STATUS_DESC: '[object Object]', IMAGE_ASC: '[object Object]', IMAGE_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', CATEGORY_ASC: '[object Object]', CATEGORY_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type WebhooksConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WebhooksConnection'] = ResolversParentTypes['WebhooksConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Webhook']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['WebhooksEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WebhookResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Webhook'] = ResolversParentTypes['Webhook']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  create?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  retrieve?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  update?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  delete?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publish?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unpublish?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WebhooksEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WebhooksEdge'] = ResolversParentTypes['WebhooksEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WebhooksOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', URL_ASC: '[object Object]', URL_DESC: '[object Object]', HEADERS_ASC: '[object Object]', HEADERS_DESC: '[object Object]', CREATE_ASC: '[object Object]', CREATE_DESC: '[object Object]', RETRIEVE_ASC: '[object Object]', RETRIEVE_DESC: '[object Object]', UPDATE_ASC: '[object Object]', UPDATE_DESC: '[object Object]', DELETE_ASC: '[object Object]', DELETE_DESC: '[object Object]', PUBLISH_ASC: '[object Object]', PUBLISH_DESC: '[object Object]', UNPUBLISH_ASC: '[object Object]', UNPUBLISH_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type WebsitesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WebsitesConnection'] = ResolversParentTypes['WebsitesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Website']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['WebsitesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WebsiteResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Website'] = ResolversParentTypes['Website']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shop?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  store?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  themes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WebsitesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WebsitesEdge'] = ResolversParentTypes['WebsitesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Website']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WebsitesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', URL_ASC: '[object Object]', URL_DESC: '[object Object]', SHOP_ASC: '[object Object]', SHOP_DESC: '[object Object]', STORE_ASC: '[object Object]', STORE_DESC: '[object Object]', CATEGORY_ASC: '[object Object]', CATEGORY_DESC: '[object Object]', THEMES_ASC: '[object Object]', THEMES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type WishlistsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WishlistsConnection'] = ResolversParentTypes['WishlistsConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Wishlist']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['WishlistsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WishlistResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Wishlist'] = ResolversParentTypes['Wishlist']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  occassions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WishlistsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WishlistsEdge'] = ResolversParentTypes['WishlistsEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Wishlist']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WishlistsOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', VISIBILITY_ASC: '[object Object]', VISIBILITY_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', QUANTITY_ASC: '[object Object]', QUANTITY_DESC: '[object Object]', OCCASSIONS_ASC: '[object Object]', OCCASSIONS_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type WorkspacesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WorkspacesConnection'] = ResolversParentTypes['WorkspacesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Workspace']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['WorkspacesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkspaceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Workspace'] = ResolversParentTypes['Workspace']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customers?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  tasks?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  brands?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  shops?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  isPublic?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  projects?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brandsBrandsToworkspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customersCustomersToworkspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productsProductsToworkspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectsProjectsToworkspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shopsShopsToworkspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tasksTasksToworkspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  usersUsersToworkspaces?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkspacesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['WorkspacesEdge'] = ResolversParentTypes['WorkspacesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkspacesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', CODE_ASC: '[object Object]', CODE_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', DESCRIPTION_ASC: '[object Object]', DESCRIPTION_DESC: '[object Object]', CUSTOMERS_ASC: '[object Object]', CUSTOMERS_DESC: '[object Object]', USERS_ASC: '[object Object]', USERS_DESC: '[object Object]', PRODUCTS_ASC: '[object Object]', PRODUCTS_DESC: '[object Object]', TASKS_ASC: '[object Object]', TASKS_DESC: '[object Object]', BRANDS_ASC: '[object Object]', BRANDS_DESC: '[object Object]', SHOPS_ASC: '[object Object]', SHOPS_DESC: '[object Object]', CATEGORY_ASC: '[object Object]', CATEGORY_DESC: '[object Object]', IS_PUBLIC_ASC: '[object Object]', IS_PUBLIC_DESC: '[object Object]', PROJECTS_ASC: '[object Object]', PROJECTS_DESC: '[object Object]', AUTHOR_ASC: '[object Object]', AUTHOR_DESC: '[object Object]', MEDIA_ASC: '[object Object]', MEDIA_DESC: '[object Object]', BRANDS_BRANDS_TOWORKSPACES_ASC: '[object Object]', BRANDS_BRANDS_TOWORKSPACES_DESC: '[object Object]', CATEGORIES_ASC: '[object Object]', CATEGORIES_DESC: '[object Object]', CUSTOMERS_CUSTOMERS_TOWORKSPACES_ASC: '[object Object]', CUSTOMERS_CUSTOMERS_TOWORKSPACES_DESC: '[object Object]', PRODUCTS_PRODUCTS_TOWORKSPACES_ASC: '[object Object]', PRODUCTS_PRODUCTS_TOWORKSPACES_DESC: '[object Object]', PROJECTS_PROJECTS_TOWORKSPACES_ASC: '[object Object]', PROJECTS_PROJECTS_TOWORKSPACES_DESC: '[object Object]', SHOPS_SHOPS_TOWORKSPACES_ASC: '[object Object]', SHOPS_SHOPS_TOWORKSPACES_DESC: '[object Object]', TASKS_TASKS_TOWORKSPACES_ASC: '[object Object]', TASKS_TASKS_TOWORKSPACES_DESC: '[object Object]', USERS_USERS_TOWORKSPACES_ASC: '[object Object]', USERS_USERS_TOWORKSPACES_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type ZonesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ZonesConnection'] = ResolversParentTypes['ZonesConnection']> = ResolversObject<{
  nodes?: Resolver<Array<Maybe<ResolversTypes['Zone']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ZonesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ZoneResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Zone'] = ResolversParentTypes['Zone']> = ResolversObject<{
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  scope?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ZonesEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ZonesEdge'] = ResolversParentTypes['ZonesEdge']> = ResolversObject<{
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ZonesOrderByResolvers = { NATURAL: '[object Object]', ID_ASC: '[object Object]', ID_DESC: '[object Object]', CREATED_AT_ASC: '[object Object]', CREATED_AT_DESC: '[object Object]', NAME_ASC: '[object Object]', NAME_DESC: '[object Object]', UPDATED_AT_ASC: '[object Object]', UPDATED_AT_DESC: '[object Object]', SCOPE_ASC: '[object Object]', SCOPE_DESC: '[object Object]', TYPE_ASC: '[object Object]', TYPE_DESC: '[object Object]', COUNTRY_ASC: '[object Object]', COUNTRY_DESC: '[object Object]', CODE_ASC: '[object Object]', CODE_DESC: '[object Object]', PRIMARY_KEY_ASC: '[object Object]', PRIMARY_KEY_DESC: '[object Object]' };

export type MutationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
  createAccount?: Resolver<Maybe<ResolversTypes['CreateAccountPayload']>, ParentType, ContextType, RequireFields<MutationcreateAccountArgs, 'input'>>;
  createAgreement?: Resolver<Maybe<ResolversTypes['CreateAgreementPayload']>, ParentType, ContextType, RequireFields<MutationcreateAgreementArgs, 'input'>>;
  createAnalytic?: Resolver<Maybe<ResolversTypes['CreateAnalyticPayload']>, ParentType, ContextType, RequireFields<MutationcreateAnalyticArgs, 'input'>>;
  createApitoken?: Resolver<Maybe<ResolversTypes['CreateApitokenPayload']>, ParentType, ContextType, RequireFields<MutationcreateApitokenArgs, 'input'>>;
  createArticle?: Resolver<Maybe<ResolversTypes['CreateArticlePayload']>, ParentType, ContextType, RequireFields<MutationcreateArticleArgs, 'input'>>;
  createAttribute?: Resolver<Maybe<ResolversTypes['CreateAttributePayload']>, ParentType, ContextType, RequireFields<MutationcreateAttributeArgs, 'input'>>;
  createBrand?: Resolver<Maybe<ResolversTypes['CreateBrandPayload']>, ParentType, ContextType, RequireFields<MutationcreateBrandArgs, 'input'>>;
  createCartPriceRule?: Resolver<Maybe<ResolversTypes['CreateCartPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationcreateCartPriceRuleArgs, 'input'>>;
  createCase?: Resolver<Maybe<ResolversTypes['CreateCasePayload']>, ParentType, ContextType, RequireFields<MutationcreateCaseArgs, 'input'>>;
  createCatalogPriceRule?: Resolver<Maybe<ResolversTypes['CreateCatalogPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationcreateCatalogPriceRuleArgs, 'input'>>;
  createCategory?: Resolver<Maybe<ResolversTypes['CreateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationcreateCategoryArgs, 'input'>>;
  createChannel?: Resolver<Maybe<ResolversTypes['CreateChannelPayload']>, ParentType, ContextType, RequireFields<MutationcreateChannelArgs, 'input'>>;
  createChecklist?: Resolver<Maybe<ResolversTypes['CreateChecklistPayload']>, ParentType, ContextType, RequireFields<MutationcreateChecklistArgs, 'input'>>;
  createCity?: Resolver<Maybe<ResolversTypes['CreateCityPayload']>, ParentType, ContextType, RequireFields<MutationcreateCityArgs, 'input'>>;
  createCollection?: Resolver<Maybe<ResolversTypes['CreateCollectionPayload']>, ParentType, ContextType, RequireFields<MutationcreateCollectionArgs, 'input'>>;
  createComment?: Resolver<Maybe<ResolversTypes['CreateCommentPayload']>, ParentType, ContextType, RequireFields<MutationcreateCommentArgs, 'input'>>;
  createContentType?: Resolver<Maybe<ResolversTypes['CreateContentTypePayload']>, ParentType, ContextType, RequireFields<MutationcreateContentTypeArgs, 'input'>>;
  createContract?: Resolver<Maybe<ResolversTypes['CreateContractPayload']>, ParentType, ContextType, RequireFields<MutationcreateContractArgs, 'input'>>;
  createCountry?: Resolver<Maybe<ResolversTypes['CreateCountryPayload']>, ParentType, ContextType, RequireFields<MutationcreateCountryArgs, 'input'>>;
  createCoupon?: Resolver<Maybe<ResolversTypes['CreateCouponPayload']>, ParentType, ContextType, RequireFields<MutationcreateCouponArgs, 'input'>>;
  createCreditMemo?: Resolver<Maybe<ResolversTypes['CreateCreditMemoPayload']>, ParentType, ContextType, RequireFields<MutationcreateCreditMemoArgs, 'input'>>;
  createCurrency?: Resolver<Maybe<ResolversTypes['CreateCurrencyPayload']>, ParentType, ContextType, RequireFields<MutationcreateCurrencyArgs, 'input'>>;
  createCurrencyRate?: Resolver<Maybe<ResolversTypes['CreateCurrencyRatePayload']>, ParentType, ContextType, RequireFields<MutationcreateCurrencyRateArgs, 'input'>>;
  createCurrencySymbol?: Resolver<Maybe<ResolversTypes['CreateCurrencySymbolPayload']>, ParentType, ContextType, RequireFields<MutationcreateCurrencySymbolArgs, 'input'>>;
  createCustomerGroup?: Resolver<Maybe<ResolversTypes['CreateCustomerGroupPayload']>, ParentType, ContextType, RequireFields<MutationcreateCustomerGroupArgs, 'input'>>;
  createCustomer?: Resolver<Maybe<ResolversTypes['CreateCustomerPayload']>, ParentType, ContextType, RequireFields<MutationcreateCustomerArgs, 'input'>>;
  createCustomization?: Resolver<Maybe<ResolversTypes['CreateCustomizationPayload']>, ParentType, ContextType, RequireFields<MutationcreateCustomizationArgs, 'input'>>;
  createDashboard?: Resolver<Maybe<ResolversTypes['CreateDashboardPayload']>, ParentType, ContextType, RequireFields<MutationcreateDashboardArgs, 'input'>>;
  createDeepdive?: Resolver<Maybe<ResolversTypes['CreateDeepdivePayload']>, ParentType, ContextType, RequireFields<MutationcreateDeepdiveArgs, 'input'>>;
  createDigiboard?: Resolver<Maybe<ResolversTypes['CreateDigiboardPayload']>, ParentType, ContextType, RequireFields<MutationcreateDigiboardArgs, 'input'>>;
  createEmail?: Resolver<Maybe<ResolversTypes['CreateEmailPayload']>, ParentType, ContextType, RequireFields<MutationcreateEmailArgs, 'input'>>;
  createEndofshift?: Resolver<Maybe<ResolversTypes['CreateEndofshiftPayload']>, ParentType, ContextType, RequireFields<MutationcreateEndofshiftArgs, 'input'>>;
  createEvent?: Resolver<Maybe<ResolversTypes['CreateEventPayload']>, ParentType, ContextType, RequireFields<MutationcreateEventArgs, 'input'>>;
  createFullfillment?: Resolver<Maybe<ResolversTypes['CreateFullfillmentPayload']>, ParentType, ContextType, RequireFields<MutationcreateFullfillmentArgs, 'input'>>;
  createGiftCertificate?: Resolver<Maybe<ResolversTypes['CreateGiftCertificatePayload']>, ParentType, ContextType, RequireFields<MutationcreateGiftCertificateArgs, 'input'>>;
  createGlossary?: Resolver<Maybe<ResolversTypes['CreateGlossaryPayload']>, ParentType, ContextType, RequireFields<MutationcreateGlossaryArgs, 'input'>>;
  createImportm?: Resolver<Maybe<ResolversTypes['CreateImportmPayload']>, ParentType, ContextType, RequireFields<MutationcreateImportmArgs, 'input'>>;
  createIntegration?: Resolver<Maybe<ResolversTypes['CreateIntegrationPayload']>, ParentType, ContextType, RequireFields<MutationcreateIntegrationArgs, 'input'>>;
  createInternalization?: Resolver<Maybe<ResolversTypes['CreateInternalizationPayload']>, ParentType, ContextType, RequireFields<MutationcreateInternalizationArgs, 'input'>>;
  createInvitation?: Resolver<Maybe<ResolversTypes['CreateInvitationPayload']>, ParentType, ContextType, RequireFields<MutationcreateInvitationArgs, 'input'>>;
  createInvoice?: Resolver<Maybe<ResolversTypes['CreateInvoicePayload']>, ParentType, ContextType, RequireFields<MutationcreateInvoiceArgs, 'input'>>;
  createLead?: Resolver<Maybe<ResolversTypes['CreateLeadPayload']>, ParentType, ContextType, RequireFields<MutationcreateLeadArgs, 'input'>>;
  createManufacturer?: Resolver<Maybe<ResolversTypes['CreateManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationcreateManufacturerArgs, 'input'>>;
  createMediamanager?: Resolver<Maybe<ResolversTypes['CreateMediamanagerPayload']>, ParentType, ContextType, RequireFields<MutationcreateMediamanagerArgs, 'input'>>;
  createMeeting?: Resolver<Maybe<ResolversTypes['CreateMeetingPayload']>, ParentType, ContextType, RequireFields<MutationcreateMeetingArgs, 'input'>>;
  createMessage?: Resolver<Maybe<ResolversTypes['CreateMessagePayload']>, ParentType, ContextType, RequireFields<MutationcreateMessageArgs, 'input'>>;
  createNewsletter?: Resolver<Maybe<ResolversTypes['CreateNewsletterPayload']>, ParentType, ContextType, RequireFields<MutationcreateNewsletterArgs, 'input'>>;
  createOoto?: Resolver<Maybe<ResolversTypes['CreateOotoPayload']>, ParentType, ContextType, RequireFields<MutationcreateOotoArgs, 'input'>>;
  createOpportunity?: Resolver<Maybe<ResolversTypes['CreateOpportunityPayload']>, ParentType, ContextType, RequireFields<MutationcreateOpportunityArgs, 'input'>>;
  createOrder?: Resolver<Maybe<ResolversTypes['CreateOrderPayload']>, ParentType, ContextType, RequireFields<MutationcreateOrderArgs, 'input'>>;
  createPage?: Resolver<Maybe<ResolversTypes['CreatePagePayload']>, ParentType, ContextType, RequireFields<MutationcreatePageArgs, 'input'>>;
  createPartner?: Resolver<Maybe<ResolversTypes['CreatePartnerPayload']>, ParentType, ContextType, RequireFields<MutationcreatePartnerArgs, 'input'>>;
  createPayment?: Resolver<Maybe<ResolversTypes['CreatePaymentPayload']>, ParentType, ContextType, RequireFields<MutationcreatePaymentArgs, 'input'>>;
  createPermission?: Resolver<Maybe<ResolversTypes['CreatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationcreatePermissionArgs, 'input'>>;
  createPlugin?: Resolver<Maybe<ResolversTypes['CreatePluginPayload']>, ParentType, ContextType, RequireFields<MutationcreatePluginArgs, 'input'>>;
  createPoll?: Resolver<Maybe<ResolversTypes['CreatePollPayload']>, ParentType, ContextType, RequireFields<MutationcreatePollArgs, 'input'>>;
  createProductType?: Resolver<Maybe<ResolversTypes['CreateProductTypePayload']>, ParentType, ContextType, RequireFields<MutationcreateProductTypeArgs, 'input'>>;
  createProduct?: Resolver<Maybe<ResolversTypes['CreateProductPayload']>, ParentType, ContextType, RequireFields<MutationcreateProductArgs, 'input'>>;
  createProject?: Resolver<Maybe<ResolversTypes['CreateProjectPayload']>, ParentType, ContextType, RequireFields<MutationcreateProjectArgs, 'input'>>;
  createProvider?: Resolver<Maybe<ResolversTypes['CreateProviderPayload']>, ParentType, ContextType, RequireFields<MutationcreateProviderArgs, 'input'>>;
  createQuote?: Resolver<Maybe<ResolversTypes['CreateQuotePayload']>, ParentType, ContextType, RequireFields<MutationcreateQuoteArgs, 'input'>>;
  createRating?: Resolver<Maybe<ResolversTypes['CreateRatingPayload']>, ParentType, ContextType, RequireFields<MutationcreateRatingArgs, 'input'>>;
  createReport?: Resolver<Maybe<ResolversTypes['CreateReportPayload']>, ParentType, ContextType, RequireFields<MutationcreateReportArgs, 'input'>>;
  createReturn?: Resolver<Maybe<ResolversTypes['CreateReturnPayload']>, ParentType, ContextType, RequireFields<MutationcreateReturnArgs, 'input'>>;
  createReview?: Resolver<Maybe<ResolversTypes['CreateReviewPayload']>, ParentType, ContextType, RequireFields<MutationcreateReviewArgs, 'input'>>;
  createReward?: Resolver<Maybe<ResolversTypes['CreateRewardPayload']>, ParentType, ContextType, RequireFields<MutationcreateRewardArgs, 'input'>>;
  createRole?: Resolver<Maybe<ResolversTypes['CreateRolePayload']>, ParentType, ContextType, RequireFields<MutationcreateRoleArgs, 'input'>>;
  createScheduler?: Resolver<Maybe<ResolversTypes['CreateSchedulerPayload']>, ParentType, ContextType, RequireFields<MutationcreateSchedulerArgs, 'input'>>;
  createSegment?: Resolver<Maybe<ResolversTypes['CreateSegmentPayload']>, ParentType, ContextType, RequireFields<MutationcreateSegmentArgs, 'input'>>;
  createSetting?: Resolver<Maybe<ResolversTypes['CreateSettingPayload']>, ParentType, ContextType, RequireFields<MutationcreateSettingArgs, 'input'>>;
  createShipment?: Resolver<Maybe<ResolversTypes['CreateShipmentPayload']>, ParentType, ContextType, RequireFields<MutationcreateShipmentArgs, 'input'>>;
  createSpecialDiscount?: Resolver<Maybe<ResolversTypes['CreateSpecialDiscountPayload']>, ParentType, ContextType, RequireFields<MutationcreateSpecialDiscountArgs, 'input'>>;
  createState?: Resolver<Maybe<ResolversTypes['CreateStatePayload']>, ParentType, ContextType, RequireFields<MutationcreateStateArgs, 'input'>>;
  createStatistic?: Resolver<Maybe<ResolversTypes['CreateStatisticPayload']>, ParentType, ContextType, RequireFields<MutationcreateStatisticArgs, 'input'>>;
  createStock?: Resolver<Maybe<ResolversTypes['CreateStockPayload']>, ParentType, ContextType, RequireFields<MutationcreateStockArgs, 'input'>>;
  createSurvey?: Resolver<Maybe<ResolversTypes['CreateSurveyPayload']>, ParentType, ContextType, RequireFields<MutationcreateSurveyArgs, 'input'>>;
  createTag?: Resolver<Maybe<ResolversTypes['CreateTagPayload']>, ParentType, ContextType, RequireFields<MutationcreateTagArgs, 'input'>>;
  createTarget?: Resolver<Maybe<ResolversTypes['CreateTargetPayload']>, ParentType, ContextType, RequireFields<MutationcreateTargetArgs, 'input'>>;
  createTaxCategory?: Resolver<Maybe<ResolversTypes['CreateTaxCategoryPayload']>, ParentType, ContextType, RequireFields<MutationcreateTaxCategoryArgs, 'input'>>;
  createTaxRate?: Resolver<Maybe<ResolversTypes['CreateTaxRatePayload']>, ParentType, ContextType, RequireFields<MutationcreateTaxRateArgs, 'input'>>;
  createTaxRule?: Resolver<Maybe<ResolversTypes['CreateTaxRulePayload']>, ParentType, ContextType, RequireFields<MutationcreateTaxRuleArgs, 'input'>>;
  createTemplate?: Resolver<Maybe<ResolversTypes['CreateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationcreateTemplateArgs, 'input'>>;
  createTheme?: Resolver<Maybe<ResolversTypes['CreateThemePayload']>, ParentType, ContextType, RequireFields<MutationcreateThemeArgs, 'input'>>;
  createTicketing?: Resolver<Maybe<ResolversTypes['CreateTicketingPayload']>, ParentType, ContextType, RequireFields<MutationcreateTicketingArgs, 'input'>>;
  createTraining?: Resolver<Maybe<ResolversTypes['CreateTrainingPayload']>, ParentType, ContextType, RequireFields<MutationcreateTrainingArgs, 'input'>>;
  createTransaction?: Resolver<Maybe<ResolversTypes['CreateTransactionPayload']>, ParentType, ContextType, RequireFields<MutationcreateTransactionArgs, 'input'>>;
  createUploadFile?: Resolver<Maybe<ResolversTypes['CreateUploadFilePayload']>, ParentType, ContextType, RequireFields<MutationcreateUploadFileArgs, 'input'>>;
  createUser?: Resolver<Maybe<ResolversTypes['CreateUserPayload']>, ParentType, ContextType, RequireFields<MutationcreateUserArgs, 'input'>>;
  createVendor?: Resolver<Maybe<ResolversTypes['CreateVendorPayload']>, ParentType, ContextType, RequireFields<MutationcreateVendorArgs, 'input'>>;
  createVisit?: Resolver<Maybe<ResolversTypes['CreateVisitPayload']>, ParentType, ContextType, RequireFields<MutationcreateVisitArgs, 'input'>>;
  createWarehouse?: Resolver<Maybe<ResolversTypes['CreateWarehousePayload']>, ParentType, ContextType, RequireFields<MutationcreateWarehouseArgs, 'input'>>;
  createWebhook?: Resolver<Maybe<ResolversTypes['CreateWebhookPayload']>, ParentType, ContextType, RequireFields<MutationcreateWebhookArgs, 'input'>>;
  createWebsite?: Resolver<Maybe<ResolversTypes['CreateWebsitePayload']>, ParentType, ContextType, RequireFields<MutationcreateWebsiteArgs, 'input'>>;
  createWishlist?: Resolver<Maybe<ResolversTypes['CreateWishlistPayload']>, ParentType, ContextType, RequireFields<MutationcreateWishlistArgs, 'input'>>;
  createWorkspace?: Resolver<Maybe<ResolversTypes['CreateWorkspacePayload']>, ParentType, ContextType, RequireFields<MutationcreateWorkspaceArgs, 'input'>>;
  createZone?: Resolver<Maybe<ResolversTypes['CreateZonePayload']>, ParentType, ContextType, RequireFields<MutationcreateZoneArgs, 'input'>>;
  updateAccount?: Resolver<Maybe<ResolversTypes['UpdateAccountPayload']>, ParentType, ContextType, RequireFields<MutationupdateAccountArgs, 'input'>>;
  updateAccountById?: Resolver<Maybe<ResolversTypes['UpdateAccountPayload']>, ParentType, ContextType, RequireFields<MutationupdateAccountByIdArgs, 'input'>>;
  updateAgreement?: Resolver<Maybe<ResolversTypes['UpdateAgreementPayload']>, ParentType, ContextType, RequireFields<MutationupdateAgreementArgs, 'input'>>;
  updateAgreementById?: Resolver<Maybe<ResolversTypes['UpdateAgreementPayload']>, ParentType, ContextType, RequireFields<MutationupdateAgreementByIdArgs, 'input'>>;
  updateAnalytic?: Resolver<Maybe<ResolversTypes['UpdateAnalyticPayload']>, ParentType, ContextType, RequireFields<MutationupdateAnalyticArgs, 'input'>>;
  updateAnalyticById?: Resolver<Maybe<ResolversTypes['UpdateAnalyticPayload']>, ParentType, ContextType, RequireFields<MutationupdateAnalyticByIdArgs, 'input'>>;
  updateApitoken?: Resolver<Maybe<ResolversTypes['UpdateApitokenPayload']>, ParentType, ContextType, RequireFields<MutationupdateApitokenArgs, 'input'>>;
  updateApitokenById?: Resolver<Maybe<ResolversTypes['UpdateApitokenPayload']>, ParentType, ContextType, RequireFields<MutationupdateApitokenByIdArgs, 'input'>>;
  updateArticle?: Resolver<Maybe<ResolversTypes['UpdateArticlePayload']>, ParentType, ContextType, RequireFields<MutationupdateArticleArgs, 'input'>>;
  updateArticleById?: Resolver<Maybe<ResolversTypes['UpdateArticlePayload']>, ParentType, ContextType, RequireFields<MutationupdateArticleByIdArgs, 'input'>>;
  updateAttribute?: Resolver<Maybe<ResolversTypes['UpdateAttributePayload']>, ParentType, ContextType, RequireFields<MutationupdateAttributeArgs, 'input'>>;
  updateAttributeById?: Resolver<Maybe<ResolversTypes['UpdateAttributePayload']>, ParentType, ContextType, RequireFields<MutationupdateAttributeByIdArgs, 'input'>>;
  updateBrand?: Resolver<Maybe<ResolversTypes['UpdateBrandPayload']>, ParentType, ContextType, RequireFields<MutationupdateBrandArgs, 'input'>>;
  updateBrandById?: Resolver<Maybe<ResolversTypes['UpdateBrandPayload']>, ParentType, ContextType, RequireFields<MutationupdateBrandByIdArgs, 'input'>>;
  updateCartPriceRule?: Resolver<Maybe<ResolversTypes['UpdateCartPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationupdateCartPriceRuleArgs, 'input'>>;
  updateCartPriceRuleById?: Resolver<Maybe<ResolversTypes['UpdateCartPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationupdateCartPriceRuleByIdArgs, 'input'>>;
  updateCase?: Resolver<Maybe<ResolversTypes['UpdateCasePayload']>, ParentType, ContextType, RequireFields<MutationupdateCaseArgs, 'input'>>;
  updateCaseById?: Resolver<Maybe<ResolversTypes['UpdateCasePayload']>, ParentType, ContextType, RequireFields<MutationupdateCaseByIdArgs, 'input'>>;
  updateCatalogPriceRule?: Resolver<Maybe<ResolversTypes['UpdateCatalogPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationupdateCatalogPriceRuleArgs, 'input'>>;
  updateCatalogPriceRuleById?: Resolver<Maybe<ResolversTypes['UpdateCatalogPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationupdateCatalogPriceRuleByIdArgs, 'input'>>;
  updateCategory?: Resolver<Maybe<ResolversTypes['UpdateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationupdateCategoryArgs, 'input'>>;
  updateCategoryById?: Resolver<Maybe<ResolversTypes['UpdateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationupdateCategoryByIdArgs, 'input'>>;
  updateChannel?: Resolver<Maybe<ResolversTypes['UpdateChannelPayload']>, ParentType, ContextType, RequireFields<MutationupdateChannelArgs, 'input'>>;
  updateChannelById?: Resolver<Maybe<ResolversTypes['UpdateChannelPayload']>, ParentType, ContextType, RequireFields<MutationupdateChannelByIdArgs, 'input'>>;
  updateChecklist?: Resolver<Maybe<ResolversTypes['UpdateChecklistPayload']>, ParentType, ContextType, RequireFields<MutationupdateChecklistArgs, 'input'>>;
  updateChecklistById?: Resolver<Maybe<ResolversTypes['UpdateChecklistPayload']>, ParentType, ContextType, RequireFields<MutationupdateChecklistByIdArgs, 'input'>>;
  updateCity?: Resolver<Maybe<ResolversTypes['UpdateCityPayload']>, ParentType, ContextType, RequireFields<MutationupdateCityArgs, 'input'>>;
  updateCityById?: Resolver<Maybe<ResolversTypes['UpdateCityPayload']>, ParentType, ContextType, RequireFields<MutationupdateCityByIdArgs, 'input'>>;
  updateCollection?: Resolver<Maybe<ResolversTypes['UpdateCollectionPayload']>, ParentType, ContextType, RequireFields<MutationupdateCollectionArgs, 'input'>>;
  updateCollectionById?: Resolver<Maybe<ResolversTypes['UpdateCollectionPayload']>, ParentType, ContextType, RequireFields<MutationupdateCollectionByIdArgs, 'input'>>;
  updateComment?: Resolver<Maybe<ResolversTypes['UpdateCommentPayload']>, ParentType, ContextType, RequireFields<MutationupdateCommentArgs, 'input'>>;
  updateCommentById?: Resolver<Maybe<ResolversTypes['UpdateCommentPayload']>, ParentType, ContextType, RequireFields<MutationupdateCommentByIdArgs, 'input'>>;
  updateContentType?: Resolver<Maybe<ResolversTypes['UpdateContentTypePayload']>, ParentType, ContextType, RequireFields<MutationupdateContentTypeArgs, 'input'>>;
  updateContentTypeById?: Resolver<Maybe<ResolversTypes['UpdateContentTypePayload']>, ParentType, ContextType, RequireFields<MutationupdateContentTypeByIdArgs, 'input'>>;
  updateContract?: Resolver<Maybe<ResolversTypes['UpdateContractPayload']>, ParentType, ContextType, RequireFields<MutationupdateContractArgs, 'input'>>;
  updateContractById?: Resolver<Maybe<ResolversTypes['UpdateContractPayload']>, ParentType, ContextType, RequireFields<MutationupdateContractByIdArgs, 'input'>>;
  updateCountry?: Resolver<Maybe<ResolversTypes['UpdateCountryPayload']>, ParentType, ContextType, RequireFields<MutationupdateCountryArgs, 'input'>>;
  updateCountryById?: Resolver<Maybe<ResolversTypes['UpdateCountryPayload']>, ParentType, ContextType, RequireFields<MutationupdateCountryByIdArgs, 'input'>>;
  updateCoupon?: Resolver<Maybe<ResolversTypes['UpdateCouponPayload']>, ParentType, ContextType, RequireFields<MutationupdateCouponArgs, 'input'>>;
  updateCouponById?: Resolver<Maybe<ResolversTypes['UpdateCouponPayload']>, ParentType, ContextType, RequireFields<MutationupdateCouponByIdArgs, 'input'>>;
  updateCreditMemo?: Resolver<Maybe<ResolversTypes['UpdateCreditMemoPayload']>, ParentType, ContextType, RequireFields<MutationupdateCreditMemoArgs, 'input'>>;
  updateCreditMemoByCreditMemoAndId?: Resolver<Maybe<ResolversTypes['UpdateCreditMemoPayload']>, ParentType, ContextType, RequireFields<MutationupdateCreditMemoByCreditMemoAndIdArgs, 'input'>>;
  updateCurrency?: Resolver<Maybe<ResolversTypes['UpdateCurrencyPayload']>, ParentType, ContextType, RequireFields<MutationupdateCurrencyArgs, 'input'>>;
  updateCurrencyById?: Resolver<Maybe<ResolversTypes['UpdateCurrencyPayload']>, ParentType, ContextType, RequireFields<MutationupdateCurrencyByIdArgs, 'input'>>;
  updateCurrencyRate?: Resolver<Maybe<ResolversTypes['UpdateCurrencyRatePayload']>, ParentType, ContextType, RequireFields<MutationupdateCurrencyRateArgs, 'input'>>;
  updateCurrencyRateByImportService?: Resolver<Maybe<ResolversTypes['UpdateCurrencyRatePayload']>, ParentType, ContextType, RequireFields<MutationupdateCurrencyRateByImportServiceArgs, 'input'>>;
  updateCurrencySymbol?: Resolver<Maybe<ResolversTypes['UpdateCurrencySymbolPayload']>, ParentType, ContextType, RequireFields<MutationupdateCurrencySymbolArgs, 'input'>>;
  updateCurrencySymbolBySymbol?: Resolver<Maybe<ResolversTypes['UpdateCurrencySymbolPayload']>, ParentType, ContextType, RequireFields<MutationupdateCurrencySymbolBySymbolArgs, 'input'>>;
  updateCustomerGroup?: Resolver<Maybe<ResolversTypes['UpdateCustomerGroupPayload']>, ParentType, ContextType, RequireFields<MutationupdateCustomerGroupArgs, 'input'>>;
  updateCustomerGroupById?: Resolver<Maybe<ResolversTypes['UpdateCustomerGroupPayload']>, ParentType, ContextType, RequireFields<MutationupdateCustomerGroupByIdArgs, 'input'>>;
  updateCustomer?: Resolver<Maybe<ResolversTypes['UpdateCustomerPayload']>, ParentType, ContextType, RequireFields<MutationupdateCustomerArgs, 'input'>>;
  updateCustomerById?: Resolver<Maybe<ResolversTypes['UpdateCustomerPayload']>, ParentType, ContextType, RequireFields<MutationupdateCustomerByIdArgs, 'input'>>;
  updateCustomization?: Resolver<Maybe<ResolversTypes['UpdateCustomizationPayload']>, ParentType, ContextType, RequireFields<MutationupdateCustomizationArgs, 'input'>>;
  updateCustomizationById?: Resolver<Maybe<ResolversTypes['UpdateCustomizationPayload']>, ParentType, ContextType, RequireFields<MutationupdateCustomizationByIdArgs, 'input'>>;
  updateDashboard?: Resolver<Maybe<ResolversTypes['UpdateDashboardPayload']>, ParentType, ContextType, RequireFields<MutationupdateDashboardArgs, 'input'>>;
  updateDashboardById?: Resolver<Maybe<ResolversTypes['UpdateDashboardPayload']>, ParentType, ContextType, RequireFields<MutationupdateDashboardByIdArgs, 'input'>>;
  updateDeepdive?: Resolver<Maybe<ResolversTypes['UpdateDeepdivePayload']>, ParentType, ContextType, RequireFields<MutationupdateDeepdiveArgs, 'input'>>;
  updateDeepdiveById?: Resolver<Maybe<ResolversTypes['UpdateDeepdivePayload']>, ParentType, ContextType, RequireFields<MutationupdateDeepdiveByIdArgs, 'input'>>;
  updateDigiboard?: Resolver<Maybe<ResolversTypes['UpdateDigiboardPayload']>, ParentType, ContextType, RequireFields<MutationupdateDigiboardArgs, 'input'>>;
  updateDigiboardById?: Resolver<Maybe<ResolversTypes['UpdateDigiboardPayload']>, ParentType, ContextType, RequireFields<MutationupdateDigiboardByIdArgs, 'input'>>;
  updateEmail?: Resolver<Maybe<ResolversTypes['UpdateEmailPayload']>, ParentType, ContextType, RequireFields<MutationupdateEmailArgs, 'input'>>;
  updateEmailById?: Resolver<Maybe<ResolversTypes['UpdateEmailPayload']>, ParentType, ContextType, RequireFields<MutationupdateEmailByIdArgs, 'input'>>;
  updateEndofshift?: Resolver<Maybe<ResolversTypes['UpdateEndofshiftPayload']>, ParentType, ContextType, RequireFields<MutationupdateEndofshiftArgs, 'input'>>;
  updateEndofshiftById?: Resolver<Maybe<ResolversTypes['UpdateEndofshiftPayload']>, ParentType, ContextType, RequireFields<MutationupdateEndofshiftByIdArgs, 'input'>>;
  updateEvent?: Resolver<Maybe<ResolversTypes['UpdateEventPayload']>, ParentType, ContextType, RequireFields<MutationupdateEventArgs, 'input'>>;
  updateEventById?: Resolver<Maybe<ResolversTypes['UpdateEventPayload']>, ParentType, ContextType, RequireFields<MutationupdateEventByIdArgs, 'input'>>;
  updateFullfillment?: Resolver<Maybe<ResolversTypes['UpdateFullfillmentPayload']>, ParentType, ContextType, RequireFields<MutationupdateFullfillmentArgs, 'input'>>;
  updateFullfillmentById?: Resolver<Maybe<ResolversTypes['UpdateFullfillmentPayload']>, ParentType, ContextType, RequireFields<MutationupdateFullfillmentByIdArgs, 'input'>>;
  updateGiftCertificate?: Resolver<Maybe<ResolversTypes['UpdateGiftCertificatePayload']>, ParentType, ContextType, RequireFields<MutationupdateGiftCertificateArgs, 'input'>>;
  updateGiftCertificateById?: Resolver<Maybe<ResolversTypes['UpdateGiftCertificatePayload']>, ParentType, ContextType, RequireFields<MutationupdateGiftCertificateByIdArgs, 'input'>>;
  updateGlossary?: Resolver<Maybe<ResolversTypes['UpdateGlossaryPayload']>, ParentType, ContextType, RequireFields<MutationupdateGlossaryArgs, 'input'>>;
  updateGlossaryById?: Resolver<Maybe<ResolversTypes['UpdateGlossaryPayload']>, ParentType, ContextType, RequireFields<MutationupdateGlossaryByIdArgs, 'input'>>;
  updateImportm?: Resolver<Maybe<ResolversTypes['UpdateImportmPayload']>, ParentType, ContextType, RequireFields<MutationupdateImportmArgs, 'input'>>;
  updateImportmById?: Resolver<Maybe<ResolversTypes['UpdateImportmPayload']>, ParentType, ContextType, RequireFields<MutationupdateImportmByIdArgs, 'input'>>;
  updateIntegration?: Resolver<Maybe<ResolversTypes['UpdateIntegrationPayload']>, ParentType, ContextType, RequireFields<MutationupdateIntegrationArgs, 'input'>>;
  updateIntegrationById?: Resolver<Maybe<ResolversTypes['UpdateIntegrationPayload']>, ParentType, ContextType, RequireFields<MutationupdateIntegrationByIdArgs, 'input'>>;
  updateInternalization?: Resolver<Maybe<ResolversTypes['UpdateInternalizationPayload']>, ParentType, ContextType, RequireFields<MutationupdateInternalizationArgs, 'input'>>;
  updateInternalizationById?: Resolver<Maybe<ResolversTypes['UpdateInternalizationPayload']>, ParentType, ContextType, RequireFields<MutationupdateInternalizationByIdArgs, 'input'>>;
  updateInvitation?: Resolver<Maybe<ResolversTypes['UpdateInvitationPayload']>, ParentType, ContextType, RequireFields<MutationupdateInvitationArgs, 'input'>>;
  updateInvitationById?: Resolver<Maybe<ResolversTypes['UpdateInvitationPayload']>, ParentType, ContextType, RequireFields<MutationupdateInvitationByIdArgs, 'input'>>;
  updateInvoice?: Resolver<Maybe<ResolversTypes['UpdateInvoicePayload']>, ParentType, ContextType, RequireFields<MutationupdateInvoiceArgs, 'input'>>;
  updateInvoiceById?: Resolver<Maybe<ResolversTypes['UpdateInvoicePayload']>, ParentType, ContextType, RequireFields<MutationupdateInvoiceByIdArgs, 'input'>>;
  updateLead?: Resolver<Maybe<ResolversTypes['UpdateLeadPayload']>, ParentType, ContextType, RequireFields<MutationupdateLeadArgs, 'input'>>;
  updateLeadById?: Resolver<Maybe<ResolversTypes['UpdateLeadPayload']>, ParentType, ContextType, RequireFields<MutationupdateLeadByIdArgs, 'input'>>;
  updateManufacturer?: Resolver<Maybe<ResolversTypes['UpdateManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationupdateManufacturerArgs, 'input'>>;
  updateManufacturerById?: Resolver<Maybe<ResolversTypes['UpdateManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationupdateManufacturerByIdArgs, 'input'>>;
  updateMediamanager?: Resolver<Maybe<ResolversTypes['UpdateMediamanagerPayload']>, ParentType, ContextType, RequireFields<MutationupdateMediamanagerArgs, 'input'>>;
  updateMediamanagerById?: Resolver<Maybe<ResolversTypes['UpdateMediamanagerPayload']>, ParentType, ContextType, RequireFields<MutationupdateMediamanagerByIdArgs, 'input'>>;
  updateMeeting?: Resolver<Maybe<ResolversTypes['UpdateMeetingPayload']>, ParentType, ContextType, RequireFields<MutationupdateMeetingArgs, 'input'>>;
  updateMeetingById?: Resolver<Maybe<ResolversTypes['UpdateMeetingPayload']>, ParentType, ContextType, RequireFields<MutationupdateMeetingByIdArgs, 'input'>>;
  updateMessage?: Resolver<Maybe<ResolversTypes['UpdateMessagePayload']>, ParentType, ContextType, RequireFields<MutationupdateMessageArgs, 'input'>>;
  updateMessageById?: Resolver<Maybe<ResolversTypes['UpdateMessagePayload']>, ParentType, ContextType, RequireFields<MutationupdateMessageByIdArgs, 'input'>>;
  updateNewsletter?: Resolver<Maybe<ResolversTypes['UpdateNewsletterPayload']>, ParentType, ContextType, RequireFields<MutationupdateNewsletterArgs, 'input'>>;
  updateNewsletterById?: Resolver<Maybe<ResolversTypes['UpdateNewsletterPayload']>, ParentType, ContextType, RequireFields<MutationupdateNewsletterByIdArgs, 'input'>>;
  updateOoto?: Resolver<Maybe<ResolversTypes['UpdateOotoPayload']>, ParentType, ContextType, RequireFields<MutationupdateOotoArgs, 'input'>>;
  updateOotoById?: Resolver<Maybe<ResolversTypes['UpdateOotoPayload']>, ParentType, ContextType, RequireFields<MutationupdateOotoByIdArgs, 'input'>>;
  updateOpportunity?: Resolver<Maybe<ResolversTypes['UpdateOpportunityPayload']>, ParentType, ContextType, RequireFields<MutationupdateOpportunityArgs, 'input'>>;
  updateOpportunityById?: Resolver<Maybe<ResolversTypes['UpdateOpportunityPayload']>, ParentType, ContextType, RequireFields<MutationupdateOpportunityByIdArgs, 'input'>>;
  updateOrder?: Resolver<Maybe<ResolversTypes['UpdateOrderPayload']>, ParentType, ContextType, RequireFields<MutationupdateOrderArgs, 'input'>>;
  updateOrderById?: Resolver<Maybe<ResolversTypes['UpdateOrderPayload']>, ParentType, ContextType, RequireFields<MutationupdateOrderByIdArgs, 'input'>>;
  updatePage?: Resolver<Maybe<ResolversTypes['UpdatePagePayload']>, ParentType, ContextType, RequireFields<MutationupdatePageArgs, 'input'>>;
  updatePageById?: Resolver<Maybe<ResolversTypes['UpdatePagePayload']>, ParentType, ContextType, RequireFields<MutationupdatePageByIdArgs, 'input'>>;
  updatePartner?: Resolver<Maybe<ResolversTypes['UpdatePartnerPayload']>, ParentType, ContextType, RequireFields<MutationupdatePartnerArgs, 'input'>>;
  updatePartnerById?: Resolver<Maybe<ResolversTypes['UpdatePartnerPayload']>, ParentType, ContextType, RequireFields<MutationupdatePartnerByIdArgs, 'input'>>;
  updatePayment?: Resolver<Maybe<ResolversTypes['UpdatePaymentPayload']>, ParentType, ContextType, RequireFields<MutationupdatePaymentArgs, 'input'>>;
  updatePaymentById?: Resolver<Maybe<ResolversTypes['UpdatePaymentPayload']>, ParentType, ContextType, RequireFields<MutationupdatePaymentByIdArgs, 'input'>>;
  updatePermission?: Resolver<Maybe<ResolversTypes['UpdatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationupdatePermissionArgs, 'input'>>;
  updatePermissionById?: Resolver<Maybe<ResolversTypes['UpdatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationupdatePermissionByIdArgs, 'input'>>;
  updatePlugin?: Resolver<Maybe<ResolversTypes['UpdatePluginPayload']>, ParentType, ContextType, RequireFields<MutationupdatePluginArgs, 'input'>>;
  updatePluginById?: Resolver<Maybe<ResolversTypes['UpdatePluginPayload']>, ParentType, ContextType, RequireFields<MutationupdatePluginByIdArgs, 'input'>>;
  updatePoll?: Resolver<Maybe<ResolversTypes['UpdatePollPayload']>, ParentType, ContextType, RequireFields<MutationupdatePollArgs, 'input'>>;
  updatePollById?: Resolver<Maybe<ResolversTypes['UpdatePollPayload']>, ParentType, ContextType, RequireFields<MutationupdatePollByIdArgs, 'input'>>;
  updateProductType?: Resolver<Maybe<ResolversTypes['UpdateProductTypePayload']>, ParentType, ContextType, RequireFields<MutationupdateProductTypeArgs, 'input'>>;
  updateProductTypeById?: Resolver<Maybe<ResolversTypes['UpdateProductTypePayload']>, ParentType, ContextType, RequireFields<MutationupdateProductTypeByIdArgs, 'input'>>;
  updateProduct?: Resolver<Maybe<ResolversTypes['UpdateProductPayload']>, ParentType, ContextType, RequireFields<MutationupdateProductArgs, 'input'>>;
  updateProductById?: Resolver<Maybe<ResolversTypes['UpdateProductPayload']>, ParentType, ContextType, RequireFields<MutationupdateProductByIdArgs, 'input'>>;
  updateProject?: Resolver<Maybe<ResolversTypes['UpdateProjectPayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectArgs, 'input'>>;
  updateProjectById?: Resolver<Maybe<ResolversTypes['UpdateProjectPayload']>, ParentType, ContextType, RequireFields<MutationupdateProjectByIdArgs, 'input'>>;
  updateProvider?: Resolver<Maybe<ResolversTypes['UpdateProviderPayload']>, ParentType, ContextType, RequireFields<MutationupdateProviderArgs, 'input'>>;
  updateProviderById?: Resolver<Maybe<ResolversTypes['UpdateProviderPayload']>, ParentType, ContextType, RequireFields<MutationupdateProviderByIdArgs, 'input'>>;
  updateQuote?: Resolver<Maybe<ResolversTypes['UpdateQuotePayload']>, ParentType, ContextType, RequireFields<MutationupdateQuoteArgs, 'input'>>;
  updateQuoteById?: Resolver<Maybe<ResolversTypes['UpdateQuotePayload']>, ParentType, ContextType, RequireFields<MutationupdateQuoteByIdArgs, 'input'>>;
  updateRating?: Resolver<Maybe<ResolversTypes['UpdateRatingPayload']>, ParentType, ContextType, RequireFields<MutationupdateRatingArgs, 'input'>>;
  updateRatingById?: Resolver<Maybe<ResolversTypes['UpdateRatingPayload']>, ParentType, ContextType, RequireFields<MutationupdateRatingByIdArgs, 'input'>>;
  updateReport?: Resolver<Maybe<ResolversTypes['UpdateReportPayload']>, ParentType, ContextType, RequireFields<MutationupdateReportArgs, 'input'>>;
  updateReportById?: Resolver<Maybe<ResolversTypes['UpdateReportPayload']>, ParentType, ContextType, RequireFields<MutationupdateReportByIdArgs, 'input'>>;
  updateReturn?: Resolver<Maybe<ResolversTypes['UpdateReturnPayload']>, ParentType, ContextType, RequireFields<MutationupdateReturnArgs, 'input'>>;
  updateReturnById?: Resolver<Maybe<ResolversTypes['UpdateReturnPayload']>, ParentType, ContextType, RequireFields<MutationupdateReturnByIdArgs, 'input'>>;
  updateReview?: Resolver<Maybe<ResolversTypes['UpdateReviewPayload']>, ParentType, ContextType, RequireFields<MutationupdateReviewArgs, 'input'>>;
  updateReviewById?: Resolver<Maybe<ResolversTypes['UpdateReviewPayload']>, ParentType, ContextType, RequireFields<MutationupdateReviewByIdArgs, 'input'>>;
  updateReward?: Resolver<Maybe<ResolversTypes['UpdateRewardPayload']>, ParentType, ContextType, RequireFields<MutationupdateRewardArgs, 'input'>>;
  updateRewardById?: Resolver<Maybe<ResolversTypes['UpdateRewardPayload']>, ParentType, ContextType, RequireFields<MutationupdateRewardByIdArgs, 'input'>>;
  updateRole?: Resolver<Maybe<ResolversTypes['UpdateRolePayload']>, ParentType, ContextType, RequireFields<MutationupdateRoleArgs, 'input'>>;
  updateRoleById?: Resolver<Maybe<ResolversTypes['UpdateRolePayload']>, ParentType, ContextType, RequireFields<MutationupdateRoleByIdArgs, 'input'>>;
  updateScheduler?: Resolver<Maybe<ResolversTypes['UpdateSchedulerPayload']>, ParentType, ContextType, RequireFields<MutationupdateSchedulerArgs, 'input'>>;
  updateSchedulerById?: Resolver<Maybe<ResolversTypes['UpdateSchedulerPayload']>, ParentType, ContextType, RequireFields<MutationupdateSchedulerByIdArgs, 'input'>>;
  updateSegment?: Resolver<Maybe<ResolversTypes['UpdateSegmentPayload']>, ParentType, ContextType, RequireFields<MutationupdateSegmentArgs, 'input'>>;
  updateSegmentById?: Resolver<Maybe<ResolversTypes['UpdateSegmentPayload']>, ParentType, ContextType, RequireFields<MutationupdateSegmentByIdArgs, 'input'>>;
  updateSetting?: Resolver<Maybe<ResolversTypes['UpdateSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateSettingArgs, 'input'>>;
  updateSettingById?: Resolver<Maybe<ResolversTypes['UpdateSettingPayload']>, ParentType, ContextType, RequireFields<MutationupdateSettingByIdArgs, 'input'>>;
  updateShipment?: Resolver<Maybe<ResolversTypes['UpdateShipmentPayload']>, ParentType, ContextType, RequireFields<MutationupdateShipmentArgs, 'input'>>;
  updateShipmentById?: Resolver<Maybe<ResolversTypes['UpdateShipmentPayload']>, ParentType, ContextType, RequireFields<MutationupdateShipmentByIdArgs, 'input'>>;
  updateSpecialDiscount?: Resolver<Maybe<ResolversTypes['UpdateSpecialDiscountPayload']>, ParentType, ContextType, RequireFields<MutationupdateSpecialDiscountArgs, 'input'>>;
  updateSpecialDiscountById?: Resolver<Maybe<ResolversTypes['UpdateSpecialDiscountPayload']>, ParentType, ContextType, RequireFields<MutationupdateSpecialDiscountByIdArgs, 'input'>>;
  updateState?: Resolver<Maybe<ResolversTypes['UpdateStatePayload']>, ParentType, ContextType, RequireFields<MutationupdateStateArgs, 'input'>>;
  updateStateById?: Resolver<Maybe<ResolversTypes['UpdateStatePayload']>, ParentType, ContextType, RequireFields<MutationupdateStateByIdArgs, 'input'>>;
  updateStatistic?: Resolver<Maybe<ResolversTypes['UpdateStatisticPayload']>, ParentType, ContextType, RequireFields<MutationupdateStatisticArgs, 'input'>>;
  updateStatisticById?: Resolver<Maybe<ResolversTypes['UpdateStatisticPayload']>, ParentType, ContextType, RequireFields<MutationupdateStatisticByIdArgs, 'input'>>;
  updateStock?: Resolver<Maybe<ResolversTypes['UpdateStockPayload']>, ParentType, ContextType, RequireFields<MutationupdateStockArgs, 'input'>>;
  updateStockById?: Resolver<Maybe<ResolversTypes['UpdateStockPayload']>, ParentType, ContextType, RequireFields<MutationupdateStockByIdArgs, 'input'>>;
  updateSurvey?: Resolver<Maybe<ResolversTypes['UpdateSurveyPayload']>, ParentType, ContextType, RequireFields<MutationupdateSurveyArgs, 'input'>>;
  updateSurveyById?: Resolver<Maybe<ResolversTypes['UpdateSurveyPayload']>, ParentType, ContextType, RequireFields<MutationupdateSurveyByIdArgs, 'input'>>;
  updateTag?: Resolver<Maybe<ResolversTypes['UpdateTagPayload']>, ParentType, ContextType, RequireFields<MutationupdateTagArgs, 'input'>>;
  updateTagById?: Resolver<Maybe<ResolversTypes['UpdateTagPayload']>, ParentType, ContextType, RequireFields<MutationupdateTagByIdArgs, 'input'>>;
  updateTarget?: Resolver<Maybe<ResolversTypes['UpdateTargetPayload']>, ParentType, ContextType, RequireFields<MutationupdateTargetArgs, 'input'>>;
  updateTargetById?: Resolver<Maybe<ResolversTypes['UpdateTargetPayload']>, ParentType, ContextType, RequireFields<MutationupdateTargetByIdArgs, 'input'>>;
  updateTaxCategory?: Resolver<Maybe<ResolversTypes['UpdateTaxCategoryPayload']>, ParentType, ContextType, RequireFields<MutationupdateTaxCategoryArgs, 'input'>>;
  updateTaxCategoryById?: Resolver<Maybe<ResolversTypes['UpdateTaxCategoryPayload']>, ParentType, ContextType, RequireFields<MutationupdateTaxCategoryByIdArgs, 'input'>>;
  updateTaxRate?: Resolver<Maybe<ResolversTypes['UpdateTaxRatePayload']>, ParentType, ContextType, RequireFields<MutationupdateTaxRateArgs, 'input'>>;
  updateTaxRateById?: Resolver<Maybe<ResolversTypes['UpdateTaxRatePayload']>, ParentType, ContextType, RequireFields<MutationupdateTaxRateByIdArgs, 'input'>>;
  updateTaxRule?: Resolver<Maybe<ResolversTypes['UpdateTaxRulePayload']>, ParentType, ContextType, RequireFields<MutationupdateTaxRuleArgs, 'input'>>;
  updateTaxRuleById?: Resolver<Maybe<ResolversTypes['UpdateTaxRulePayload']>, ParentType, ContextType, RequireFields<MutationupdateTaxRuleByIdArgs, 'input'>>;
  updateTemplate?: Resolver<Maybe<ResolversTypes['UpdateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationupdateTemplateArgs, 'input'>>;
  updateTemplateById?: Resolver<Maybe<ResolversTypes['UpdateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationupdateTemplateByIdArgs, 'input'>>;
  updateTheme?: Resolver<Maybe<ResolversTypes['UpdateThemePayload']>, ParentType, ContextType, RequireFields<MutationupdateThemeArgs, 'input'>>;
  updateThemeById?: Resolver<Maybe<ResolversTypes['UpdateThemePayload']>, ParentType, ContextType, RequireFields<MutationupdateThemeByIdArgs, 'input'>>;
  updateTicketing?: Resolver<Maybe<ResolversTypes['UpdateTicketingPayload']>, ParentType, ContextType, RequireFields<MutationupdateTicketingArgs, 'input'>>;
  updateTicketingById?: Resolver<Maybe<ResolversTypes['UpdateTicketingPayload']>, ParentType, ContextType, RequireFields<MutationupdateTicketingByIdArgs, 'input'>>;
  updateTraining?: Resolver<Maybe<ResolversTypes['UpdateTrainingPayload']>, ParentType, ContextType, RequireFields<MutationupdateTrainingArgs, 'input'>>;
  updateTrainingById?: Resolver<Maybe<ResolversTypes['UpdateTrainingPayload']>, ParentType, ContextType, RequireFields<MutationupdateTrainingByIdArgs, 'input'>>;
  updateTransaction?: Resolver<Maybe<ResolversTypes['UpdateTransactionPayload']>, ParentType, ContextType, RequireFields<MutationupdateTransactionArgs, 'input'>>;
  updateTransactionById?: Resolver<Maybe<ResolversTypes['UpdateTransactionPayload']>, ParentType, ContextType, RequireFields<MutationupdateTransactionByIdArgs, 'input'>>;
  updateUploadFile?: Resolver<Maybe<ResolversTypes['UpdateUploadFilePayload']>, ParentType, ContextType, RequireFields<MutationupdateUploadFileArgs, 'input'>>;
  updateUploadFileById?: Resolver<Maybe<ResolversTypes['UpdateUploadFilePayload']>, ParentType, ContextType, RequireFields<MutationupdateUploadFileByIdArgs, 'input'>>;
  updateUser?: Resolver<Maybe<ResolversTypes['UpdateUserPayload']>, ParentType, ContextType, RequireFields<MutationupdateUserArgs, 'input'>>;
  updateUserById?: Resolver<Maybe<ResolversTypes['UpdateUserPayload']>, ParentType, ContextType, RequireFields<MutationupdateUserByIdArgs, 'input'>>;
  updateVendor?: Resolver<Maybe<ResolversTypes['UpdateVendorPayload']>, ParentType, ContextType, RequireFields<MutationupdateVendorArgs, 'input'>>;
  updateVendorById?: Resolver<Maybe<ResolversTypes['UpdateVendorPayload']>, ParentType, ContextType, RequireFields<MutationupdateVendorByIdArgs, 'input'>>;
  updateVisit?: Resolver<Maybe<ResolversTypes['UpdateVisitPayload']>, ParentType, ContextType, RequireFields<MutationupdateVisitArgs, 'input'>>;
  updateVisitById?: Resolver<Maybe<ResolversTypes['UpdateVisitPayload']>, ParentType, ContextType, RequireFields<MutationupdateVisitByIdArgs, 'input'>>;
  updateWarehouse?: Resolver<Maybe<ResolversTypes['UpdateWarehousePayload']>, ParentType, ContextType, RequireFields<MutationupdateWarehouseArgs, 'input'>>;
  updateWarehouseById?: Resolver<Maybe<ResolversTypes['UpdateWarehousePayload']>, ParentType, ContextType, RequireFields<MutationupdateWarehouseByIdArgs, 'input'>>;
  updateWebhook?: Resolver<Maybe<ResolversTypes['UpdateWebhookPayload']>, ParentType, ContextType, RequireFields<MutationupdateWebhookArgs, 'input'>>;
  updateWebhookById?: Resolver<Maybe<ResolversTypes['UpdateWebhookPayload']>, ParentType, ContextType, RequireFields<MutationupdateWebhookByIdArgs, 'input'>>;
  updateWebsite?: Resolver<Maybe<ResolversTypes['UpdateWebsitePayload']>, ParentType, ContextType, RequireFields<MutationupdateWebsiteArgs, 'input'>>;
  updateWebsiteById?: Resolver<Maybe<ResolversTypes['UpdateWebsitePayload']>, ParentType, ContextType, RequireFields<MutationupdateWebsiteByIdArgs, 'input'>>;
  updateWishlist?: Resolver<Maybe<ResolversTypes['UpdateWishlistPayload']>, ParentType, ContextType, RequireFields<MutationupdateWishlistArgs, 'input'>>;
  updateWishlistById?: Resolver<Maybe<ResolversTypes['UpdateWishlistPayload']>, ParentType, ContextType, RequireFields<MutationupdateWishlistByIdArgs, 'input'>>;
  updateWorkspace?: Resolver<Maybe<ResolversTypes['UpdateWorkspacePayload']>, ParentType, ContextType, RequireFields<MutationupdateWorkspaceArgs, 'input'>>;
  updateWorkspaceById?: Resolver<Maybe<ResolversTypes['UpdateWorkspacePayload']>, ParentType, ContextType, RequireFields<MutationupdateWorkspaceByIdArgs, 'input'>>;
  updateZone?: Resolver<Maybe<ResolversTypes['UpdateZonePayload']>, ParentType, ContextType, RequireFields<MutationupdateZoneArgs, 'input'>>;
  updateZoneById?: Resolver<Maybe<ResolversTypes['UpdateZonePayload']>, ParentType, ContextType, RequireFields<MutationupdateZoneByIdArgs, 'input'>>;
  deleteAccount?: Resolver<Maybe<ResolversTypes['DeleteAccountPayload']>, ParentType, ContextType, RequireFields<MutationdeleteAccountArgs, 'input'>>;
  deleteAccountById?: Resolver<Maybe<ResolversTypes['DeleteAccountPayload']>, ParentType, ContextType, RequireFields<MutationdeleteAccountByIdArgs, 'input'>>;
  deleteAgreement?: Resolver<Maybe<ResolversTypes['DeleteAgreementPayload']>, ParentType, ContextType, RequireFields<MutationdeleteAgreementArgs, 'input'>>;
  deleteAgreementById?: Resolver<Maybe<ResolversTypes['DeleteAgreementPayload']>, ParentType, ContextType, RequireFields<MutationdeleteAgreementByIdArgs, 'input'>>;
  deleteAnalytic?: Resolver<Maybe<ResolversTypes['DeleteAnalyticPayload']>, ParentType, ContextType, RequireFields<MutationdeleteAnalyticArgs, 'input'>>;
  deleteAnalyticById?: Resolver<Maybe<ResolversTypes['DeleteAnalyticPayload']>, ParentType, ContextType, RequireFields<MutationdeleteAnalyticByIdArgs, 'input'>>;
  deleteApitoken?: Resolver<Maybe<ResolversTypes['DeleteApitokenPayload']>, ParentType, ContextType, RequireFields<MutationdeleteApitokenArgs, 'input'>>;
  deleteApitokenById?: Resolver<Maybe<ResolversTypes['DeleteApitokenPayload']>, ParentType, ContextType, RequireFields<MutationdeleteApitokenByIdArgs, 'input'>>;
  deleteArticle?: Resolver<Maybe<ResolversTypes['DeleteArticlePayload']>, ParentType, ContextType, RequireFields<MutationdeleteArticleArgs, 'input'>>;
  deleteArticleById?: Resolver<Maybe<ResolversTypes['DeleteArticlePayload']>, ParentType, ContextType, RequireFields<MutationdeleteArticleByIdArgs, 'input'>>;
  deleteAttribute?: Resolver<Maybe<ResolversTypes['DeleteAttributePayload']>, ParentType, ContextType, RequireFields<MutationdeleteAttributeArgs, 'input'>>;
  deleteAttributeById?: Resolver<Maybe<ResolversTypes['DeleteAttributePayload']>, ParentType, ContextType, RequireFields<MutationdeleteAttributeByIdArgs, 'input'>>;
  deleteBrand?: Resolver<Maybe<ResolversTypes['DeleteBrandPayload']>, ParentType, ContextType, RequireFields<MutationdeleteBrandArgs, 'input'>>;
  deleteBrandById?: Resolver<Maybe<ResolversTypes['DeleteBrandPayload']>, ParentType, ContextType, RequireFields<MutationdeleteBrandByIdArgs, 'input'>>;
  deleteCartPriceRule?: Resolver<Maybe<ResolversTypes['DeleteCartPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationdeleteCartPriceRuleArgs, 'input'>>;
  deleteCartPriceRuleById?: Resolver<Maybe<ResolversTypes['DeleteCartPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationdeleteCartPriceRuleByIdArgs, 'input'>>;
  deleteCase?: Resolver<Maybe<ResolversTypes['DeleteCasePayload']>, ParentType, ContextType, RequireFields<MutationdeleteCaseArgs, 'input'>>;
  deleteCaseById?: Resolver<Maybe<ResolversTypes['DeleteCasePayload']>, ParentType, ContextType, RequireFields<MutationdeleteCaseByIdArgs, 'input'>>;
  deleteCatalogPriceRule?: Resolver<Maybe<ResolversTypes['DeleteCatalogPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationdeleteCatalogPriceRuleArgs, 'input'>>;
  deleteCatalogPriceRuleById?: Resolver<Maybe<ResolversTypes['DeleteCatalogPriceRulePayload']>, ParentType, ContextType, RequireFields<MutationdeleteCatalogPriceRuleByIdArgs, 'input'>>;
  deleteCategory?: Resolver<Maybe<ResolversTypes['DeleteCategoryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCategoryArgs, 'input'>>;
  deleteCategoryById?: Resolver<Maybe<ResolversTypes['DeleteCategoryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCategoryByIdArgs, 'input'>>;
  deleteChannel?: Resolver<Maybe<ResolversTypes['DeleteChannelPayload']>, ParentType, ContextType, RequireFields<MutationdeleteChannelArgs, 'input'>>;
  deleteChannelById?: Resolver<Maybe<ResolversTypes['DeleteChannelPayload']>, ParentType, ContextType, RequireFields<MutationdeleteChannelByIdArgs, 'input'>>;
  deleteChecklist?: Resolver<Maybe<ResolversTypes['DeleteChecklistPayload']>, ParentType, ContextType, RequireFields<MutationdeleteChecklistArgs, 'input'>>;
  deleteChecklistById?: Resolver<Maybe<ResolversTypes['DeleteChecklistPayload']>, ParentType, ContextType, RequireFields<MutationdeleteChecklistByIdArgs, 'input'>>;
  deleteCity?: Resolver<Maybe<ResolversTypes['DeleteCityPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCityArgs, 'input'>>;
  deleteCityById?: Resolver<Maybe<ResolversTypes['DeleteCityPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCityByIdArgs, 'input'>>;
  deleteCollection?: Resolver<Maybe<ResolversTypes['DeleteCollectionPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCollectionArgs, 'input'>>;
  deleteCollectionById?: Resolver<Maybe<ResolversTypes['DeleteCollectionPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCollectionByIdArgs, 'input'>>;
  deleteComment?: Resolver<Maybe<ResolversTypes['DeleteCommentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCommentArgs, 'input'>>;
  deleteCommentById?: Resolver<Maybe<ResolversTypes['DeleteCommentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCommentByIdArgs, 'input'>>;
  deleteContentType?: Resolver<Maybe<ResolversTypes['DeleteContentTypePayload']>, ParentType, ContextType, RequireFields<MutationdeleteContentTypeArgs, 'input'>>;
  deleteContentTypeById?: Resolver<Maybe<ResolversTypes['DeleteContentTypePayload']>, ParentType, ContextType, RequireFields<MutationdeleteContentTypeByIdArgs, 'input'>>;
  deleteContract?: Resolver<Maybe<ResolversTypes['DeleteContractPayload']>, ParentType, ContextType, RequireFields<MutationdeleteContractArgs, 'input'>>;
  deleteContractById?: Resolver<Maybe<ResolversTypes['DeleteContractPayload']>, ParentType, ContextType, RequireFields<MutationdeleteContractByIdArgs, 'input'>>;
  deleteCountry?: Resolver<Maybe<ResolversTypes['DeleteCountryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCountryArgs, 'input'>>;
  deleteCountryById?: Resolver<Maybe<ResolversTypes['DeleteCountryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCountryByIdArgs, 'input'>>;
  deleteCoupon?: Resolver<Maybe<ResolversTypes['DeleteCouponPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCouponArgs, 'input'>>;
  deleteCouponById?: Resolver<Maybe<ResolversTypes['DeleteCouponPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCouponByIdArgs, 'input'>>;
  deleteCreditMemo?: Resolver<Maybe<ResolversTypes['DeleteCreditMemoPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCreditMemoArgs, 'input'>>;
  deleteCreditMemoByCreditMemoAndId?: Resolver<Maybe<ResolversTypes['DeleteCreditMemoPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCreditMemoByCreditMemoAndIdArgs, 'input'>>;
  deleteCurrency?: Resolver<Maybe<ResolversTypes['DeleteCurrencyPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCurrencyArgs, 'input'>>;
  deleteCurrencyById?: Resolver<Maybe<ResolversTypes['DeleteCurrencyPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCurrencyByIdArgs, 'input'>>;
  deleteCurrencyRate?: Resolver<Maybe<ResolversTypes['DeleteCurrencyRatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteCurrencyRateArgs, 'input'>>;
  deleteCurrencyRateByImportService?: Resolver<Maybe<ResolversTypes['DeleteCurrencyRatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteCurrencyRateByImportServiceArgs, 'input'>>;
  deleteCurrencySymbol?: Resolver<Maybe<ResolversTypes['DeleteCurrencySymbolPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCurrencySymbolArgs, 'input'>>;
  deleteCurrencySymbolBySymbol?: Resolver<Maybe<ResolversTypes['DeleteCurrencySymbolPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCurrencySymbolBySymbolArgs, 'input'>>;
  deleteCustomerGroup?: Resolver<Maybe<ResolversTypes['DeleteCustomerGroupPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCustomerGroupArgs, 'input'>>;
  deleteCustomerGroupById?: Resolver<Maybe<ResolversTypes['DeleteCustomerGroupPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCustomerGroupByIdArgs, 'input'>>;
  deleteCustomer?: Resolver<Maybe<ResolversTypes['DeleteCustomerPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCustomerArgs, 'input'>>;
  deleteCustomerById?: Resolver<Maybe<ResolversTypes['DeleteCustomerPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCustomerByIdArgs, 'input'>>;
  deleteCustomization?: Resolver<Maybe<ResolversTypes['DeleteCustomizationPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCustomizationArgs, 'input'>>;
  deleteCustomizationById?: Resolver<Maybe<ResolversTypes['DeleteCustomizationPayload']>, ParentType, ContextType, RequireFields<MutationdeleteCustomizationByIdArgs, 'input'>>;
  deleteDashboard?: Resolver<Maybe<ResolversTypes['DeleteDashboardPayload']>, ParentType, ContextType, RequireFields<MutationdeleteDashboardArgs, 'input'>>;
  deleteDashboardById?: Resolver<Maybe<ResolversTypes['DeleteDashboardPayload']>, ParentType, ContextType, RequireFields<MutationdeleteDashboardByIdArgs, 'input'>>;
  deleteDeepdive?: Resolver<Maybe<ResolversTypes['DeleteDeepdivePayload']>, ParentType, ContextType, RequireFields<MutationdeleteDeepdiveArgs, 'input'>>;
  deleteDeepdiveById?: Resolver<Maybe<ResolversTypes['DeleteDeepdivePayload']>, ParentType, ContextType, RequireFields<MutationdeleteDeepdiveByIdArgs, 'input'>>;
  deleteDigiboard?: Resolver<Maybe<ResolversTypes['DeleteDigiboardPayload']>, ParentType, ContextType, RequireFields<MutationdeleteDigiboardArgs, 'input'>>;
  deleteDigiboardById?: Resolver<Maybe<ResolversTypes['DeleteDigiboardPayload']>, ParentType, ContextType, RequireFields<MutationdeleteDigiboardByIdArgs, 'input'>>;
  deleteEmail?: Resolver<Maybe<ResolversTypes['DeleteEmailPayload']>, ParentType, ContextType, RequireFields<MutationdeleteEmailArgs, 'input'>>;
  deleteEmailById?: Resolver<Maybe<ResolversTypes['DeleteEmailPayload']>, ParentType, ContextType, RequireFields<MutationdeleteEmailByIdArgs, 'input'>>;
  deleteEndofshift?: Resolver<Maybe<ResolversTypes['DeleteEndofshiftPayload']>, ParentType, ContextType, RequireFields<MutationdeleteEndofshiftArgs, 'input'>>;
  deleteEndofshiftById?: Resolver<Maybe<ResolversTypes['DeleteEndofshiftPayload']>, ParentType, ContextType, RequireFields<MutationdeleteEndofshiftByIdArgs, 'input'>>;
  deleteEvent?: Resolver<Maybe<ResolversTypes['DeleteEventPayload']>, ParentType, ContextType, RequireFields<MutationdeleteEventArgs, 'input'>>;
  deleteEventById?: Resolver<Maybe<ResolversTypes['DeleteEventPayload']>, ParentType, ContextType, RequireFields<MutationdeleteEventByIdArgs, 'input'>>;
  deleteFullfillment?: Resolver<Maybe<ResolversTypes['DeleteFullfillmentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteFullfillmentArgs, 'input'>>;
  deleteFullfillmentById?: Resolver<Maybe<ResolversTypes['DeleteFullfillmentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteFullfillmentByIdArgs, 'input'>>;
  deleteGiftCertificate?: Resolver<Maybe<ResolversTypes['DeleteGiftCertificatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteGiftCertificateArgs, 'input'>>;
  deleteGiftCertificateById?: Resolver<Maybe<ResolversTypes['DeleteGiftCertificatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteGiftCertificateByIdArgs, 'input'>>;
  deleteGlossary?: Resolver<Maybe<ResolversTypes['DeleteGlossaryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteGlossaryArgs, 'input'>>;
  deleteGlossaryById?: Resolver<Maybe<ResolversTypes['DeleteGlossaryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteGlossaryByIdArgs, 'input'>>;
  deleteImportm?: Resolver<Maybe<ResolversTypes['DeleteImportmPayload']>, ParentType, ContextType, RequireFields<MutationdeleteImportmArgs, 'input'>>;
  deleteImportmById?: Resolver<Maybe<ResolversTypes['DeleteImportmPayload']>, ParentType, ContextType, RequireFields<MutationdeleteImportmByIdArgs, 'input'>>;
  deleteIntegration?: Resolver<Maybe<ResolversTypes['DeleteIntegrationPayload']>, ParentType, ContextType, RequireFields<MutationdeleteIntegrationArgs, 'input'>>;
  deleteIntegrationById?: Resolver<Maybe<ResolversTypes['DeleteIntegrationPayload']>, ParentType, ContextType, RequireFields<MutationdeleteIntegrationByIdArgs, 'input'>>;
  deleteInternalization?: Resolver<Maybe<ResolversTypes['DeleteInternalizationPayload']>, ParentType, ContextType, RequireFields<MutationdeleteInternalizationArgs, 'input'>>;
  deleteInternalizationById?: Resolver<Maybe<ResolversTypes['DeleteInternalizationPayload']>, ParentType, ContextType, RequireFields<MutationdeleteInternalizationByIdArgs, 'input'>>;
  deleteInvitation?: Resolver<Maybe<ResolversTypes['DeleteInvitationPayload']>, ParentType, ContextType, RequireFields<MutationdeleteInvitationArgs, 'input'>>;
  deleteInvitationById?: Resolver<Maybe<ResolversTypes['DeleteInvitationPayload']>, ParentType, ContextType, RequireFields<MutationdeleteInvitationByIdArgs, 'input'>>;
  deleteInvoice?: Resolver<Maybe<ResolversTypes['DeleteInvoicePayload']>, ParentType, ContextType, RequireFields<MutationdeleteInvoiceArgs, 'input'>>;
  deleteInvoiceById?: Resolver<Maybe<ResolversTypes['DeleteInvoicePayload']>, ParentType, ContextType, RequireFields<MutationdeleteInvoiceByIdArgs, 'input'>>;
  deleteLead?: Resolver<Maybe<ResolversTypes['DeleteLeadPayload']>, ParentType, ContextType, RequireFields<MutationdeleteLeadArgs, 'input'>>;
  deleteLeadById?: Resolver<Maybe<ResolversTypes['DeleteLeadPayload']>, ParentType, ContextType, RequireFields<MutationdeleteLeadByIdArgs, 'input'>>;
  deleteManufacturer?: Resolver<Maybe<ResolversTypes['DeleteManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationdeleteManufacturerArgs, 'input'>>;
  deleteManufacturerById?: Resolver<Maybe<ResolversTypes['DeleteManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationdeleteManufacturerByIdArgs, 'input'>>;
  deleteMediamanager?: Resolver<Maybe<ResolversTypes['DeleteMediamanagerPayload']>, ParentType, ContextType, RequireFields<MutationdeleteMediamanagerArgs, 'input'>>;
  deleteMediamanagerById?: Resolver<Maybe<ResolversTypes['DeleteMediamanagerPayload']>, ParentType, ContextType, RequireFields<MutationdeleteMediamanagerByIdArgs, 'input'>>;
  deleteMeeting?: Resolver<Maybe<ResolversTypes['DeleteMeetingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteMeetingArgs, 'input'>>;
  deleteMeetingById?: Resolver<Maybe<ResolversTypes['DeleteMeetingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteMeetingByIdArgs, 'input'>>;
  deleteMessage?: Resolver<Maybe<ResolversTypes['DeleteMessagePayload']>, ParentType, ContextType, RequireFields<MutationdeleteMessageArgs, 'input'>>;
  deleteMessageById?: Resolver<Maybe<ResolversTypes['DeleteMessagePayload']>, ParentType, ContextType, RequireFields<MutationdeleteMessageByIdArgs, 'input'>>;
  deleteNewsletter?: Resolver<Maybe<ResolversTypes['DeleteNewsletterPayload']>, ParentType, ContextType, RequireFields<MutationdeleteNewsletterArgs, 'input'>>;
  deleteNewsletterById?: Resolver<Maybe<ResolversTypes['DeleteNewsletterPayload']>, ParentType, ContextType, RequireFields<MutationdeleteNewsletterByIdArgs, 'input'>>;
  deleteOoto?: Resolver<Maybe<ResolversTypes['DeleteOotoPayload']>, ParentType, ContextType, RequireFields<MutationdeleteOotoArgs, 'input'>>;
  deleteOotoById?: Resolver<Maybe<ResolversTypes['DeleteOotoPayload']>, ParentType, ContextType, RequireFields<MutationdeleteOotoByIdArgs, 'input'>>;
  deleteOpportunity?: Resolver<Maybe<ResolversTypes['DeleteOpportunityPayload']>, ParentType, ContextType, RequireFields<MutationdeleteOpportunityArgs, 'input'>>;
  deleteOpportunityById?: Resolver<Maybe<ResolversTypes['DeleteOpportunityPayload']>, ParentType, ContextType, RequireFields<MutationdeleteOpportunityByIdArgs, 'input'>>;
  deleteOrder?: Resolver<Maybe<ResolversTypes['DeleteOrderPayload']>, ParentType, ContextType, RequireFields<MutationdeleteOrderArgs, 'input'>>;
  deleteOrderById?: Resolver<Maybe<ResolversTypes['DeleteOrderPayload']>, ParentType, ContextType, RequireFields<MutationdeleteOrderByIdArgs, 'input'>>;
  deletePage?: Resolver<Maybe<ResolversTypes['DeletePagePayload']>, ParentType, ContextType, RequireFields<MutationdeletePageArgs, 'input'>>;
  deletePageById?: Resolver<Maybe<ResolversTypes['DeletePagePayload']>, ParentType, ContextType, RequireFields<MutationdeletePageByIdArgs, 'input'>>;
  deletePartner?: Resolver<Maybe<ResolversTypes['DeletePartnerPayload']>, ParentType, ContextType, RequireFields<MutationdeletePartnerArgs, 'input'>>;
  deletePartnerById?: Resolver<Maybe<ResolversTypes['DeletePartnerPayload']>, ParentType, ContextType, RequireFields<MutationdeletePartnerByIdArgs, 'input'>>;
  deletePayment?: Resolver<Maybe<ResolversTypes['DeletePaymentPayload']>, ParentType, ContextType, RequireFields<MutationdeletePaymentArgs, 'input'>>;
  deletePaymentById?: Resolver<Maybe<ResolversTypes['DeletePaymentPayload']>, ParentType, ContextType, RequireFields<MutationdeletePaymentByIdArgs, 'input'>>;
  deletePermission?: Resolver<Maybe<ResolversTypes['DeletePermissionPayload']>, ParentType, ContextType, RequireFields<MutationdeletePermissionArgs, 'input'>>;
  deletePermissionById?: Resolver<Maybe<ResolversTypes['DeletePermissionPayload']>, ParentType, ContextType, RequireFields<MutationdeletePermissionByIdArgs, 'input'>>;
  deletePlugin?: Resolver<Maybe<ResolversTypes['DeletePluginPayload']>, ParentType, ContextType, RequireFields<MutationdeletePluginArgs, 'input'>>;
  deletePluginById?: Resolver<Maybe<ResolversTypes['DeletePluginPayload']>, ParentType, ContextType, RequireFields<MutationdeletePluginByIdArgs, 'input'>>;
  deletePoll?: Resolver<Maybe<ResolversTypes['DeletePollPayload']>, ParentType, ContextType, RequireFields<MutationdeletePollArgs, 'input'>>;
  deletePollById?: Resolver<Maybe<ResolversTypes['DeletePollPayload']>, ParentType, ContextType, RequireFields<MutationdeletePollByIdArgs, 'input'>>;
  deleteProductType?: Resolver<Maybe<ResolversTypes['DeleteProductTypePayload']>, ParentType, ContextType, RequireFields<MutationdeleteProductTypeArgs, 'input'>>;
  deleteProductTypeById?: Resolver<Maybe<ResolversTypes['DeleteProductTypePayload']>, ParentType, ContextType, RequireFields<MutationdeleteProductTypeByIdArgs, 'input'>>;
  deleteProduct?: Resolver<Maybe<ResolversTypes['DeleteProductPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProductArgs, 'input'>>;
  deleteProductById?: Resolver<Maybe<ResolversTypes['DeleteProductPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProductByIdArgs, 'input'>>;
  deleteProject?: Resolver<Maybe<ResolversTypes['DeleteProjectPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectArgs, 'input'>>;
  deleteProjectById?: Resolver<Maybe<ResolversTypes['DeleteProjectPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProjectByIdArgs, 'input'>>;
  deleteProvider?: Resolver<Maybe<ResolversTypes['DeleteProviderPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProviderArgs, 'input'>>;
  deleteProviderById?: Resolver<Maybe<ResolversTypes['DeleteProviderPayload']>, ParentType, ContextType, RequireFields<MutationdeleteProviderByIdArgs, 'input'>>;
  deleteQuote?: Resolver<Maybe<ResolversTypes['DeleteQuotePayload']>, ParentType, ContextType, RequireFields<MutationdeleteQuoteArgs, 'input'>>;
  deleteQuoteById?: Resolver<Maybe<ResolversTypes['DeleteQuotePayload']>, ParentType, ContextType, RequireFields<MutationdeleteQuoteByIdArgs, 'input'>>;
  deleteRating?: Resolver<Maybe<ResolversTypes['DeleteRatingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteRatingArgs, 'input'>>;
  deleteRatingById?: Resolver<Maybe<ResolversTypes['DeleteRatingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteRatingByIdArgs, 'input'>>;
  deleteReport?: Resolver<Maybe<ResolversTypes['DeleteReportPayload']>, ParentType, ContextType, RequireFields<MutationdeleteReportArgs, 'input'>>;
  deleteReportById?: Resolver<Maybe<ResolversTypes['DeleteReportPayload']>, ParentType, ContextType, RequireFields<MutationdeleteReportByIdArgs, 'input'>>;
  deleteReturn?: Resolver<Maybe<ResolversTypes['DeleteReturnPayload']>, ParentType, ContextType, RequireFields<MutationdeleteReturnArgs, 'input'>>;
  deleteReturnById?: Resolver<Maybe<ResolversTypes['DeleteReturnPayload']>, ParentType, ContextType, RequireFields<MutationdeleteReturnByIdArgs, 'input'>>;
  deleteReview?: Resolver<Maybe<ResolversTypes['DeleteReviewPayload']>, ParentType, ContextType, RequireFields<MutationdeleteReviewArgs, 'input'>>;
  deleteReviewById?: Resolver<Maybe<ResolversTypes['DeleteReviewPayload']>, ParentType, ContextType, RequireFields<MutationdeleteReviewByIdArgs, 'input'>>;
  deleteReward?: Resolver<Maybe<ResolversTypes['DeleteRewardPayload']>, ParentType, ContextType, RequireFields<MutationdeleteRewardArgs, 'input'>>;
  deleteRewardById?: Resolver<Maybe<ResolversTypes['DeleteRewardPayload']>, ParentType, ContextType, RequireFields<MutationdeleteRewardByIdArgs, 'input'>>;
  deleteRole?: Resolver<Maybe<ResolversTypes['DeleteRolePayload']>, ParentType, ContextType, RequireFields<MutationdeleteRoleArgs, 'input'>>;
  deleteRoleById?: Resolver<Maybe<ResolversTypes['DeleteRolePayload']>, ParentType, ContextType, RequireFields<MutationdeleteRoleByIdArgs, 'input'>>;
  deleteScheduler?: Resolver<Maybe<ResolversTypes['DeleteSchedulerPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSchedulerArgs, 'input'>>;
  deleteSchedulerById?: Resolver<Maybe<ResolversTypes['DeleteSchedulerPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSchedulerByIdArgs, 'input'>>;
  deleteSegment?: Resolver<Maybe<ResolversTypes['DeleteSegmentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSegmentArgs, 'input'>>;
  deleteSegmentById?: Resolver<Maybe<ResolversTypes['DeleteSegmentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSegmentByIdArgs, 'input'>>;
  deleteSetting?: Resolver<Maybe<ResolversTypes['DeleteSettingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSettingArgs, 'input'>>;
  deleteSettingById?: Resolver<Maybe<ResolversTypes['DeleteSettingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSettingByIdArgs, 'input'>>;
  deleteShipment?: Resolver<Maybe<ResolversTypes['DeleteShipmentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteShipmentArgs, 'input'>>;
  deleteShipmentById?: Resolver<Maybe<ResolversTypes['DeleteShipmentPayload']>, ParentType, ContextType, RequireFields<MutationdeleteShipmentByIdArgs, 'input'>>;
  deleteSpecialDiscount?: Resolver<Maybe<ResolversTypes['DeleteSpecialDiscountPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSpecialDiscountArgs, 'input'>>;
  deleteSpecialDiscountById?: Resolver<Maybe<ResolversTypes['DeleteSpecialDiscountPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSpecialDiscountByIdArgs, 'input'>>;
  deleteState?: Resolver<Maybe<ResolversTypes['DeleteStatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteStateArgs, 'input'>>;
  deleteStateById?: Resolver<Maybe<ResolversTypes['DeleteStatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteStateByIdArgs, 'input'>>;
  deleteStatistic?: Resolver<Maybe<ResolversTypes['DeleteStatisticPayload']>, ParentType, ContextType, RequireFields<MutationdeleteStatisticArgs, 'input'>>;
  deleteStatisticById?: Resolver<Maybe<ResolversTypes['DeleteStatisticPayload']>, ParentType, ContextType, RequireFields<MutationdeleteStatisticByIdArgs, 'input'>>;
  deleteStock?: Resolver<Maybe<ResolversTypes['DeleteStockPayload']>, ParentType, ContextType, RequireFields<MutationdeleteStockArgs, 'input'>>;
  deleteStockById?: Resolver<Maybe<ResolversTypes['DeleteStockPayload']>, ParentType, ContextType, RequireFields<MutationdeleteStockByIdArgs, 'input'>>;
  deleteSurvey?: Resolver<Maybe<ResolversTypes['DeleteSurveyPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSurveyArgs, 'input'>>;
  deleteSurveyById?: Resolver<Maybe<ResolversTypes['DeleteSurveyPayload']>, ParentType, ContextType, RequireFields<MutationdeleteSurveyByIdArgs, 'input'>>;
  deleteTag?: Resolver<Maybe<ResolversTypes['DeleteTagPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTagArgs, 'input'>>;
  deleteTagById?: Resolver<Maybe<ResolversTypes['DeleteTagPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTagByIdArgs, 'input'>>;
  deleteTarget?: Resolver<Maybe<ResolversTypes['DeleteTargetPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTargetArgs, 'input'>>;
  deleteTargetById?: Resolver<Maybe<ResolversTypes['DeleteTargetPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTargetByIdArgs, 'input'>>;
  deleteTaxCategory?: Resolver<Maybe<ResolversTypes['DeleteTaxCategoryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTaxCategoryArgs, 'input'>>;
  deleteTaxCategoryById?: Resolver<Maybe<ResolversTypes['DeleteTaxCategoryPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTaxCategoryByIdArgs, 'input'>>;
  deleteTaxRate?: Resolver<Maybe<ResolversTypes['DeleteTaxRatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteTaxRateArgs, 'input'>>;
  deleteTaxRateById?: Resolver<Maybe<ResolversTypes['DeleteTaxRatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteTaxRateByIdArgs, 'input'>>;
  deleteTaxRule?: Resolver<Maybe<ResolversTypes['DeleteTaxRulePayload']>, ParentType, ContextType, RequireFields<MutationdeleteTaxRuleArgs, 'input'>>;
  deleteTaxRuleById?: Resolver<Maybe<ResolversTypes['DeleteTaxRulePayload']>, ParentType, ContextType, RequireFields<MutationdeleteTaxRuleByIdArgs, 'input'>>;
  deleteTemplate?: Resolver<Maybe<ResolversTypes['DeleteTemplatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteTemplateArgs, 'input'>>;
  deleteTemplateById?: Resolver<Maybe<ResolversTypes['DeleteTemplatePayload']>, ParentType, ContextType, RequireFields<MutationdeleteTemplateByIdArgs, 'input'>>;
  deleteTheme?: Resolver<Maybe<ResolversTypes['DeleteThemePayload']>, ParentType, ContextType, RequireFields<MutationdeleteThemeArgs, 'input'>>;
  deleteThemeById?: Resolver<Maybe<ResolversTypes['DeleteThemePayload']>, ParentType, ContextType, RequireFields<MutationdeleteThemeByIdArgs, 'input'>>;
  deleteTicketing?: Resolver<Maybe<ResolversTypes['DeleteTicketingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTicketingArgs, 'input'>>;
  deleteTicketingById?: Resolver<Maybe<ResolversTypes['DeleteTicketingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTicketingByIdArgs, 'input'>>;
  deleteTraining?: Resolver<Maybe<ResolversTypes['DeleteTrainingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTrainingArgs, 'input'>>;
  deleteTrainingById?: Resolver<Maybe<ResolversTypes['DeleteTrainingPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTrainingByIdArgs, 'input'>>;
  deleteTransaction?: Resolver<Maybe<ResolversTypes['DeleteTransactionPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTransactionArgs, 'input'>>;
  deleteTransactionById?: Resolver<Maybe<ResolversTypes['DeleteTransactionPayload']>, ParentType, ContextType, RequireFields<MutationdeleteTransactionByIdArgs, 'input'>>;
  deleteUploadFile?: Resolver<Maybe<ResolversTypes['DeleteUploadFilePayload']>, ParentType, ContextType, RequireFields<MutationdeleteUploadFileArgs, 'input'>>;
  deleteUploadFileById?: Resolver<Maybe<ResolversTypes['DeleteUploadFilePayload']>, ParentType, ContextType, RequireFields<MutationdeleteUploadFileByIdArgs, 'input'>>;
  deleteUser?: Resolver<Maybe<ResolversTypes['DeleteUserPayload']>, ParentType, ContextType, RequireFields<MutationdeleteUserArgs, 'input'>>;
  deleteUserById?: Resolver<Maybe<ResolversTypes['DeleteUserPayload']>, ParentType, ContextType, RequireFields<MutationdeleteUserByIdArgs, 'input'>>;
  deleteVendor?: Resolver<Maybe<ResolversTypes['DeleteVendorPayload']>, ParentType, ContextType, RequireFields<MutationdeleteVendorArgs, 'input'>>;
  deleteVendorById?: Resolver<Maybe<ResolversTypes['DeleteVendorPayload']>, ParentType, ContextType, RequireFields<MutationdeleteVendorByIdArgs, 'input'>>;
  deleteVisit?: Resolver<Maybe<ResolversTypes['DeleteVisitPayload']>, ParentType, ContextType, RequireFields<MutationdeleteVisitArgs, 'input'>>;
  deleteVisitById?: Resolver<Maybe<ResolversTypes['DeleteVisitPayload']>, ParentType, ContextType, RequireFields<MutationdeleteVisitByIdArgs, 'input'>>;
  deleteWarehouse?: Resolver<Maybe<ResolversTypes['DeleteWarehousePayload']>, ParentType, ContextType, RequireFields<MutationdeleteWarehouseArgs, 'input'>>;
  deleteWarehouseById?: Resolver<Maybe<ResolversTypes['DeleteWarehousePayload']>, ParentType, ContextType, RequireFields<MutationdeleteWarehouseByIdArgs, 'input'>>;
  deleteWebhook?: Resolver<Maybe<ResolversTypes['DeleteWebhookPayload']>, ParentType, ContextType, RequireFields<MutationdeleteWebhookArgs, 'input'>>;
  deleteWebhookById?: Resolver<Maybe<ResolversTypes['DeleteWebhookPayload']>, ParentType, ContextType, RequireFields<MutationdeleteWebhookByIdArgs, 'input'>>;
  deleteWebsite?: Resolver<Maybe<ResolversTypes['DeleteWebsitePayload']>, ParentType, ContextType, RequireFields<MutationdeleteWebsiteArgs, 'input'>>;
  deleteWebsiteById?: Resolver<Maybe<ResolversTypes['DeleteWebsitePayload']>, ParentType, ContextType, RequireFields<MutationdeleteWebsiteByIdArgs, 'input'>>;
  deleteWishlist?: Resolver<Maybe<ResolversTypes['DeleteWishlistPayload']>, ParentType, ContextType, RequireFields<MutationdeleteWishlistArgs, 'input'>>;
  deleteWishlistById?: Resolver<Maybe<ResolversTypes['DeleteWishlistPayload']>, ParentType, ContextType, RequireFields<MutationdeleteWishlistByIdArgs, 'input'>>;
  deleteWorkspace?: Resolver<Maybe<ResolversTypes['DeleteWorkspacePayload']>, ParentType, ContextType, RequireFields<MutationdeleteWorkspaceArgs, 'input'>>;
  deleteWorkspaceById?: Resolver<Maybe<ResolversTypes['DeleteWorkspacePayload']>, ParentType, ContextType, RequireFields<MutationdeleteWorkspaceByIdArgs, 'input'>>;
  deleteZone?: Resolver<Maybe<ResolversTypes['DeleteZonePayload']>, ParentType, ContextType, RequireFields<MutationdeleteZoneArgs, 'input'>>;
  deleteZoneById?: Resolver<Maybe<ResolversTypes['DeleteZonePayload']>, ParentType, ContextType, RequireFields<MutationdeleteZoneByIdArgs, 'input'>>;
}>;

export type CreateAccountPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateAccountPayload'] = ResolversParentTypes['CreateAccountPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  account?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  accountEdge?: Resolver<Maybe<ResolversTypes['AccountsEdge']>, ParentType, ContextType, RequireFields<CreateAccountPayloadaccountEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateAgreementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateAgreementPayload'] = ResolversParentTypes['CreateAgreementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  agreement?: Resolver<Maybe<ResolversTypes['Agreement']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  agreementEdge?: Resolver<Maybe<ResolversTypes['AgreementsEdge']>, ParentType, ContextType, RequireFields<CreateAgreementPayloadagreementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateAnalyticPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateAnalyticPayload'] = ResolversParentTypes['CreateAnalyticPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  analytic?: Resolver<Maybe<ResolversTypes['Analytic']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  analyticEdge?: Resolver<Maybe<ResolversTypes['AnalyticsEdge']>, ParentType, ContextType, RequireFields<CreateAnalyticPayloadanalyticEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateApitokenPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateApitokenPayload'] = ResolversParentTypes['CreateApitokenPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  apitoken?: Resolver<Maybe<ResolversTypes['Apitoken']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  apitokenEdge?: Resolver<Maybe<ResolversTypes['ApitokensEdge']>, ParentType, ContextType, RequireFields<CreateApitokenPayloadapitokenEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateArticlePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateArticlePayload'] = ResolversParentTypes['CreateArticlePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  article?: Resolver<Maybe<ResolversTypes['Article']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  articleEdge?: Resolver<Maybe<ResolversTypes['ArticlesEdge']>, ParentType, ContextType, RequireFields<CreateArticlePayloadarticleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateAttributePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateAttributePayload'] = ResolversParentTypes['CreateAttributePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  attributeEdge?: Resolver<Maybe<ResolversTypes['AttributesEdge']>, ParentType, ContextType, RequireFields<CreateAttributePayloadattributeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateBrandPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateBrandPayload'] = ResolversParentTypes['CreateBrandPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brand?: Resolver<Maybe<ResolversTypes['Brand']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  brandEdge?: Resolver<Maybe<ResolversTypes['BrandsEdge']>, ParentType, ContextType, RequireFields<CreateBrandPayloadbrandEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCartPriceRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCartPriceRulePayload'] = ResolversParentTypes['CreateCartPriceRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cartPriceRule?: Resolver<Maybe<ResolversTypes['CartPriceRule']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  cartPriceRuleEdge?: Resolver<Maybe<ResolversTypes['CartPriceRulesEdge']>, ParentType, ContextType, RequireFields<CreateCartPriceRulePayloadcartPriceRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCasePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCasePayload'] = ResolversParentTypes['CreateCasePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  case?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  caseEdge?: Resolver<Maybe<ResolversTypes['CasesEdge']>, ParentType, ContextType, RequireFields<CreateCasePayloadcaseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCatalogPriceRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCatalogPriceRulePayload'] = ResolversParentTypes['CreateCatalogPriceRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  catalogPriceRule?: Resolver<Maybe<ResolversTypes['CatalogPriceRule']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  catalogPriceRuleEdge?: Resolver<Maybe<ResolversTypes['CatalogPriceRulesEdge']>, ParentType, ContextType, RequireFields<CreateCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCategoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCategoryPayload'] = ResolversParentTypes['CreateCategoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  categoryEdge?: Resolver<Maybe<ResolversTypes['CategoriesEdge']>, ParentType, ContextType, RequireFields<CreateCategoryPayloadcategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateChannelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateChannelPayload'] = ResolversParentTypes['CreateChannelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  channelEdge?: Resolver<Maybe<ResolversTypes['ChannelsEdge']>, ParentType, ContextType, RequireFields<CreateChannelPayloadchannelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateChecklistPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateChecklistPayload'] = ResolversParentTypes['CreateChecklistPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  checklist?: Resolver<Maybe<ResolversTypes['Checklist']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  checklistEdge?: Resolver<Maybe<ResolversTypes['ChecklistsEdge']>, ParentType, ContextType, RequireFields<CreateChecklistPayloadchecklistEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCityPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCityPayload'] = ResolversParentTypes['CreateCityPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  cityEdge?: Resolver<Maybe<ResolversTypes['CitiesEdge']>, ParentType, ContextType, RequireFields<CreateCityPayloadcityEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCollectionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCollectionPayload'] = ResolversParentTypes['CreateCollectionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  collectionEdge?: Resolver<Maybe<ResolversTypes['CollectionsEdge']>, ParentType, ContextType, RequireFields<CreateCollectionPayloadcollectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCommentPayload'] = ResolversParentTypes['CreateCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Comment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['CommentsEdge']>, ParentType, ContextType, RequireFields<CreateCommentPayloadcommentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateContentTypePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateContentTypePayload'] = ResolversParentTypes['CreateContentTypePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<Maybe<ResolversTypes['ContentType']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  contentTypeEdge?: Resolver<Maybe<ResolversTypes['ContentTypesEdge']>, ParentType, ContextType, RequireFields<CreateContentTypePayloadcontentTypeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateContractPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateContractPayload'] = ResolversParentTypes['CreateContractPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contract?: Resolver<Maybe<ResolversTypes['Contract']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  contractEdge?: Resolver<Maybe<ResolversTypes['ContractsEdge']>, ParentType, ContextType, RequireFields<CreateContractPayloadcontractEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCountryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCountryPayload'] = ResolversParentTypes['CreateCountryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  countryEdge?: Resolver<Maybe<ResolversTypes['CountriesEdge']>, ParentType, ContextType, RequireFields<CreateCountryPayloadcountryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCouponPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCouponPayload'] = ResolversParentTypes['CreateCouponPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coupon?: Resolver<Maybe<ResolversTypes['Coupon']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  couponEdge?: Resolver<Maybe<ResolversTypes['CouponsEdge']>, ParentType, ContextType, RequireFields<CreateCouponPayloadcouponEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCreditMemoPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCreditMemoPayload'] = ResolversParentTypes['CreateCreditMemoPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  creditMemo?: Resolver<Maybe<ResolversTypes['CreditMemo']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  creditMemoEdge?: Resolver<Maybe<ResolversTypes['CreditMemosEdge']>, ParentType, ContextType, RequireFields<CreateCreditMemoPayloadcreditMemoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCurrencyPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCurrencyPayload'] = ResolversParentTypes['CreateCurrencyPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencyEdge?: Resolver<Maybe<ResolversTypes['CurrenciesEdge']>, ParentType, ContextType, RequireFields<CreateCurrencyPayloadcurrencyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCurrencyRatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCurrencyRatePayload'] = ResolversParentTypes['CreateCurrencyRatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currencyRate?: Resolver<Maybe<ResolversTypes['CurrencyRate']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencyRateEdge?: Resolver<Maybe<ResolversTypes['CurrencyRatesEdge']>, ParentType, ContextType, RequireFields<CreateCurrencyRatePayloadcurrencyRateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCurrencySymbolPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCurrencySymbolPayload'] = ResolversParentTypes['CreateCurrencySymbolPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currencySymbol?: Resolver<Maybe<ResolversTypes['CurrencySymbol']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencySymbolEdge?: Resolver<Maybe<ResolversTypes['CurrencySymbolsEdge']>, ParentType, ContextType, RequireFields<CreateCurrencySymbolPayloadcurrencySymbolEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCustomerGroupPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCustomerGroupPayload'] = ResolversParentTypes['CreateCustomerGroupPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customerGroupEdge?: Resolver<Maybe<ResolversTypes['CustomerGroupsEdge']>, ParentType, ContextType, RequireFields<CreateCustomerGroupPayloadcustomerGroupEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCustomerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCustomerPayload'] = ResolversParentTypes['CreateCustomerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customerEdge?: Resolver<Maybe<ResolversTypes['CustomersEdge']>, ParentType, ContextType, RequireFields<CreateCustomerPayloadcustomerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateCustomizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateCustomizationPayload'] = ResolversParentTypes['CreateCustomizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customization?: Resolver<Maybe<ResolversTypes['Customization']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customizationEdge?: Resolver<Maybe<ResolversTypes['CustomizationsEdge']>, ParentType, ContextType, RequireFields<CreateCustomizationPayloadcustomizationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateDashboardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateDashboardPayload'] = ResolversParentTypes['CreateDashboardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dashboard?: Resolver<Maybe<ResolversTypes['Dashboard']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  dashboardEdge?: Resolver<Maybe<ResolversTypes['DashboardsEdge']>, ParentType, ContextType, RequireFields<CreateDashboardPayloaddashboardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateDeepdivePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateDeepdivePayload'] = ResolversParentTypes['CreateDeepdivePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deepdive?: Resolver<Maybe<ResolversTypes['Deepdive']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  deepdiveEdge?: Resolver<Maybe<ResolversTypes['DeepdivesEdge']>, ParentType, ContextType, RequireFields<CreateDeepdivePayloaddeepdiveEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateDigiboardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateDigiboardPayload'] = ResolversParentTypes['CreateDigiboardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  digiboard?: Resolver<Maybe<ResolversTypes['Digiboard']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  digiboardEdge?: Resolver<Maybe<ResolversTypes['DigiboardsEdge']>, ParentType, ContextType, RequireFields<CreateDigiboardPayloaddigiboardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateEmailPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateEmailPayload'] = ResolversParentTypes['CreateEmailPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['Email']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  emailEdge?: Resolver<Maybe<ResolversTypes['EmailsEdge']>, ParentType, ContextType, RequireFields<CreateEmailPayloademailEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateEndofshiftPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateEndofshiftPayload'] = ResolversParentTypes['CreateEndofshiftPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endofshift?: Resolver<Maybe<ResolversTypes['Endofshift']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  endofshiftEdge?: Resolver<Maybe<ResolversTypes['EndofshiftsEdge']>, ParentType, ContextType, RequireFields<CreateEndofshiftPayloadendofshiftEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateEventPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateEventPayload'] = ResolversParentTypes['CreateEventPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  event?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  eventEdge?: Resolver<Maybe<ResolversTypes['EventsEdge']>, ParentType, ContextType, RequireFields<CreateEventPayloadeventEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateFullfillmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateFullfillmentPayload'] = ResolversParentTypes['CreateFullfillmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullfillment?: Resolver<Maybe<ResolversTypes['Fullfillment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  fullfillmentEdge?: Resolver<Maybe<ResolversTypes['FullfillmentsEdge']>, ParentType, ContextType, RequireFields<CreateFullfillmentPayloadfullfillmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateGiftCertificatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateGiftCertificatePayload'] = ResolversParentTypes['CreateGiftCertificatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  giftCertificate?: Resolver<Maybe<ResolversTypes['GiftCertificate']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  giftCertificateEdge?: Resolver<Maybe<ResolversTypes['GiftCertificatesEdge']>, ParentType, ContextType, RequireFields<CreateGiftCertificatePayloadgiftCertificateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateGlossaryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateGlossaryPayload'] = ResolversParentTypes['CreateGlossaryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  glossary?: Resolver<Maybe<ResolversTypes['Glossary']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  glossaryEdge?: Resolver<Maybe<ResolversTypes['GlossariesEdge']>, ParentType, ContextType, RequireFields<CreateGlossaryPayloadglossaryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateImportmPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateImportmPayload'] = ResolversParentTypes['CreateImportmPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  importm?: Resolver<Maybe<ResolversTypes['Importm']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  importmEdge?: Resolver<Maybe<ResolversTypes['ImportmsEdge']>, ParentType, ContextType, RequireFields<CreateImportmPayloadimportmEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateIntegrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateIntegrationPayload'] = ResolversParentTypes['CreateIntegrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  integration?: Resolver<Maybe<ResolversTypes['Integration']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  integrationEdge?: Resolver<Maybe<ResolversTypes['IntegrationsEdge']>, ParentType, ContextType, RequireFields<CreateIntegrationPayloadintegrationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateInternalizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateInternalizationPayload'] = ResolversParentTypes['CreateInternalizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  internalization?: Resolver<Maybe<ResolversTypes['Internalization']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  internalizationEdge?: Resolver<Maybe<ResolversTypes['InternalizationsEdge']>, ParentType, ContextType, RequireFields<CreateInternalizationPayloadinternalizationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateInvitationPayload'] = ResolversParentTypes['CreateInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['Invitation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  invitationEdge?: Resolver<Maybe<ResolversTypes['InvitationsEdge']>, ParentType, ContextType, RequireFields<CreateInvitationPayloadinvitationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateInvoicePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateInvoicePayload'] = ResolversParentTypes['CreateInvoicePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  invoiceEdge?: Resolver<Maybe<ResolversTypes['InvoicesEdge']>, ParentType, ContextType, RequireFields<CreateInvoicePayloadinvoiceEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateLeadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateLeadPayload'] = ResolversParentTypes['CreateLeadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lead?: Resolver<Maybe<ResolversTypes['Lead']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  leadEdge?: Resolver<Maybe<ResolversTypes['LeadsEdge']>, ParentType, ContextType, RequireFields<CreateLeadPayloadleadEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateManufacturerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateManufacturerPayload'] = ResolversParentTypes['CreateManufacturerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturer?: Resolver<Maybe<ResolversTypes['Manufacturer']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  manufacturerEdge?: Resolver<Maybe<ResolversTypes['ManufacturersEdge']>, ParentType, ContextType, RequireFields<CreateManufacturerPayloadmanufacturerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateMediamanagerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateMediamanagerPayload'] = ResolversParentTypes['CreateMediamanagerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['Mediamanager']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  mediamanagerEdge?: Resolver<Maybe<ResolversTypes['MediamanagersEdge']>, ParentType, ContextType, RequireFields<CreateMediamanagerPayloadmediamanagerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateMeetingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateMeetingPayload'] = ResolversParentTypes['CreateMeetingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  meeting?: Resolver<Maybe<ResolversTypes['Meeting']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  meetingEdge?: Resolver<Maybe<ResolversTypes['MeetingsEdge']>, ParentType, ContextType, RequireFields<CreateMeetingPayloadmeetingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateMessagePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateMessagePayload'] = ResolversParentTypes['CreateMessagePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  messageEdge?: Resolver<Maybe<ResolversTypes['MessagesEdge']>, ParentType, ContextType, RequireFields<CreateMessagePayloadmessageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateNewsletterPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateNewsletterPayload'] = ResolversParentTypes['CreateNewsletterPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  newsletter?: Resolver<Maybe<ResolversTypes['Newsletter']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  newsletterEdge?: Resolver<Maybe<ResolversTypes['NewslettersEdge']>, ParentType, ContextType, RequireFields<CreateNewsletterPayloadnewsletterEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateOotoPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateOotoPayload'] = ResolversParentTypes['CreateOotoPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ooto?: Resolver<Maybe<ResolversTypes['Ooto']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ootoEdge?: Resolver<Maybe<ResolversTypes['OotosEdge']>, ParentType, ContextType, RequireFields<CreateOotoPayloadootoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateOpportunityPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateOpportunityPayload'] = ResolversParentTypes['CreateOpportunityPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  opportunity?: Resolver<Maybe<ResolversTypes['Opportunity']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  opportunityEdge?: Resolver<Maybe<ResolversTypes['OpportunitiesEdge']>, ParentType, ContextType, RequireFields<CreateOpportunityPayloadopportunityEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateOrderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateOrderPayload'] = ResolversParentTypes['CreateOrderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  orderEdge?: Resolver<Maybe<ResolversTypes['OrdersEdge']>, ParentType, ContextType, RequireFields<CreateOrderPayloadorderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatePagePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatePagePayload'] = ResolversParentTypes['CreatePagePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pageEdge?: Resolver<Maybe<ResolversTypes['PagesEdge']>, ParentType, ContextType, RequireFields<CreatePagePayloadpageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatePartnerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatePartnerPayload'] = ResolversParentTypes['CreatePartnerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  partner?: Resolver<Maybe<ResolversTypes['Partner']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  partnerEdge?: Resolver<Maybe<ResolversTypes['PartnersEdge']>, ParentType, ContextType, RequireFields<CreatePartnerPayloadpartnerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatePaymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatePaymentPayload'] = ResolversParentTypes['CreatePaymentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  paymentEdge?: Resolver<Maybe<ResolversTypes['PaymentsEdge']>, ParentType, ContextType, RequireFields<CreatePaymentPayloadpaymentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatePermissionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatePermissionPayload'] = ResolversParentTypes['CreatePermissionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['Permission']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionEdge?: Resolver<Maybe<ResolversTypes['PermissionsEdge']>, ParentType, ContextType, RequireFields<CreatePermissionPayloadpermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatePluginPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatePluginPayload'] = ResolversParentTypes['CreatePluginPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  plugin?: Resolver<Maybe<ResolversTypes['Plugin']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pluginEdge?: Resolver<Maybe<ResolversTypes['PluginsEdge']>, ParentType, ContextType, RequireFields<CreatePluginPayloadpluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatePollPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreatePollPayload'] = ResolversParentTypes['CreatePollPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['Poll']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pollEdge?: Resolver<Maybe<ResolversTypes['PollsEdge']>, ParentType, ContextType, RequireFields<CreatePollPayloadpollEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateProductTypePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateProductTypePayload'] = ResolversParentTypes['CreateProductTypePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  productTypeEdge?: Resolver<Maybe<ResolversTypes['ProductTypesEdge']>, ParentType, ContextType, RequireFields<CreateProductTypePayloadproductTypeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateProductPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateProductPayload'] = ResolversParentTypes['CreateProductPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  productEdge?: Resolver<Maybe<ResolversTypes['ProductsEdge']>, ParentType, ContextType, RequireFields<CreateProductPayloadproductEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateProjectPayload'] = ResolversParentTypes['CreateProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  projectEdge?: Resolver<Maybe<ResolversTypes['ProjectsEdge']>, ParentType, ContextType, RequireFields<CreateProjectPayloadprojectEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateProviderPayload'] = ResolversParentTypes['CreateProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['Provider']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  providerEdge?: Resolver<Maybe<ResolversTypes['ProvidersEdge']>, ParentType, ContextType, RequireFields<CreateProviderPayloadproviderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateQuotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateQuotePayload'] = ResolversParentTypes['CreateQuotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  quoteEdge?: Resolver<Maybe<ResolversTypes['QuotesEdge']>, ParentType, ContextType, RequireFields<CreateQuotePayloadquoteEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateRatingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateRatingPayload'] = ResolversParentTypes['CreateRatingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rating?: Resolver<Maybe<ResolversTypes['Rating']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ratingEdge?: Resolver<Maybe<ResolversTypes['RatingsEdge']>, ParentType, ContextType, RequireFields<CreateRatingPayloadratingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateReportPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateReportPayload'] = ResolversParentTypes['CreateReportPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  report?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reportEdge?: Resolver<Maybe<ResolversTypes['ReportsEdge']>, ParentType, ContextType, RequireFields<CreateReportPayloadreportEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateReturnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateReturnPayload'] = ResolversParentTypes['CreateReturnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  return?: Resolver<Maybe<ResolversTypes['Return']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  returnEdge?: Resolver<Maybe<ResolversTypes['ReturnsEdge']>, ParentType, ContextType, RequireFields<CreateReturnPayloadreturnEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateReviewPayload'] = ResolversParentTypes['CreateReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<CreateReviewPayloadreviewEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateRewardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateRewardPayload'] = ResolversParentTypes['CreateRewardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reward?: Resolver<Maybe<ResolversTypes['Reward']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  rewardEdge?: Resolver<Maybe<ResolversTypes['RewardsEdge']>, ParentType, ContextType, RequireFields<CreateRewardPayloadrewardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateRolePayload'] = ResolversParentTypes['CreateRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleEdge?: Resolver<Maybe<ResolversTypes['RolesEdge']>, ParentType, ContextType, RequireFields<CreateRolePayloadroleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSchedulerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSchedulerPayload'] = ResolversParentTypes['CreateSchedulerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scheduler?: Resolver<Maybe<ResolversTypes['Scheduler']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  schedulerEdge?: Resolver<Maybe<ResolversTypes['SchedulersEdge']>, ParentType, ContextType, RequireFields<CreateSchedulerPayloadschedulerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSegmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSegmentPayload'] = ResolversParentTypes['CreateSegmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  segment?: Resolver<Maybe<ResolversTypes['Segment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  segmentEdge?: Resolver<Maybe<ResolversTypes['SegmentsEdge']>, ParentType, ContextType, RequireFields<CreateSegmentPayloadsegmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSettingPayload'] = ResolversParentTypes['CreateSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  setting?: Resolver<Maybe<ResolversTypes['Setting']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  settingEdge?: Resolver<Maybe<ResolversTypes['SettingsEdge']>, ParentType, ContextType, RequireFields<CreateSettingPayloadsettingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateShipmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateShipmentPayload'] = ResolversParentTypes['CreateShipmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shipment?: Resolver<Maybe<ResolversTypes['Shipment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  shipmentEdge?: Resolver<Maybe<ResolversTypes['ShipmentsEdge']>, ParentType, ContextType, RequireFields<CreateShipmentPayloadshipmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSpecialDiscountPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSpecialDiscountPayload'] = ResolversParentTypes['CreateSpecialDiscountPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  specialDiscount?: Resolver<Maybe<ResolversTypes['SpecialDiscount']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  specialDiscountEdge?: Resolver<Maybe<ResolversTypes['SpecialDiscountsEdge']>, ParentType, ContextType, RequireFields<CreateSpecialDiscountPayloadspecialDiscountEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateStatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateStatePayload'] = ResolversParentTypes['CreateStatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stateEdge?: Resolver<Maybe<ResolversTypes['StatesEdge']>, ParentType, ContextType, RequireFields<CreateStatePayloadstateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateStatisticPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateStatisticPayload'] = ResolversParentTypes['CreateStatisticPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  statistic?: Resolver<Maybe<ResolversTypes['Statistic']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  statisticEdge?: Resolver<Maybe<ResolversTypes['StatisticsEdge']>, ParentType, ContextType, RequireFields<CreateStatisticPayloadstatisticEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateStockPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateStockPayload'] = ResolversParentTypes['CreateStockPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stock?: Resolver<Maybe<ResolversTypes['Stock']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stockEdge?: Resolver<Maybe<ResolversTypes['StocksEdge']>, ParentType, ContextType, RequireFields<CreateStockPayloadstockEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateSurveyPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateSurveyPayload'] = ResolversParentTypes['CreateSurveyPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  survey?: Resolver<Maybe<ResolversTypes['Survey']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  surveyEdge?: Resolver<Maybe<ResolversTypes['SurveysEdge']>, ParentType, ContextType, RequireFields<CreateSurveyPayloadsurveyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTagPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTagPayload'] = ResolversParentTypes['CreateTagPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  tagEdge?: Resolver<Maybe<ResolversTypes['TagsEdge']>, ParentType, ContextType, RequireFields<CreateTagPayloadtagEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTargetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTargetPayload'] = ResolversParentTypes['CreateTargetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['Target']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  targetEdge?: Resolver<Maybe<ResolversTypes['TargetsEdge']>, ParentType, ContextType, RequireFields<CreateTargetPayloadtargetEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTaxCategoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTaxCategoryPayload'] = ResolversParentTypes['CreateTaxCategoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxCategoryEdge?: Resolver<Maybe<ResolversTypes['TaxCategoriesEdge']>, ParentType, ContextType, RequireFields<CreateTaxCategoryPayloadtaxCategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTaxRatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTaxRatePayload'] = ResolversParentTypes['CreateTaxRatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxRateEdge?: Resolver<Maybe<ResolversTypes['TaxRatesEdge']>, ParentType, ContextType, RequireFields<CreateTaxRatePayloadtaxRateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTaxRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTaxRulePayload'] = ResolversParentTypes['CreateTaxRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxRule?: Resolver<Maybe<ResolversTypes['TaxRule']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxRuleEdge?: Resolver<Maybe<ResolversTypes['TaxRulesEdge']>, ParentType, ContextType, RequireFields<CreateTaxRulePayloadtaxRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTemplatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTemplatePayload'] = ResolversParentTypes['CreateTemplatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<CreateTemplatePayloadtemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateThemePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateThemePayload'] = ResolversParentTypes['CreateThemePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  theme?: Resolver<Maybe<ResolversTypes['Theme']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  themeEdge?: Resolver<Maybe<ResolversTypes['ThemesEdge']>, ParentType, ContextType, RequireFields<CreateThemePayloadthemeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTicketingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTicketingPayload'] = ResolversParentTypes['CreateTicketingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ticketing?: Resolver<Maybe<ResolversTypes['Ticketing']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ticketingEdge?: Resolver<Maybe<ResolversTypes['TicketingsEdge']>, ParentType, ContextType, RequireFields<CreateTicketingPayloadticketingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTrainingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTrainingPayload'] = ResolversParentTypes['CreateTrainingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  training?: Resolver<Maybe<ResolversTypes['Training']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  trainingEdge?: Resolver<Maybe<ResolversTypes['TrainingsEdge']>, ParentType, ContextType, RequireFields<CreateTrainingPayloadtrainingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateTransactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateTransactionPayload'] = ResolversParentTypes['CreateTransactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  transactionEdge?: Resolver<Maybe<ResolversTypes['TransactionsEdge']>, ParentType, ContextType, RequireFields<CreateTransactionPayloadtransactionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateUploadFilePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateUploadFilePayload'] = ResolversParentTypes['CreateUploadFilePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uploadFile?: Resolver<Maybe<ResolversTypes['UploadFile']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  uploadFileEdge?: Resolver<Maybe<ResolversTypes['UploadFilesEdge']>, ParentType, ContextType, RequireFields<CreateUploadFilePayloaduploadFileEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateUserPayload'] = ResolversParentTypes['CreateUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<CreateUserPayloaduserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateVendorPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateVendorPayload'] = ResolversParentTypes['CreateVendorPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vendor?: Resolver<Maybe<ResolversTypes['Vendor']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  vendorEdge?: Resolver<Maybe<ResolversTypes['VendorsEdge']>, ParentType, ContextType, RequireFields<CreateVendorPayloadvendorEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateVisitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateVisitPayload'] = ResolversParentTypes['CreateVisitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visit?: Resolver<Maybe<ResolversTypes['Visit']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  visitEdge?: Resolver<Maybe<ResolversTypes['VisitsEdge']>, ParentType, ContextType, RequireFields<CreateVisitPayloadvisitEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateWarehousePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateWarehousePayload'] = ResolversParentTypes['CreateWarehousePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  warehouseEdge?: Resolver<Maybe<ResolversTypes['WarehousesEdge']>, ParentType, ContextType, RequireFields<CreateWarehousePayloadwarehouseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateWebhookPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateWebhookPayload'] = ResolversParentTypes['CreateWebhookPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  webhook?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webhookEdge?: Resolver<Maybe<ResolversTypes['WebhooksEdge']>, ParentType, ContextType, RequireFields<CreateWebhookPayloadwebhookEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateWebsitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateWebsitePayload'] = ResolversParentTypes['CreateWebsitePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['Website']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  websiteEdge?: Resolver<Maybe<ResolversTypes['WebsitesEdge']>, ParentType, ContextType, RequireFields<CreateWebsitePayloadwebsiteEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateWishlistPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateWishlistPayload'] = ResolversParentTypes['CreateWishlistPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  wishlist?: Resolver<Maybe<ResolversTypes['Wishlist']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  wishlistEdge?: Resolver<Maybe<ResolversTypes['WishlistsEdge']>, ParentType, ContextType, RequireFields<CreateWishlistPayloadwishlistEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateWorkspacePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateWorkspacePayload'] = ResolversParentTypes['CreateWorkspacePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspace?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  workspaceEdge?: Resolver<Maybe<ResolversTypes['WorkspacesEdge']>, ParentType, ContextType, RequireFields<CreateWorkspacePayloadworkspaceEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreateZonePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CreateZonePayload'] = ResolversParentTypes['CreateZonePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  zone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  zoneEdge?: Resolver<Maybe<ResolversTypes['ZonesEdge']>, ParentType, ContextType, RequireFields<CreateZonePayloadzoneEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateAccountPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateAccountPayload'] = ResolversParentTypes['UpdateAccountPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  account?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  accountEdge?: Resolver<Maybe<ResolversTypes['AccountsEdge']>, ParentType, ContextType, RequireFields<UpdateAccountPayloadaccountEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateAgreementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateAgreementPayload'] = ResolversParentTypes['UpdateAgreementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  agreement?: Resolver<Maybe<ResolversTypes['Agreement']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  agreementEdge?: Resolver<Maybe<ResolversTypes['AgreementsEdge']>, ParentType, ContextType, RequireFields<UpdateAgreementPayloadagreementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateAnalyticPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateAnalyticPayload'] = ResolversParentTypes['UpdateAnalyticPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  analytic?: Resolver<Maybe<ResolversTypes['Analytic']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  analyticEdge?: Resolver<Maybe<ResolversTypes['AnalyticsEdge']>, ParentType, ContextType, RequireFields<UpdateAnalyticPayloadanalyticEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateApitokenPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateApitokenPayload'] = ResolversParentTypes['UpdateApitokenPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  apitoken?: Resolver<Maybe<ResolversTypes['Apitoken']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  apitokenEdge?: Resolver<Maybe<ResolversTypes['ApitokensEdge']>, ParentType, ContextType, RequireFields<UpdateApitokenPayloadapitokenEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateArticlePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateArticlePayload'] = ResolversParentTypes['UpdateArticlePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  article?: Resolver<Maybe<ResolversTypes['Article']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  articleEdge?: Resolver<Maybe<ResolversTypes['ArticlesEdge']>, ParentType, ContextType, RequireFields<UpdateArticlePayloadarticleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateAttributePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateAttributePayload'] = ResolversParentTypes['UpdateAttributePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  attributeEdge?: Resolver<Maybe<ResolversTypes['AttributesEdge']>, ParentType, ContextType, RequireFields<UpdateAttributePayloadattributeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateBrandPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateBrandPayload'] = ResolversParentTypes['UpdateBrandPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brand?: Resolver<Maybe<ResolversTypes['Brand']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  brandEdge?: Resolver<Maybe<ResolversTypes['BrandsEdge']>, ParentType, ContextType, RequireFields<UpdateBrandPayloadbrandEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCartPriceRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCartPriceRulePayload'] = ResolversParentTypes['UpdateCartPriceRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cartPriceRule?: Resolver<Maybe<ResolversTypes['CartPriceRule']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  cartPriceRuleEdge?: Resolver<Maybe<ResolversTypes['CartPriceRulesEdge']>, ParentType, ContextType, RequireFields<UpdateCartPriceRulePayloadcartPriceRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCasePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCasePayload'] = ResolversParentTypes['UpdateCasePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  case?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  caseEdge?: Resolver<Maybe<ResolversTypes['CasesEdge']>, ParentType, ContextType, RequireFields<UpdateCasePayloadcaseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCatalogPriceRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCatalogPriceRulePayload'] = ResolversParentTypes['UpdateCatalogPriceRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  catalogPriceRule?: Resolver<Maybe<ResolversTypes['CatalogPriceRule']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  catalogPriceRuleEdge?: Resolver<Maybe<ResolversTypes['CatalogPriceRulesEdge']>, ParentType, ContextType, RequireFields<UpdateCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCategoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCategoryPayload'] = ResolversParentTypes['UpdateCategoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  categoryEdge?: Resolver<Maybe<ResolversTypes['CategoriesEdge']>, ParentType, ContextType, RequireFields<UpdateCategoryPayloadcategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateChannelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateChannelPayload'] = ResolversParentTypes['UpdateChannelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  channelEdge?: Resolver<Maybe<ResolversTypes['ChannelsEdge']>, ParentType, ContextType, RequireFields<UpdateChannelPayloadchannelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateChecklistPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateChecklistPayload'] = ResolversParentTypes['UpdateChecklistPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  checklist?: Resolver<Maybe<ResolversTypes['Checklist']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  checklistEdge?: Resolver<Maybe<ResolversTypes['ChecklistsEdge']>, ParentType, ContextType, RequireFields<UpdateChecklistPayloadchecklistEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCityPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCityPayload'] = ResolversParentTypes['UpdateCityPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  cityEdge?: Resolver<Maybe<ResolversTypes['CitiesEdge']>, ParentType, ContextType, RequireFields<UpdateCityPayloadcityEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCollectionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCollectionPayload'] = ResolversParentTypes['UpdateCollectionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  collectionEdge?: Resolver<Maybe<ResolversTypes['CollectionsEdge']>, ParentType, ContextType, RequireFields<UpdateCollectionPayloadcollectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCommentPayload'] = ResolversParentTypes['UpdateCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Comment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['CommentsEdge']>, ParentType, ContextType, RequireFields<UpdateCommentPayloadcommentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateContentTypePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateContentTypePayload'] = ResolversParentTypes['UpdateContentTypePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<Maybe<ResolversTypes['ContentType']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  contentTypeEdge?: Resolver<Maybe<ResolversTypes['ContentTypesEdge']>, ParentType, ContextType, RequireFields<UpdateContentTypePayloadcontentTypeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateContractPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateContractPayload'] = ResolversParentTypes['UpdateContractPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contract?: Resolver<Maybe<ResolversTypes['Contract']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  contractEdge?: Resolver<Maybe<ResolversTypes['ContractsEdge']>, ParentType, ContextType, RequireFields<UpdateContractPayloadcontractEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCountryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCountryPayload'] = ResolversParentTypes['UpdateCountryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  countryEdge?: Resolver<Maybe<ResolversTypes['CountriesEdge']>, ParentType, ContextType, RequireFields<UpdateCountryPayloadcountryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCouponPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCouponPayload'] = ResolversParentTypes['UpdateCouponPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coupon?: Resolver<Maybe<ResolversTypes['Coupon']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  couponEdge?: Resolver<Maybe<ResolversTypes['CouponsEdge']>, ParentType, ContextType, RequireFields<UpdateCouponPayloadcouponEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCreditMemoPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCreditMemoPayload'] = ResolversParentTypes['UpdateCreditMemoPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  creditMemo?: Resolver<Maybe<ResolversTypes['CreditMemo']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  creditMemoEdge?: Resolver<Maybe<ResolversTypes['CreditMemosEdge']>, ParentType, ContextType, RequireFields<UpdateCreditMemoPayloadcreditMemoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCurrencyPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCurrencyPayload'] = ResolversParentTypes['UpdateCurrencyPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencyEdge?: Resolver<Maybe<ResolversTypes['CurrenciesEdge']>, ParentType, ContextType, RequireFields<UpdateCurrencyPayloadcurrencyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCurrencyRatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCurrencyRatePayload'] = ResolversParentTypes['UpdateCurrencyRatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currencyRate?: Resolver<Maybe<ResolversTypes['CurrencyRate']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencyRateEdge?: Resolver<Maybe<ResolversTypes['CurrencyRatesEdge']>, ParentType, ContextType, RequireFields<UpdateCurrencyRatePayloadcurrencyRateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCurrencySymbolPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCurrencySymbolPayload'] = ResolversParentTypes['UpdateCurrencySymbolPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currencySymbol?: Resolver<Maybe<ResolversTypes['CurrencySymbol']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencySymbolEdge?: Resolver<Maybe<ResolversTypes['CurrencySymbolsEdge']>, ParentType, ContextType, RequireFields<UpdateCurrencySymbolPayloadcurrencySymbolEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCustomerGroupPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCustomerGroupPayload'] = ResolversParentTypes['UpdateCustomerGroupPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customerGroupEdge?: Resolver<Maybe<ResolversTypes['CustomerGroupsEdge']>, ParentType, ContextType, RequireFields<UpdateCustomerGroupPayloadcustomerGroupEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCustomerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCustomerPayload'] = ResolversParentTypes['UpdateCustomerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customerEdge?: Resolver<Maybe<ResolversTypes['CustomersEdge']>, ParentType, ContextType, RequireFields<UpdateCustomerPayloadcustomerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateCustomizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateCustomizationPayload'] = ResolversParentTypes['UpdateCustomizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customization?: Resolver<Maybe<ResolversTypes['Customization']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customizationEdge?: Resolver<Maybe<ResolversTypes['CustomizationsEdge']>, ParentType, ContextType, RequireFields<UpdateCustomizationPayloadcustomizationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateDashboardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateDashboardPayload'] = ResolversParentTypes['UpdateDashboardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dashboard?: Resolver<Maybe<ResolversTypes['Dashboard']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  dashboardEdge?: Resolver<Maybe<ResolversTypes['DashboardsEdge']>, ParentType, ContextType, RequireFields<UpdateDashboardPayloaddashboardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateDeepdivePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateDeepdivePayload'] = ResolversParentTypes['UpdateDeepdivePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deepdive?: Resolver<Maybe<ResolversTypes['Deepdive']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  deepdiveEdge?: Resolver<Maybe<ResolversTypes['DeepdivesEdge']>, ParentType, ContextType, RequireFields<UpdateDeepdivePayloaddeepdiveEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateDigiboardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateDigiboardPayload'] = ResolversParentTypes['UpdateDigiboardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  digiboard?: Resolver<Maybe<ResolversTypes['Digiboard']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  digiboardEdge?: Resolver<Maybe<ResolversTypes['DigiboardsEdge']>, ParentType, ContextType, RequireFields<UpdateDigiboardPayloaddigiboardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEmailPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEmailPayload'] = ResolversParentTypes['UpdateEmailPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['Email']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  emailEdge?: Resolver<Maybe<ResolversTypes['EmailsEdge']>, ParentType, ContextType, RequireFields<UpdateEmailPayloademailEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEndofshiftPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEndofshiftPayload'] = ResolversParentTypes['UpdateEndofshiftPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endofshift?: Resolver<Maybe<ResolversTypes['Endofshift']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  endofshiftEdge?: Resolver<Maybe<ResolversTypes['EndofshiftsEdge']>, ParentType, ContextType, RequireFields<UpdateEndofshiftPayloadendofshiftEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateEventPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateEventPayload'] = ResolversParentTypes['UpdateEventPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  event?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  eventEdge?: Resolver<Maybe<ResolversTypes['EventsEdge']>, ParentType, ContextType, RequireFields<UpdateEventPayloadeventEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateFullfillmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateFullfillmentPayload'] = ResolversParentTypes['UpdateFullfillmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullfillment?: Resolver<Maybe<ResolversTypes['Fullfillment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  fullfillmentEdge?: Resolver<Maybe<ResolversTypes['FullfillmentsEdge']>, ParentType, ContextType, RequireFields<UpdateFullfillmentPayloadfullfillmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateGiftCertificatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateGiftCertificatePayload'] = ResolversParentTypes['UpdateGiftCertificatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  giftCertificate?: Resolver<Maybe<ResolversTypes['GiftCertificate']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  giftCertificateEdge?: Resolver<Maybe<ResolversTypes['GiftCertificatesEdge']>, ParentType, ContextType, RequireFields<UpdateGiftCertificatePayloadgiftCertificateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateGlossaryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateGlossaryPayload'] = ResolversParentTypes['UpdateGlossaryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  glossary?: Resolver<Maybe<ResolversTypes['Glossary']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  glossaryEdge?: Resolver<Maybe<ResolversTypes['GlossariesEdge']>, ParentType, ContextType, RequireFields<UpdateGlossaryPayloadglossaryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateImportmPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateImportmPayload'] = ResolversParentTypes['UpdateImportmPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  importm?: Resolver<Maybe<ResolversTypes['Importm']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  importmEdge?: Resolver<Maybe<ResolversTypes['ImportmsEdge']>, ParentType, ContextType, RequireFields<UpdateImportmPayloadimportmEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateIntegrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateIntegrationPayload'] = ResolversParentTypes['UpdateIntegrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  integration?: Resolver<Maybe<ResolversTypes['Integration']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  integrationEdge?: Resolver<Maybe<ResolversTypes['IntegrationsEdge']>, ParentType, ContextType, RequireFields<UpdateIntegrationPayloadintegrationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateInternalizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateInternalizationPayload'] = ResolversParentTypes['UpdateInternalizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  internalization?: Resolver<Maybe<ResolversTypes['Internalization']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  internalizationEdge?: Resolver<Maybe<ResolversTypes['InternalizationsEdge']>, ParentType, ContextType, RequireFields<UpdateInternalizationPayloadinternalizationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateInvitationPayload'] = ResolversParentTypes['UpdateInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['Invitation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  invitationEdge?: Resolver<Maybe<ResolversTypes['InvitationsEdge']>, ParentType, ContextType, RequireFields<UpdateInvitationPayloadinvitationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateInvoicePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateInvoicePayload'] = ResolversParentTypes['UpdateInvoicePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  invoiceEdge?: Resolver<Maybe<ResolversTypes['InvoicesEdge']>, ParentType, ContextType, RequireFields<UpdateInvoicePayloadinvoiceEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateLeadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateLeadPayload'] = ResolversParentTypes['UpdateLeadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lead?: Resolver<Maybe<ResolversTypes['Lead']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  leadEdge?: Resolver<Maybe<ResolversTypes['LeadsEdge']>, ParentType, ContextType, RequireFields<UpdateLeadPayloadleadEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateManufacturerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateManufacturerPayload'] = ResolversParentTypes['UpdateManufacturerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturer?: Resolver<Maybe<ResolversTypes['Manufacturer']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  manufacturerEdge?: Resolver<Maybe<ResolversTypes['ManufacturersEdge']>, ParentType, ContextType, RequireFields<UpdateManufacturerPayloadmanufacturerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateMediamanagerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateMediamanagerPayload'] = ResolversParentTypes['UpdateMediamanagerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['Mediamanager']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  mediamanagerEdge?: Resolver<Maybe<ResolversTypes['MediamanagersEdge']>, ParentType, ContextType, RequireFields<UpdateMediamanagerPayloadmediamanagerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateMeetingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateMeetingPayload'] = ResolversParentTypes['UpdateMeetingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  meeting?: Resolver<Maybe<ResolversTypes['Meeting']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  meetingEdge?: Resolver<Maybe<ResolversTypes['MeetingsEdge']>, ParentType, ContextType, RequireFields<UpdateMeetingPayloadmeetingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateMessagePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateMessagePayload'] = ResolversParentTypes['UpdateMessagePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  messageEdge?: Resolver<Maybe<ResolversTypes['MessagesEdge']>, ParentType, ContextType, RequireFields<UpdateMessagePayloadmessageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateNewsletterPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateNewsletterPayload'] = ResolversParentTypes['UpdateNewsletterPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  newsletter?: Resolver<Maybe<ResolversTypes['Newsletter']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  newsletterEdge?: Resolver<Maybe<ResolversTypes['NewslettersEdge']>, ParentType, ContextType, RequireFields<UpdateNewsletterPayloadnewsletterEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateOotoPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateOotoPayload'] = ResolversParentTypes['UpdateOotoPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ooto?: Resolver<Maybe<ResolversTypes['Ooto']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ootoEdge?: Resolver<Maybe<ResolversTypes['OotosEdge']>, ParentType, ContextType, RequireFields<UpdateOotoPayloadootoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateOpportunityPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateOpportunityPayload'] = ResolversParentTypes['UpdateOpportunityPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  opportunity?: Resolver<Maybe<ResolversTypes['Opportunity']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  opportunityEdge?: Resolver<Maybe<ResolversTypes['OpportunitiesEdge']>, ParentType, ContextType, RequireFields<UpdateOpportunityPayloadopportunityEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateOrderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateOrderPayload'] = ResolversParentTypes['UpdateOrderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  orderEdge?: Resolver<Maybe<ResolversTypes['OrdersEdge']>, ParentType, ContextType, RequireFields<UpdateOrderPayloadorderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePagePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePagePayload'] = ResolversParentTypes['UpdatePagePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pageEdge?: Resolver<Maybe<ResolversTypes['PagesEdge']>, ParentType, ContextType, RequireFields<UpdatePagePayloadpageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePartnerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePartnerPayload'] = ResolversParentTypes['UpdatePartnerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  partner?: Resolver<Maybe<ResolversTypes['Partner']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  partnerEdge?: Resolver<Maybe<ResolversTypes['PartnersEdge']>, ParentType, ContextType, RequireFields<UpdatePartnerPayloadpartnerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePaymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePaymentPayload'] = ResolversParentTypes['UpdatePaymentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  paymentEdge?: Resolver<Maybe<ResolversTypes['PaymentsEdge']>, ParentType, ContextType, RequireFields<UpdatePaymentPayloadpaymentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePermissionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePermissionPayload'] = ResolversParentTypes['UpdatePermissionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['Permission']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionEdge?: Resolver<Maybe<ResolversTypes['PermissionsEdge']>, ParentType, ContextType, RequireFields<UpdatePermissionPayloadpermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePluginPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePluginPayload'] = ResolversParentTypes['UpdatePluginPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  plugin?: Resolver<Maybe<ResolversTypes['Plugin']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pluginEdge?: Resolver<Maybe<ResolversTypes['PluginsEdge']>, ParentType, ContextType, RequireFields<UpdatePluginPayloadpluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdatePollPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdatePollPayload'] = ResolversParentTypes['UpdatePollPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['Poll']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pollEdge?: Resolver<Maybe<ResolversTypes['PollsEdge']>, ParentType, ContextType, RequireFields<UpdatePollPayloadpollEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProductTypePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProductTypePayload'] = ResolversParentTypes['UpdateProductTypePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  productTypeEdge?: Resolver<Maybe<ResolversTypes['ProductTypesEdge']>, ParentType, ContextType, RequireFields<UpdateProductTypePayloadproductTypeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProductPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProductPayload'] = ResolversParentTypes['UpdateProductPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  productEdge?: Resolver<Maybe<ResolversTypes['ProductsEdge']>, ParentType, ContextType, RequireFields<UpdateProductPayloadproductEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProjectPayload'] = ResolversParentTypes['UpdateProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  projectEdge?: Resolver<Maybe<ResolversTypes['ProjectsEdge']>, ParentType, ContextType, RequireFields<UpdateProjectPayloadprojectEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateProviderPayload'] = ResolversParentTypes['UpdateProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['Provider']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  providerEdge?: Resolver<Maybe<ResolversTypes['ProvidersEdge']>, ParentType, ContextType, RequireFields<UpdateProviderPayloadproviderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateQuotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateQuotePayload'] = ResolversParentTypes['UpdateQuotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  quoteEdge?: Resolver<Maybe<ResolversTypes['QuotesEdge']>, ParentType, ContextType, RequireFields<UpdateQuotePayloadquoteEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateRatingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateRatingPayload'] = ResolversParentTypes['UpdateRatingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rating?: Resolver<Maybe<ResolversTypes['Rating']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ratingEdge?: Resolver<Maybe<ResolversTypes['RatingsEdge']>, ParentType, ContextType, RequireFields<UpdateRatingPayloadratingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateReportPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateReportPayload'] = ResolversParentTypes['UpdateReportPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  report?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reportEdge?: Resolver<Maybe<ResolversTypes['ReportsEdge']>, ParentType, ContextType, RequireFields<UpdateReportPayloadreportEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateReturnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateReturnPayload'] = ResolversParentTypes['UpdateReturnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  return?: Resolver<Maybe<ResolversTypes['Return']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  returnEdge?: Resolver<Maybe<ResolversTypes['ReturnsEdge']>, ParentType, ContextType, RequireFields<UpdateReturnPayloadreturnEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateReviewPayload'] = ResolversParentTypes['UpdateReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewPayloadreviewEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateRewardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateRewardPayload'] = ResolversParentTypes['UpdateRewardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reward?: Resolver<Maybe<ResolversTypes['Reward']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  rewardEdge?: Resolver<Maybe<ResolversTypes['RewardsEdge']>, ParentType, ContextType, RequireFields<UpdateRewardPayloadrewardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateRolePayload'] = ResolversParentTypes['UpdateRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleEdge?: Resolver<Maybe<ResolversTypes['RolesEdge']>, ParentType, ContextType, RequireFields<UpdateRolePayloadroleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateSchedulerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateSchedulerPayload'] = ResolversParentTypes['UpdateSchedulerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scheduler?: Resolver<Maybe<ResolversTypes['Scheduler']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  schedulerEdge?: Resolver<Maybe<ResolversTypes['SchedulersEdge']>, ParentType, ContextType, RequireFields<UpdateSchedulerPayloadschedulerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateSegmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateSegmentPayload'] = ResolversParentTypes['UpdateSegmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  segment?: Resolver<Maybe<ResolversTypes['Segment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  segmentEdge?: Resolver<Maybe<ResolversTypes['SegmentsEdge']>, ParentType, ContextType, RequireFields<UpdateSegmentPayloadsegmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateSettingPayload'] = ResolversParentTypes['UpdateSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  setting?: Resolver<Maybe<ResolversTypes['Setting']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  settingEdge?: Resolver<Maybe<ResolversTypes['SettingsEdge']>, ParentType, ContextType, RequireFields<UpdateSettingPayloadsettingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateShipmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateShipmentPayload'] = ResolversParentTypes['UpdateShipmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shipment?: Resolver<Maybe<ResolversTypes['Shipment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  shipmentEdge?: Resolver<Maybe<ResolversTypes['ShipmentsEdge']>, ParentType, ContextType, RequireFields<UpdateShipmentPayloadshipmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateSpecialDiscountPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateSpecialDiscountPayload'] = ResolversParentTypes['UpdateSpecialDiscountPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  specialDiscount?: Resolver<Maybe<ResolversTypes['SpecialDiscount']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  specialDiscountEdge?: Resolver<Maybe<ResolversTypes['SpecialDiscountsEdge']>, ParentType, ContextType, RequireFields<UpdateSpecialDiscountPayloadspecialDiscountEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateStatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateStatePayload'] = ResolversParentTypes['UpdateStatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stateEdge?: Resolver<Maybe<ResolversTypes['StatesEdge']>, ParentType, ContextType, RequireFields<UpdateStatePayloadstateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateStatisticPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateStatisticPayload'] = ResolversParentTypes['UpdateStatisticPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  statistic?: Resolver<Maybe<ResolversTypes['Statistic']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  statisticEdge?: Resolver<Maybe<ResolversTypes['StatisticsEdge']>, ParentType, ContextType, RequireFields<UpdateStatisticPayloadstatisticEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateStockPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateStockPayload'] = ResolversParentTypes['UpdateStockPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stock?: Resolver<Maybe<ResolversTypes['Stock']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stockEdge?: Resolver<Maybe<ResolversTypes['StocksEdge']>, ParentType, ContextType, RequireFields<UpdateStockPayloadstockEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateSurveyPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateSurveyPayload'] = ResolversParentTypes['UpdateSurveyPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  survey?: Resolver<Maybe<ResolversTypes['Survey']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  surveyEdge?: Resolver<Maybe<ResolversTypes['SurveysEdge']>, ParentType, ContextType, RequireFields<UpdateSurveyPayloadsurveyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTagPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTagPayload'] = ResolversParentTypes['UpdateTagPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  tagEdge?: Resolver<Maybe<ResolversTypes['TagsEdge']>, ParentType, ContextType, RequireFields<UpdateTagPayloadtagEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTargetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTargetPayload'] = ResolversParentTypes['UpdateTargetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['Target']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  targetEdge?: Resolver<Maybe<ResolversTypes['TargetsEdge']>, ParentType, ContextType, RequireFields<UpdateTargetPayloadtargetEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTaxCategoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTaxCategoryPayload'] = ResolversParentTypes['UpdateTaxCategoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxCategoryEdge?: Resolver<Maybe<ResolversTypes['TaxCategoriesEdge']>, ParentType, ContextType, RequireFields<UpdateTaxCategoryPayloadtaxCategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTaxRatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTaxRatePayload'] = ResolversParentTypes['UpdateTaxRatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxRateEdge?: Resolver<Maybe<ResolversTypes['TaxRatesEdge']>, ParentType, ContextType, RequireFields<UpdateTaxRatePayloadtaxRateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTaxRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTaxRulePayload'] = ResolversParentTypes['UpdateTaxRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxRule?: Resolver<Maybe<ResolversTypes['TaxRule']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxRuleEdge?: Resolver<Maybe<ResolversTypes['TaxRulesEdge']>, ParentType, ContextType, RequireFields<UpdateTaxRulePayloadtaxRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTemplatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTemplatePayload'] = ResolversParentTypes['UpdateTemplatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<UpdateTemplatePayloadtemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateThemePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateThemePayload'] = ResolversParentTypes['UpdateThemePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  theme?: Resolver<Maybe<ResolversTypes['Theme']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  themeEdge?: Resolver<Maybe<ResolversTypes['ThemesEdge']>, ParentType, ContextType, RequireFields<UpdateThemePayloadthemeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTicketingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTicketingPayload'] = ResolversParentTypes['UpdateTicketingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ticketing?: Resolver<Maybe<ResolversTypes['Ticketing']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ticketingEdge?: Resolver<Maybe<ResolversTypes['TicketingsEdge']>, ParentType, ContextType, RequireFields<UpdateTicketingPayloadticketingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTrainingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTrainingPayload'] = ResolversParentTypes['UpdateTrainingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  training?: Resolver<Maybe<ResolversTypes['Training']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  trainingEdge?: Resolver<Maybe<ResolversTypes['TrainingsEdge']>, ParentType, ContextType, RequireFields<UpdateTrainingPayloadtrainingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateTransactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateTransactionPayload'] = ResolversParentTypes['UpdateTransactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  transactionEdge?: Resolver<Maybe<ResolversTypes['TransactionsEdge']>, ParentType, ContextType, RequireFields<UpdateTransactionPayloadtransactionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateUploadFilePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateUploadFilePayload'] = ResolversParentTypes['UpdateUploadFilePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uploadFile?: Resolver<Maybe<ResolversTypes['UploadFile']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  uploadFileEdge?: Resolver<Maybe<ResolversTypes['UploadFilesEdge']>, ParentType, ContextType, RequireFields<UpdateUploadFilePayloaduploadFileEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateUserPayload'] = ResolversParentTypes['UpdateUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<UpdateUserPayloaduserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateVendorPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateVendorPayload'] = ResolversParentTypes['UpdateVendorPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vendor?: Resolver<Maybe<ResolversTypes['Vendor']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  vendorEdge?: Resolver<Maybe<ResolversTypes['VendorsEdge']>, ParentType, ContextType, RequireFields<UpdateVendorPayloadvendorEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateVisitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateVisitPayload'] = ResolversParentTypes['UpdateVisitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visit?: Resolver<Maybe<ResolversTypes['Visit']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  visitEdge?: Resolver<Maybe<ResolversTypes['VisitsEdge']>, ParentType, ContextType, RequireFields<UpdateVisitPayloadvisitEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateWarehousePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateWarehousePayload'] = ResolversParentTypes['UpdateWarehousePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  warehouseEdge?: Resolver<Maybe<ResolversTypes['WarehousesEdge']>, ParentType, ContextType, RequireFields<UpdateWarehousePayloadwarehouseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateWebhookPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateWebhookPayload'] = ResolversParentTypes['UpdateWebhookPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  webhook?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webhookEdge?: Resolver<Maybe<ResolversTypes['WebhooksEdge']>, ParentType, ContextType, RequireFields<UpdateWebhookPayloadwebhookEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateWebsitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateWebsitePayload'] = ResolversParentTypes['UpdateWebsitePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['Website']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  websiteEdge?: Resolver<Maybe<ResolversTypes['WebsitesEdge']>, ParentType, ContextType, RequireFields<UpdateWebsitePayloadwebsiteEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateWishlistPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateWishlistPayload'] = ResolversParentTypes['UpdateWishlistPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  wishlist?: Resolver<Maybe<ResolversTypes['Wishlist']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  wishlistEdge?: Resolver<Maybe<ResolversTypes['WishlistsEdge']>, ParentType, ContextType, RequireFields<UpdateWishlistPayloadwishlistEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateWorkspacePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateWorkspacePayload'] = ResolversParentTypes['UpdateWorkspacePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspace?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  workspaceEdge?: Resolver<Maybe<ResolversTypes['WorkspacesEdge']>, ParentType, ContextType, RequireFields<UpdateWorkspacePayloadworkspaceEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UpdateZonePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UpdateZonePayload'] = ResolversParentTypes['UpdateZonePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  zone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  zoneEdge?: Resolver<Maybe<ResolversTypes['ZonesEdge']>, ParentType, ContextType, RequireFields<UpdateZonePayloadzoneEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteAccountPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteAccountPayload'] = ResolversParentTypes['DeleteAccountPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  account?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  deletedAccountId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  accountEdge?: Resolver<Maybe<ResolversTypes['AccountsEdge']>, ParentType, ContextType, RequireFields<DeleteAccountPayloadaccountEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteAgreementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteAgreementPayload'] = ResolversParentTypes['DeleteAgreementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  agreement?: Resolver<Maybe<ResolversTypes['Agreement']>, ParentType, ContextType>;
  deletedAgreementId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  agreementEdge?: Resolver<Maybe<ResolversTypes['AgreementsEdge']>, ParentType, ContextType, RequireFields<DeleteAgreementPayloadagreementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteAnalyticPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteAnalyticPayload'] = ResolversParentTypes['DeleteAnalyticPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  analytic?: Resolver<Maybe<ResolversTypes['Analytic']>, ParentType, ContextType>;
  deletedAnalyticId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  analyticEdge?: Resolver<Maybe<ResolversTypes['AnalyticsEdge']>, ParentType, ContextType, RequireFields<DeleteAnalyticPayloadanalyticEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteApitokenPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteApitokenPayload'] = ResolversParentTypes['DeleteApitokenPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  apitoken?: Resolver<Maybe<ResolversTypes['Apitoken']>, ParentType, ContextType>;
  deletedApitokenId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  apitokenEdge?: Resolver<Maybe<ResolversTypes['ApitokensEdge']>, ParentType, ContextType, RequireFields<DeleteApitokenPayloadapitokenEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteArticlePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteArticlePayload'] = ResolversParentTypes['DeleteArticlePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  article?: Resolver<Maybe<ResolversTypes['Article']>, ParentType, ContextType>;
  deletedArticleId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  articleEdge?: Resolver<Maybe<ResolversTypes['ArticlesEdge']>, ParentType, ContextType, RequireFields<DeleteArticlePayloadarticleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteAttributePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteAttributePayload'] = ResolversParentTypes['DeleteAttributePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  deletedAttributeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  attributeEdge?: Resolver<Maybe<ResolversTypes['AttributesEdge']>, ParentType, ContextType, RequireFields<DeleteAttributePayloadattributeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteBrandPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteBrandPayload'] = ResolversParentTypes['DeleteBrandPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  brand?: Resolver<Maybe<ResolversTypes['Brand']>, ParentType, ContextType>;
  deletedBrandId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  brandEdge?: Resolver<Maybe<ResolversTypes['BrandsEdge']>, ParentType, ContextType, RequireFields<DeleteBrandPayloadbrandEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCartPriceRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCartPriceRulePayload'] = ResolversParentTypes['DeleteCartPriceRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cartPriceRule?: Resolver<Maybe<ResolversTypes['CartPriceRule']>, ParentType, ContextType>;
  deletedCartPriceRuleId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  cartPriceRuleEdge?: Resolver<Maybe<ResolversTypes['CartPriceRulesEdge']>, ParentType, ContextType, RequireFields<DeleteCartPriceRulePayloadcartPriceRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCasePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCasePayload'] = ResolversParentTypes['DeleteCasePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  case?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType>;
  deletedCaseId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  caseEdge?: Resolver<Maybe<ResolversTypes['CasesEdge']>, ParentType, ContextType, RequireFields<DeleteCasePayloadcaseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCatalogPriceRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCatalogPriceRulePayload'] = ResolversParentTypes['DeleteCatalogPriceRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  catalogPriceRule?: Resolver<Maybe<ResolversTypes['CatalogPriceRule']>, ParentType, ContextType>;
  deletedCatalogPriceRuleId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  catalogPriceRuleEdge?: Resolver<Maybe<ResolversTypes['CatalogPriceRulesEdge']>, ParentType, ContextType, RequireFields<DeleteCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCategoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCategoryPayload'] = ResolversParentTypes['DeleteCategoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  deletedCategoryId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  categoryEdge?: Resolver<Maybe<ResolversTypes['CategoriesEdge']>, ParentType, ContextType, RequireFields<DeleteCategoryPayloadcategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteChannelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteChannelPayload'] = ResolversParentTypes['DeleteChannelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  deletedChannelId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  channelEdge?: Resolver<Maybe<ResolversTypes['ChannelsEdge']>, ParentType, ContextType, RequireFields<DeleteChannelPayloadchannelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteChecklistPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteChecklistPayload'] = ResolversParentTypes['DeleteChecklistPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  checklist?: Resolver<Maybe<ResolversTypes['Checklist']>, ParentType, ContextType>;
  deletedChecklistId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  checklistEdge?: Resolver<Maybe<ResolversTypes['ChecklistsEdge']>, ParentType, ContextType, RequireFields<DeleteChecklistPayloadchecklistEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCityPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCityPayload'] = ResolversParentTypes['DeleteCityPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType>;
  deletedCityId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  cityEdge?: Resolver<Maybe<ResolversTypes['CitiesEdge']>, ParentType, ContextType, RequireFields<DeleteCityPayloadcityEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCollectionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCollectionPayload'] = ResolversParentTypes['DeleteCollectionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  deletedCollectionId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  collectionEdge?: Resolver<Maybe<ResolversTypes['CollectionsEdge']>, ParentType, ContextType, RequireFields<DeleteCollectionPayloadcollectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCommentPayload'] = ResolversParentTypes['DeleteCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Comment']>, ParentType, ContextType>;
  deletedCommentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['CommentsEdge']>, ParentType, ContextType, RequireFields<DeleteCommentPayloadcommentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteContentTypePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteContentTypePayload'] = ResolversParentTypes['DeleteContentTypePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<Maybe<ResolversTypes['ContentType']>, ParentType, ContextType>;
  deletedContentTypeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  contentTypeEdge?: Resolver<Maybe<ResolversTypes['ContentTypesEdge']>, ParentType, ContextType, RequireFields<DeleteContentTypePayloadcontentTypeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteContractPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteContractPayload'] = ResolversParentTypes['DeleteContractPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contract?: Resolver<Maybe<ResolversTypes['Contract']>, ParentType, ContextType>;
  deletedContractId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  contractEdge?: Resolver<Maybe<ResolversTypes['ContractsEdge']>, ParentType, ContextType, RequireFields<DeleteContractPayloadcontractEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCountryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCountryPayload'] = ResolversParentTypes['DeleteCountryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  deletedCountryId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  countryEdge?: Resolver<Maybe<ResolversTypes['CountriesEdge']>, ParentType, ContextType, RequireFields<DeleteCountryPayloadcountryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCouponPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCouponPayload'] = ResolversParentTypes['DeleteCouponPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coupon?: Resolver<Maybe<ResolversTypes['Coupon']>, ParentType, ContextType>;
  deletedCouponId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  couponEdge?: Resolver<Maybe<ResolversTypes['CouponsEdge']>, ParentType, ContextType, RequireFields<DeleteCouponPayloadcouponEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCreditMemoPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCreditMemoPayload'] = ResolversParentTypes['DeleteCreditMemoPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  creditMemo?: Resolver<Maybe<ResolversTypes['CreditMemo']>, ParentType, ContextType>;
  deletedCreditMemoId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  creditMemoEdge?: Resolver<Maybe<ResolversTypes['CreditMemosEdge']>, ParentType, ContextType, RequireFields<DeleteCreditMemoPayloadcreditMemoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCurrencyPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCurrencyPayload'] = ResolversParentTypes['DeleteCurrencyPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  deletedCurrencyId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencyEdge?: Resolver<Maybe<ResolversTypes['CurrenciesEdge']>, ParentType, ContextType, RequireFields<DeleteCurrencyPayloadcurrencyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCurrencyRatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCurrencyRatePayload'] = ResolversParentTypes['DeleteCurrencyRatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currencyRate?: Resolver<Maybe<ResolversTypes['CurrencyRate']>, ParentType, ContextType>;
  deletedCurrencyRateId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencyRateEdge?: Resolver<Maybe<ResolversTypes['CurrencyRatesEdge']>, ParentType, ContextType, RequireFields<DeleteCurrencyRatePayloadcurrencyRateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCurrencySymbolPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCurrencySymbolPayload'] = ResolversParentTypes['DeleteCurrencySymbolPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currencySymbol?: Resolver<Maybe<ResolversTypes['CurrencySymbol']>, ParentType, ContextType>;
  deletedCurrencySymbolId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  currencySymbolEdge?: Resolver<Maybe<ResolversTypes['CurrencySymbolsEdge']>, ParentType, ContextType, RequireFields<DeleteCurrencySymbolPayloadcurrencySymbolEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCustomerGroupPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCustomerGroupPayload'] = ResolversParentTypes['DeleteCustomerGroupPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  deletedCustomerGroupId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customerGroupEdge?: Resolver<Maybe<ResolversTypes['CustomerGroupsEdge']>, ParentType, ContextType, RequireFields<DeleteCustomerGroupPayloadcustomerGroupEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCustomerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCustomerPayload'] = ResolversParentTypes['DeleteCustomerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  deletedCustomerId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customerEdge?: Resolver<Maybe<ResolversTypes['CustomersEdge']>, ParentType, ContextType, RequireFields<DeleteCustomerPayloadcustomerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteCustomizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteCustomizationPayload'] = ResolversParentTypes['DeleteCustomizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customization?: Resolver<Maybe<ResolversTypes['Customization']>, ParentType, ContextType>;
  deletedCustomizationId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  customizationEdge?: Resolver<Maybe<ResolversTypes['CustomizationsEdge']>, ParentType, ContextType, RequireFields<DeleteCustomizationPayloadcustomizationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteDashboardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteDashboardPayload'] = ResolversParentTypes['DeleteDashboardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dashboard?: Resolver<Maybe<ResolversTypes['Dashboard']>, ParentType, ContextType>;
  deletedDashboardId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  dashboardEdge?: Resolver<Maybe<ResolversTypes['DashboardsEdge']>, ParentType, ContextType, RequireFields<DeleteDashboardPayloaddashboardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteDeepdivePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteDeepdivePayload'] = ResolversParentTypes['DeleteDeepdivePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deepdive?: Resolver<Maybe<ResolversTypes['Deepdive']>, ParentType, ContextType>;
  deletedDeepdiveId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  deepdiveEdge?: Resolver<Maybe<ResolversTypes['DeepdivesEdge']>, ParentType, ContextType, RequireFields<DeleteDeepdivePayloaddeepdiveEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteDigiboardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteDigiboardPayload'] = ResolversParentTypes['DeleteDigiboardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  digiboard?: Resolver<Maybe<ResolversTypes['Digiboard']>, ParentType, ContextType>;
  deletedDigiboardId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  digiboardEdge?: Resolver<Maybe<ResolversTypes['DigiboardsEdge']>, ParentType, ContextType, RequireFields<DeleteDigiboardPayloaddigiboardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteEmailPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteEmailPayload'] = ResolversParentTypes['DeleteEmailPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['Email']>, ParentType, ContextType>;
  deletedEmailId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  emailEdge?: Resolver<Maybe<ResolversTypes['EmailsEdge']>, ParentType, ContextType, RequireFields<DeleteEmailPayloademailEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteEndofshiftPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteEndofshiftPayload'] = ResolversParentTypes['DeleteEndofshiftPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endofshift?: Resolver<Maybe<ResolversTypes['Endofshift']>, ParentType, ContextType>;
  deletedEndofshiftId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  endofshiftEdge?: Resolver<Maybe<ResolversTypes['EndofshiftsEdge']>, ParentType, ContextType, RequireFields<DeleteEndofshiftPayloadendofshiftEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteEventPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteEventPayload'] = ResolversParentTypes['DeleteEventPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  event?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType>;
  deletedEventId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  eventEdge?: Resolver<Maybe<ResolversTypes['EventsEdge']>, ParentType, ContextType, RequireFields<DeleteEventPayloadeventEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteFullfillmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteFullfillmentPayload'] = ResolversParentTypes['DeleteFullfillmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullfillment?: Resolver<Maybe<ResolversTypes['Fullfillment']>, ParentType, ContextType>;
  deletedFullfillmentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  fullfillmentEdge?: Resolver<Maybe<ResolversTypes['FullfillmentsEdge']>, ParentType, ContextType, RequireFields<DeleteFullfillmentPayloadfullfillmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteGiftCertificatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteGiftCertificatePayload'] = ResolversParentTypes['DeleteGiftCertificatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  giftCertificate?: Resolver<Maybe<ResolversTypes['GiftCertificate']>, ParentType, ContextType>;
  deletedGiftCertificateId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  giftCertificateEdge?: Resolver<Maybe<ResolversTypes['GiftCertificatesEdge']>, ParentType, ContextType, RequireFields<DeleteGiftCertificatePayloadgiftCertificateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteGlossaryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteGlossaryPayload'] = ResolversParentTypes['DeleteGlossaryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  glossary?: Resolver<Maybe<ResolversTypes['Glossary']>, ParentType, ContextType>;
  deletedGlossaryId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  glossaryEdge?: Resolver<Maybe<ResolversTypes['GlossariesEdge']>, ParentType, ContextType, RequireFields<DeleteGlossaryPayloadglossaryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteImportmPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteImportmPayload'] = ResolversParentTypes['DeleteImportmPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  importm?: Resolver<Maybe<ResolversTypes['Importm']>, ParentType, ContextType>;
  deletedImportmId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  importmEdge?: Resolver<Maybe<ResolversTypes['ImportmsEdge']>, ParentType, ContextType, RequireFields<DeleteImportmPayloadimportmEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteIntegrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteIntegrationPayload'] = ResolversParentTypes['DeleteIntegrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  integration?: Resolver<Maybe<ResolversTypes['Integration']>, ParentType, ContextType>;
  deletedIntegrationId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  integrationEdge?: Resolver<Maybe<ResolversTypes['IntegrationsEdge']>, ParentType, ContextType, RequireFields<DeleteIntegrationPayloadintegrationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteInternalizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteInternalizationPayload'] = ResolversParentTypes['DeleteInternalizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  internalization?: Resolver<Maybe<ResolversTypes['Internalization']>, ParentType, ContextType>;
  deletedInternalizationId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  internalizationEdge?: Resolver<Maybe<ResolversTypes['InternalizationsEdge']>, ParentType, ContextType, RequireFields<DeleteInternalizationPayloadinternalizationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteInvitationPayload'] = ResolversParentTypes['DeleteInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['Invitation']>, ParentType, ContextType>;
  deletedInvitationId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  invitationEdge?: Resolver<Maybe<ResolversTypes['InvitationsEdge']>, ParentType, ContextType, RequireFields<DeleteInvitationPayloadinvitationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteInvoicePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteInvoicePayload'] = ResolversParentTypes['DeleteInvoicePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  deletedInvoiceId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  invoiceEdge?: Resolver<Maybe<ResolversTypes['InvoicesEdge']>, ParentType, ContextType, RequireFields<DeleteInvoicePayloadinvoiceEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteLeadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteLeadPayload'] = ResolversParentTypes['DeleteLeadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lead?: Resolver<Maybe<ResolversTypes['Lead']>, ParentType, ContextType>;
  deletedLeadId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  leadEdge?: Resolver<Maybe<ResolversTypes['LeadsEdge']>, ParentType, ContextType, RequireFields<DeleteLeadPayloadleadEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteManufacturerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteManufacturerPayload'] = ResolversParentTypes['DeleteManufacturerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturer?: Resolver<Maybe<ResolversTypes['Manufacturer']>, ParentType, ContextType>;
  deletedManufacturerId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  manufacturerEdge?: Resolver<Maybe<ResolversTypes['ManufacturersEdge']>, ParentType, ContextType, RequireFields<DeleteManufacturerPayloadmanufacturerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteMediamanagerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteMediamanagerPayload'] = ResolversParentTypes['DeleteMediamanagerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediamanager?: Resolver<Maybe<ResolversTypes['Mediamanager']>, ParentType, ContextType>;
  deletedMediamanagerId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  mediamanagerEdge?: Resolver<Maybe<ResolversTypes['MediamanagersEdge']>, ParentType, ContextType, RequireFields<DeleteMediamanagerPayloadmediamanagerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteMeetingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteMeetingPayload'] = ResolversParentTypes['DeleteMeetingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  meeting?: Resolver<Maybe<ResolversTypes['Meeting']>, ParentType, ContextType>;
  deletedMeetingId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  meetingEdge?: Resolver<Maybe<ResolversTypes['MeetingsEdge']>, ParentType, ContextType, RequireFields<DeleteMeetingPayloadmeetingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteMessagePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteMessagePayload'] = ResolversParentTypes['DeleteMessagePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType>;
  deletedMessageId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  messageEdge?: Resolver<Maybe<ResolversTypes['MessagesEdge']>, ParentType, ContextType, RequireFields<DeleteMessagePayloadmessageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteNewsletterPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteNewsletterPayload'] = ResolversParentTypes['DeleteNewsletterPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  newsletter?: Resolver<Maybe<ResolversTypes['Newsletter']>, ParentType, ContextType>;
  deletedNewsletterId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  newsletterEdge?: Resolver<Maybe<ResolversTypes['NewslettersEdge']>, ParentType, ContextType, RequireFields<DeleteNewsletterPayloadnewsletterEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteOotoPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteOotoPayload'] = ResolversParentTypes['DeleteOotoPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ooto?: Resolver<Maybe<ResolversTypes['Ooto']>, ParentType, ContextType>;
  deletedOotoId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ootoEdge?: Resolver<Maybe<ResolversTypes['OotosEdge']>, ParentType, ContextType, RequireFields<DeleteOotoPayloadootoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteOpportunityPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteOpportunityPayload'] = ResolversParentTypes['DeleteOpportunityPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  opportunity?: Resolver<Maybe<ResolversTypes['Opportunity']>, ParentType, ContextType>;
  deletedOpportunityId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  opportunityEdge?: Resolver<Maybe<ResolversTypes['OpportunitiesEdge']>, ParentType, ContextType, RequireFields<DeleteOpportunityPayloadopportunityEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteOrderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteOrderPayload'] = ResolversParentTypes['DeleteOrderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  deletedOrderId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  orderEdge?: Resolver<Maybe<ResolversTypes['OrdersEdge']>, ParentType, ContextType, RequireFields<DeleteOrderPayloadorderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePagePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePagePayload'] = ResolversParentTypes['DeletePagePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  deletedPageId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pageEdge?: Resolver<Maybe<ResolversTypes['PagesEdge']>, ParentType, ContextType, RequireFields<DeletePagePayloadpageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePartnerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePartnerPayload'] = ResolversParentTypes['DeletePartnerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  partner?: Resolver<Maybe<ResolversTypes['Partner']>, ParentType, ContextType>;
  deletedPartnerId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  partnerEdge?: Resolver<Maybe<ResolversTypes['PartnersEdge']>, ParentType, ContextType, RequireFields<DeletePartnerPayloadpartnerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePaymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePaymentPayload'] = ResolversParentTypes['DeletePaymentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType>;
  deletedPaymentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  paymentEdge?: Resolver<Maybe<ResolversTypes['PaymentsEdge']>, ParentType, ContextType, RequireFields<DeletePaymentPayloadpaymentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePermissionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePermissionPayload'] = ResolversParentTypes['DeletePermissionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['Permission']>, ParentType, ContextType>;
  deletedPermissionId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionEdge?: Resolver<Maybe<ResolversTypes['PermissionsEdge']>, ParentType, ContextType, RequireFields<DeletePermissionPayloadpermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePluginPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePluginPayload'] = ResolversParentTypes['DeletePluginPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  plugin?: Resolver<Maybe<ResolversTypes['Plugin']>, ParentType, ContextType>;
  deletedPluginId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pluginEdge?: Resolver<Maybe<ResolversTypes['PluginsEdge']>, ParentType, ContextType, RequireFields<DeletePluginPayloadpluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeletePollPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeletePollPayload'] = ResolversParentTypes['DeletePollPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['Poll']>, ParentType, ContextType>;
  deletedPollId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  pollEdge?: Resolver<Maybe<ResolversTypes['PollsEdge']>, ParentType, ContextType, RequireFields<DeletePollPayloadpollEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProductTypePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProductTypePayload'] = ResolversParentTypes['DeleteProductTypePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  deletedProductTypeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  productTypeEdge?: Resolver<Maybe<ResolversTypes['ProductTypesEdge']>, ParentType, ContextType, RequireFields<DeleteProductTypePayloadproductTypeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProductPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProductPayload'] = ResolversParentTypes['DeleteProductPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  deletedProductId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  productEdge?: Resolver<Maybe<ResolversTypes['ProductsEdge']>, ParentType, ContextType, RequireFields<DeleteProductPayloadproductEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProjectPayload'] = ResolversParentTypes['DeleteProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Project']>, ParentType, ContextType>;
  deletedProjectId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  projectEdge?: Resolver<Maybe<ResolversTypes['ProjectsEdge']>, ParentType, ContextType, RequireFields<DeleteProjectPayloadprojectEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteProviderPayload'] = ResolversParentTypes['DeleteProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['Provider']>, ParentType, ContextType>;
  deletedProviderId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  providerEdge?: Resolver<Maybe<ResolversTypes['ProvidersEdge']>, ParentType, ContextType, RequireFields<DeleteProviderPayloadproviderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteQuotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteQuotePayload'] = ResolversParentTypes['DeleteQuotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType>;
  deletedQuoteId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  quoteEdge?: Resolver<Maybe<ResolversTypes['QuotesEdge']>, ParentType, ContextType, RequireFields<DeleteQuotePayloadquoteEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteRatingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteRatingPayload'] = ResolversParentTypes['DeleteRatingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rating?: Resolver<Maybe<ResolversTypes['Rating']>, ParentType, ContextType>;
  deletedRatingId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ratingEdge?: Resolver<Maybe<ResolversTypes['RatingsEdge']>, ParentType, ContextType, RequireFields<DeleteRatingPayloadratingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteReportPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteReportPayload'] = ResolversParentTypes['DeleteReportPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  report?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType>;
  deletedReportId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reportEdge?: Resolver<Maybe<ResolversTypes['ReportsEdge']>, ParentType, ContextType, RequireFields<DeleteReportPayloadreportEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteReturnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteReturnPayload'] = ResolversParentTypes['DeleteReturnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  return?: Resolver<Maybe<ResolversTypes['Return']>, ParentType, ContextType>;
  deletedReturnId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  returnEdge?: Resolver<Maybe<ResolversTypes['ReturnsEdge']>, ParentType, ContextType, RequireFields<DeleteReturnPayloadreturnEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteReviewPayload'] = ResolversParentTypes['DeleteReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  deletedReviewId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewPayloadreviewEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteRewardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteRewardPayload'] = ResolversParentTypes['DeleteRewardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reward?: Resolver<Maybe<ResolversTypes['Reward']>, ParentType, ContextType>;
  deletedRewardId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  rewardEdge?: Resolver<Maybe<ResolversTypes['RewardsEdge']>, ParentType, ContextType, RequireFields<DeleteRewardPayloadrewardEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteRolePayload'] = ResolversParentTypes['DeleteRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  deletedRoleId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleEdge?: Resolver<Maybe<ResolversTypes['RolesEdge']>, ParentType, ContextType, RequireFields<DeleteRolePayloadroleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteSchedulerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteSchedulerPayload'] = ResolversParentTypes['DeleteSchedulerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scheduler?: Resolver<Maybe<ResolversTypes['Scheduler']>, ParentType, ContextType>;
  deletedSchedulerId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  schedulerEdge?: Resolver<Maybe<ResolversTypes['SchedulersEdge']>, ParentType, ContextType, RequireFields<DeleteSchedulerPayloadschedulerEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteSegmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteSegmentPayload'] = ResolversParentTypes['DeleteSegmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  segment?: Resolver<Maybe<ResolversTypes['Segment']>, ParentType, ContextType>;
  deletedSegmentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  segmentEdge?: Resolver<Maybe<ResolversTypes['SegmentsEdge']>, ParentType, ContextType, RequireFields<DeleteSegmentPayloadsegmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteSettingPayload'] = ResolversParentTypes['DeleteSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  setting?: Resolver<Maybe<ResolversTypes['Setting']>, ParentType, ContextType>;
  deletedSettingId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  settingEdge?: Resolver<Maybe<ResolversTypes['SettingsEdge']>, ParentType, ContextType, RequireFields<DeleteSettingPayloadsettingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteShipmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteShipmentPayload'] = ResolversParentTypes['DeleteShipmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shipment?: Resolver<Maybe<ResolversTypes['Shipment']>, ParentType, ContextType>;
  deletedShipmentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  shipmentEdge?: Resolver<Maybe<ResolversTypes['ShipmentsEdge']>, ParentType, ContextType, RequireFields<DeleteShipmentPayloadshipmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteSpecialDiscountPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteSpecialDiscountPayload'] = ResolversParentTypes['DeleteSpecialDiscountPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  specialDiscount?: Resolver<Maybe<ResolversTypes['SpecialDiscount']>, ParentType, ContextType>;
  deletedSpecialDiscountId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  specialDiscountEdge?: Resolver<Maybe<ResolversTypes['SpecialDiscountsEdge']>, ParentType, ContextType, RequireFields<DeleteSpecialDiscountPayloadspecialDiscountEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteStatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteStatePayload'] = ResolversParentTypes['DeleteStatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  deletedStateId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stateEdge?: Resolver<Maybe<ResolversTypes['StatesEdge']>, ParentType, ContextType, RequireFields<DeleteStatePayloadstateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteStatisticPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteStatisticPayload'] = ResolversParentTypes['DeleteStatisticPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  statistic?: Resolver<Maybe<ResolversTypes['Statistic']>, ParentType, ContextType>;
  deletedStatisticId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  statisticEdge?: Resolver<Maybe<ResolversTypes['StatisticsEdge']>, ParentType, ContextType, RequireFields<DeleteStatisticPayloadstatisticEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteStockPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteStockPayload'] = ResolversParentTypes['DeleteStockPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stock?: Resolver<Maybe<ResolversTypes['Stock']>, ParentType, ContextType>;
  deletedStockId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stockEdge?: Resolver<Maybe<ResolversTypes['StocksEdge']>, ParentType, ContextType, RequireFields<DeleteStockPayloadstockEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteSurveyPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteSurveyPayload'] = ResolversParentTypes['DeleteSurveyPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  survey?: Resolver<Maybe<ResolversTypes['Survey']>, ParentType, ContextType>;
  deletedSurveyId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  surveyEdge?: Resolver<Maybe<ResolversTypes['SurveysEdge']>, ParentType, ContextType, RequireFields<DeleteSurveyPayloadsurveyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTagPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTagPayload'] = ResolversParentTypes['DeleteTagPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType>;
  deletedTagId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  tagEdge?: Resolver<Maybe<ResolversTypes['TagsEdge']>, ParentType, ContextType, RequireFields<DeleteTagPayloadtagEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTargetPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTargetPayload'] = ResolversParentTypes['DeleteTargetPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['Target']>, ParentType, ContextType>;
  deletedTargetId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  targetEdge?: Resolver<Maybe<ResolversTypes['TargetsEdge']>, ParentType, ContextType, RequireFields<DeleteTargetPayloadtargetEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTaxCategoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTaxCategoryPayload'] = ResolversParentTypes['DeleteTaxCategoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  deletedTaxCategoryId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxCategoryEdge?: Resolver<Maybe<ResolversTypes['TaxCategoriesEdge']>, ParentType, ContextType, RequireFields<DeleteTaxCategoryPayloadtaxCategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTaxRatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTaxRatePayload'] = ResolversParentTypes['DeleteTaxRatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  deletedTaxRateId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxRateEdge?: Resolver<Maybe<ResolversTypes['TaxRatesEdge']>, ParentType, ContextType, RequireFields<DeleteTaxRatePayloadtaxRateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTaxRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTaxRulePayload'] = ResolversParentTypes['DeleteTaxRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxRule?: Resolver<Maybe<ResolversTypes['TaxRule']>, ParentType, ContextType>;
  deletedTaxRuleId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  taxRuleEdge?: Resolver<Maybe<ResolversTypes['TaxRulesEdge']>, ParentType, ContextType, RequireFields<DeleteTaxRulePayloadtaxRuleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTemplatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTemplatePayload'] = ResolversParentTypes['DeleteTemplatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  deletedTemplateId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<DeleteTemplatePayloadtemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteThemePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteThemePayload'] = ResolversParentTypes['DeleteThemePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  theme?: Resolver<Maybe<ResolversTypes['Theme']>, ParentType, ContextType>;
  deletedThemeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  themeEdge?: Resolver<Maybe<ResolversTypes['ThemesEdge']>, ParentType, ContextType, RequireFields<DeleteThemePayloadthemeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTicketingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTicketingPayload'] = ResolversParentTypes['DeleteTicketingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ticketing?: Resolver<Maybe<ResolversTypes['Ticketing']>, ParentType, ContextType>;
  deletedTicketingId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  ticketingEdge?: Resolver<Maybe<ResolversTypes['TicketingsEdge']>, ParentType, ContextType, RequireFields<DeleteTicketingPayloadticketingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTrainingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTrainingPayload'] = ResolversParentTypes['DeleteTrainingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  training?: Resolver<Maybe<ResolversTypes['Training']>, ParentType, ContextType>;
  deletedTrainingId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  trainingEdge?: Resolver<Maybe<ResolversTypes['TrainingsEdge']>, ParentType, ContextType, RequireFields<DeleteTrainingPayloadtrainingEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteTransactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteTransactionPayload'] = ResolversParentTypes['DeleteTransactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType>;
  deletedTransactionId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  transactionEdge?: Resolver<Maybe<ResolversTypes['TransactionsEdge']>, ParentType, ContextType, RequireFields<DeleteTransactionPayloadtransactionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteUploadFilePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteUploadFilePayload'] = ResolversParentTypes['DeleteUploadFilePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uploadFile?: Resolver<Maybe<ResolversTypes['UploadFile']>, ParentType, ContextType>;
  deletedUploadFileId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  uploadFileEdge?: Resolver<Maybe<ResolversTypes['UploadFilesEdge']>, ParentType, ContextType, RequireFields<DeleteUploadFilePayloaduploadFileEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteUserPayload'] = ResolversParentTypes['DeleteUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  deletedUserId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<DeleteUserPayloaduserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteVendorPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteVendorPayload'] = ResolversParentTypes['DeleteVendorPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vendor?: Resolver<Maybe<ResolversTypes['Vendor']>, ParentType, ContextType>;
  deletedVendorId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  vendorEdge?: Resolver<Maybe<ResolversTypes['VendorsEdge']>, ParentType, ContextType, RequireFields<DeleteVendorPayloadvendorEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteVisitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteVisitPayload'] = ResolversParentTypes['DeleteVisitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visit?: Resolver<Maybe<ResolversTypes['Visit']>, ParentType, ContextType>;
  deletedVisitId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  visitEdge?: Resolver<Maybe<ResolversTypes['VisitsEdge']>, ParentType, ContextType, RequireFields<DeleteVisitPayloadvisitEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteWarehousePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteWarehousePayload'] = ResolversParentTypes['DeleteWarehousePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  deletedWarehouseId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  warehouseEdge?: Resolver<Maybe<ResolversTypes['WarehousesEdge']>, ParentType, ContextType, RequireFields<DeleteWarehousePayloadwarehouseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteWebhookPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteWebhookPayload'] = ResolversParentTypes['DeleteWebhookPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  webhook?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType>;
  deletedWebhookId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webhookEdge?: Resolver<Maybe<ResolversTypes['WebhooksEdge']>, ParentType, ContextType, RequireFields<DeleteWebhookPayloadwebhookEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteWebsitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteWebsitePayload'] = ResolversParentTypes['DeleteWebsitePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  website?: Resolver<Maybe<ResolversTypes['Website']>, ParentType, ContextType>;
  deletedWebsiteId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  websiteEdge?: Resolver<Maybe<ResolversTypes['WebsitesEdge']>, ParentType, ContextType, RequireFields<DeleteWebsitePayloadwebsiteEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteWishlistPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteWishlistPayload'] = ResolversParentTypes['DeleteWishlistPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  wishlist?: Resolver<Maybe<ResolversTypes['Wishlist']>, ParentType, ContextType>;
  deletedWishlistId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  wishlistEdge?: Resolver<Maybe<ResolversTypes['WishlistsEdge']>, ParentType, ContextType, RequireFields<DeleteWishlistPayloadwishlistEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteWorkspacePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteWorkspacePayload'] = ResolversParentTypes['DeleteWorkspacePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  workspace?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType>;
  deletedWorkspaceId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  workspaceEdge?: Resolver<Maybe<ResolversTypes['WorkspacesEdge']>, ParentType, ContextType, RequireFields<DeleteWorkspacePayloadworkspaceEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DeleteZonePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['DeleteZonePayload'] = ResolversParentTypes['DeleteZonePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  zone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType>;
  deletedZoneId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  zoneEdge?: Resolver<Maybe<ResolversTypes['ZonesEdge']>, ParentType, ContextType, RequireFields<DeleteZonePayloadzoneEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscriptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = ResolversObject<{
  query?: SubscriptionResolver<ResolversTypes['Query'], "query", ParentType, ContextType>;
  nodeId?: SubscriptionResolver<ResolversTypes['ID'], "nodeId", ParentType, ContextType>;
  node?: SubscriptionResolver<Maybe<ResolversTypes['Node']>, "node", ParentType, ContextType, RequireFields<SubscriptionnodeArgs, 'nodeId'>>;
  allAccounts?: SubscriptionResolver<Maybe<ResolversTypes['AccountsConnection']>, "allAccounts", ParentType, ContextType, RequireFields<SubscriptionallAccountsArgs, 'orderBy'>>;
  allAccountsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Account']>>, "allAccountsList", ParentType, ContextType, Partial<SubscriptionallAccountsListArgs>>;
  allAgreements?: SubscriptionResolver<Maybe<ResolversTypes['AgreementsConnection']>, "allAgreements", ParentType, ContextType, RequireFields<SubscriptionallAgreementsArgs, 'orderBy'>>;
  allAgreementsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Agreement']>>, "allAgreementsList", ParentType, ContextType, Partial<SubscriptionallAgreementsListArgs>>;
  allAnalytics?: SubscriptionResolver<Maybe<ResolversTypes['AnalyticsConnection']>, "allAnalytics", ParentType, ContextType, RequireFields<SubscriptionallAnalyticsArgs, 'orderBy'>>;
  allAnalyticsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Analytic']>>, "allAnalyticsList", ParentType, ContextType, Partial<SubscriptionallAnalyticsListArgs>>;
  allApitokens?: SubscriptionResolver<Maybe<ResolversTypes['ApitokensConnection']>, "allApitokens", ParentType, ContextType, RequireFields<SubscriptionallApitokensArgs, 'orderBy'>>;
  allApitokensList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Apitoken']>>, "allApitokensList", ParentType, ContextType, Partial<SubscriptionallApitokensListArgs>>;
  allArticles?: SubscriptionResolver<Maybe<ResolversTypes['ArticlesConnection']>, "allArticles", ParentType, ContextType, RequireFields<SubscriptionallArticlesArgs, 'orderBy'>>;
  allArticlesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Article']>>, "allArticlesList", ParentType, ContextType, Partial<SubscriptionallArticlesListArgs>>;
  allAttributes?: SubscriptionResolver<Maybe<ResolversTypes['AttributesConnection']>, "allAttributes", ParentType, ContextType, RequireFields<SubscriptionallAttributesArgs, 'orderBy'>>;
  allAttributesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Attribute']>>, "allAttributesList", ParentType, ContextType, Partial<SubscriptionallAttributesListArgs>>;
  allBrands?: SubscriptionResolver<Maybe<ResolversTypes['BrandsConnection']>, "allBrands", ParentType, ContextType, RequireFields<SubscriptionallBrandsArgs, 'orderBy'>>;
  allBrandsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Brand']>>, "allBrandsList", ParentType, ContextType, Partial<SubscriptionallBrandsListArgs>>;
  allCartPriceRules?: SubscriptionResolver<Maybe<ResolversTypes['CartPriceRulesConnection']>, "allCartPriceRules", ParentType, ContextType, RequireFields<SubscriptionallCartPriceRulesArgs, 'orderBy'>>;
  allCartPriceRulesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['CartPriceRule']>>, "allCartPriceRulesList", ParentType, ContextType, Partial<SubscriptionallCartPriceRulesListArgs>>;
  allCases?: SubscriptionResolver<Maybe<ResolversTypes['CasesConnection']>, "allCases", ParentType, ContextType, RequireFields<SubscriptionallCasesArgs, 'orderBy'>>;
  allCasesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Case']>>, "allCasesList", ParentType, ContextType, Partial<SubscriptionallCasesListArgs>>;
  allCatalogPriceRules?: SubscriptionResolver<Maybe<ResolversTypes['CatalogPriceRulesConnection']>, "allCatalogPriceRules", ParentType, ContextType, RequireFields<SubscriptionallCatalogPriceRulesArgs, 'orderBy'>>;
  allCatalogPriceRulesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['CatalogPriceRule']>>, "allCatalogPriceRulesList", ParentType, ContextType, Partial<SubscriptionallCatalogPriceRulesListArgs>>;
  allCategories?: SubscriptionResolver<Maybe<ResolversTypes['CategoriesConnection']>, "allCategories", ParentType, ContextType, RequireFields<SubscriptionallCategoriesArgs, 'orderBy'>>;
  allCategoriesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Category']>>, "allCategoriesList", ParentType, ContextType, Partial<SubscriptionallCategoriesListArgs>>;
  allChannels?: SubscriptionResolver<Maybe<ResolversTypes['ChannelsConnection']>, "allChannels", ParentType, ContextType, RequireFields<SubscriptionallChannelsArgs, 'orderBy'>>;
  allChannelsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Channel']>>, "allChannelsList", ParentType, ContextType, Partial<SubscriptionallChannelsListArgs>>;
  allChecklists?: SubscriptionResolver<Maybe<ResolversTypes['ChecklistsConnection']>, "allChecklists", ParentType, ContextType, RequireFields<SubscriptionallChecklistsArgs, 'orderBy'>>;
  allChecklistsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Checklist']>>, "allChecklistsList", ParentType, ContextType, Partial<SubscriptionallChecklistsListArgs>>;
  allCities?: SubscriptionResolver<Maybe<ResolversTypes['CitiesConnection']>, "allCities", ParentType, ContextType, RequireFields<SubscriptionallCitiesArgs, 'orderBy'>>;
  allCitiesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['City']>>, "allCitiesList", ParentType, ContextType, Partial<SubscriptionallCitiesListArgs>>;
  allCollections?: SubscriptionResolver<Maybe<ResolversTypes['CollectionsConnection']>, "allCollections", ParentType, ContextType, RequireFields<SubscriptionallCollectionsArgs, 'orderBy'>>;
  allCollectionsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Collection']>>, "allCollectionsList", ParentType, ContextType, Partial<SubscriptionallCollectionsListArgs>>;
  allComments?: SubscriptionResolver<Maybe<ResolversTypes['CommentsConnection']>, "allComments", ParentType, ContextType, RequireFields<SubscriptionallCommentsArgs, 'orderBy'>>;
  allCommentsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Comment']>>, "allCommentsList", ParentType, ContextType, Partial<SubscriptionallCommentsListArgs>>;
  allContentTypes?: SubscriptionResolver<Maybe<ResolversTypes['ContentTypesConnection']>, "allContentTypes", ParentType, ContextType, RequireFields<SubscriptionallContentTypesArgs, 'orderBy'>>;
  allContentTypesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['ContentType']>>, "allContentTypesList", ParentType, ContextType, Partial<SubscriptionallContentTypesListArgs>>;
  allContracts?: SubscriptionResolver<Maybe<ResolversTypes['ContractsConnection']>, "allContracts", ParentType, ContextType, RequireFields<SubscriptionallContractsArgs, 'orderBy'>>;
  allContractsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Contract']>>, "allContractsList", ParentType, ContextType, Partial<SubscriptionallContractsListArgs>>;
  allCountries?: SubscriptionResolver<Maybe<ResolversTypes['CountriesConnection']>, "allCountries", ParentType, ContextType, RequireFields<SubscriptionallCountriesArgs, 'orderBy'>>;
  allCountriesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Country']>>, "allCountriesList", ParentType, ContextType, Partial<SubscriptionallCountriesListArgs>>;
  allCoupons?: SubscriptionResolver<Maybe<ResolversTypes['CouponsConnection']>, "allCoupons", ParentType, ContextType, RequireFields<SubscriptionallCouponsArgs, 'orderBy'>>;
  allCouponsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Coupon']>>, "allCouponsList", ParentType, ContextType, Partial<SubscriptionallCouponsListArgs>>;
  allCreditMemos?: SubscriptionResolver<Maybe<ResolversTypes['CreditMemosConnection']>, "allCreditMemos", ParentType, ContextType, RequireFields<SubscriptionallCreditMemosArgs, 'orderBy'>>;
  allCreditMemosList?: SubscriptionResolver<Maybe<Array<ResolversTypes['CreditMemo']>>, "allCreditMemosList", ParentType, ContextType, Partial<SubscriptionallCreditMemosListArgs>>;
  allCurrencies?: SubscriptionResolver<Maybe<ResolversTypes['CurrenciesConnection']>, "allCurrencies", ParentType, ContextType, RequireFields<SubscriptionallCurrenciesArgs, 'orderBy'>>;
  allCurrenciesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Currency']>>, "allCurrenciesList", ParentType, ContextType, Partial<SubscriptionallCurrenciesListArgs>>;
  allCurrencyRates?: SubscriptionResolver<Maybe<ResolversTypes['CurrencyRatesConnection']>, "allCurrencyRates", ParentType, ContextType, RequireFields<SubscriptionallCurrencyRatesArgs, 'orderBy'>>;
  allCurrencyRatesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['CurrencyRate']>>, "allCurrencyRatesList", ParentType, ContextType, Partial<SubscriptionallCurrencyRatesListArgs>>;
  allCurrencySymbols?: SubscriptionResolver<Maybe<ResolversTypes['CurrencySymbolsConnection']>, "allCurrencySymbols", ParentType, ContextType, RequireFields<SubscriptionallCurrencySymbolsArgs, 'orderBy'>>;
  allCurrencySymbolsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['CurrencySymbol']>>, "allCurrencySymbolsList", ParentType, ContextType, Partial<SubscriptionallCurrencySymbolsListArgs>>;
  allCustomerGroups?: SubscriptionResolver<Maybe<ResolversTypes['CustomerGroupsConnection']>, "allCustomerGroups", ParentType, ContextType, RequireFields<SubscriptionallCustomerGroupsArgs, 'orderBy'>>;
  allCustomerGroupsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['CustomerGroup']>>, "allCustomerGroupsList", ParentType, ContextType, Partial<SubscriptionallCustomerGroupsListArgs>>;
  allCustomers?: SubscriptionResolver<Maybe<ResolversTypes['CustomersConnection']>, "allCustomers", ParentType, ContextType, RequireFields<SubscriptionallCustomersArgs, 'orderBy'>>;
  allCustomersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Customer']>>, "allCustomersList", ParentType, ContextType, Partial<SubscriptionallCustomersListArgs>>;
  allCustomizations?: SubscriptionResolver<Maybe<ResolversTypes['CustomizationsConnection']>, "allCustomizations", ParentType, ContextType, RequireFields<SubscriptionallCustomizationsArgs, 'orderBy'>>;
  allCustomizationsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Customization']>>, "allCustomizationsList", ParentType, ContextType, Partial<SubscriptionallCustomizationsListArgs>>;
  allDashboards?: SubscriptionResolver<Maybe<ResolversTypes['DashboardsConnection']>, "allDashboards", ParentType, ContextType, RequireFields<SubscriptionallDashboardsArgs, 'orderBy'>>;
  allDashboardsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Dashboard']>>, "allDashboardsList", ParentType, ContextType, Partial<SubscriptionallDashboardsListArgs>>;
  allDeepdives?: SubscriptionResolver<Maybe<ResolversTypes['DeepdivesConnection']>, "allDeepdives", ParentType, ContextType, RequireFields<SubscriptionallDeepdivesArgs, 'orderBy'>>;
  allDeepdivesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Deepdive']>>, "allDeepdivesList", ParentType, ContextType, Partial<SubscriptionallDeepdivesListArgs>>;
  allDigiboards?: SubscriptionResolver<Maybe<ResolversTypes['DigiboardsConnection']>, "allDigiboards", ParentType, ContextType, RequireFields<SubscriptionallDigiboardsArgs, 'orderBy'>>;
  allDigiboardsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Digiboard']>>, "allDigiboardsList", ParentType, ContextType, Partial<SubscriptionallDigiboardsListArgs>>;
  allEmails?: SubscriptionResolver<Maybe<ResolversTypes['EmailsConnection']>, "allEmails", ParentType, ContextType, RequireFields<SubscriptionallEmailsArgs, 'orderBy'>>;
  allEmailsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Email']>>, "allEmailsList", ParentType, ContextType, Partial<SubscriptionallEmailsListArgs>>;
  allEndofshifts?: SubscriptionResolver<Maybe<ResolversTypes['EndofshiftsConnection']>, "allEndofshifts", ParentType, ContextType, RequireFields<SubscriptionallEndofshiftsArgs, 'orderBy'>>;
  allEndofshiftsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Endofshift']>>, "allEndofshiftsList", ParentType, ContextType, Partial<SubscriptionallEndofshiftsListArgs>>;
  allEvents?: SubscriptionResolver<Maybe<ResolversTypes['EventsConnection']>, "allEvents", ParentType, ContextType, RequireFields<SubscriptionallEventsArgs, 'orderBy'>>;
  allEventsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Event']>>, "allEventsList", ParentType, ContextType, Partial<SubscriptionallEventsListArgs>>;
  allFullfillments?: SubscriptionResolver<Maybe<ResolversTypes['FullfillmentsConnection']>, "allFullfillments", ParentType, ContextType, RequireFields<SubscriptionallFullfillmentsArgs, 'orderBy'>>;
  allFullfillmentsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Fullfillment']>>, "allFullfillmentsList", ParentType, ContextType, Partial<SubscriptionallFullfillmentsListArgs>>;
  allGiftCertificates?: SubscriptionResolver<Maybe<ResolversTypes['GiftCertificatesConnection']>, "allGiftCertificates", ParentType, ContextType, RequireFields<SubscriptionallGiftCertificatesArgs, 'orderBy'>>;
  allGiftCertificatesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['GiftCertificate']>>, "allGiftCertificatesList", ParentType, ContextType, Partial<SubscriptionallGiftCertificatesListArgs>>;
  allGlossaries?: SubscriptionResolver<Maybe<ResolversTypes['GlossariesConnection']>, "allGlossaries", ParentType, ContextType, RequireFields<SubscriptionallGlossariesArgs, 'orderBy'>>;
  allGlossariesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Glossary']>>, "allGlossariesList", ParentType, ContextType, Partial<SubscriptionallGlossariesListArgs>>;
  allImportms?: SubscriptionResolver<Maybe<ResolversTypes['ImportmsConnection']>, "allImportms", ParentType, ContextType, RequireFields<SubscriptionallImportmsArgs, 'orderBy'>>;
  allImportmsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Importm']>>, "allImportmsList", ParentType, ContextType, Partial<SubscriptionallImportmsListArgs>>;
  allIntegrations?: SubscriptionResolver<Maybe<ResolversTypes['IntegrationsConnection']>, "allIntegrations", ParentType, ContextType, RequireFields<SubscriptionallIntegrationsArgs, 'orderBy'>>;
  allIntegrationsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Integration']>>, "allIntegrationsList", ParentType, ContextType, Partial<SubscriptionallIntegrationsListArgs>>;
  allInternalizations?: SubscriptionResolver<Maybe<ResolversTypes['InternalizationsConnection']>, "allInternalizations", ParentType, ContextType, RequireFields<SubscriptionallInternalizationsArgs, 'orderBy'>>;
  allInternalizationsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Internalization']>>, "allInternalizationsList", ParentType, ContextType, Partial<SubscriptionallInternalizationsListArgs>>;
  allInvitations?: SubscriptionResolver<Maybe<ResolversTypes['InvitationsConnection']>, "allInvitations", ParentType, ContextType, RequireFields<SubscriptionallInvitationsArgs, 'orderBy'>>;
  allInvitationsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Invitation']>>, "allInvitationsList", ParentType, ContextType, Partial<SubscriptionallInvitationsListArgs>>;
  allInvoices?: SubscriptionResolver<Maybe<ResolversTypes['InvoicesConnection']>, "allInvoices", ParentType, ContextType, RequireFields<SubscriptionallInvoicesArgs, 'orderBy'>>;
  allInvoicesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Invoice']>>, "allInvoicesList", ParentType, ContextType, Partial<SubscriptionallInvoicesListArgs>>;
  allLeads?: SubscriptionResolver<Maybe<ResolversTypes['LeadsConnection']>, "allLeads", ParentType, ContextType, RequireFields<SubscriptionallLeadsArgs, 'orderBy'>>;
  allLeadsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Lead']>>, "allLeadsList", ParentType, ContextType, Partial<SubscriptionallLeadsListArgs>>;
  allManufacturers?: SubscriptionResolver<Maybe<ResolversTypes['ManufacturersConnection']>, "allManufacturers", ParentType, ContextType, RequireFields<SubscriptionallManufacturersArgs, 'orderBy'>>;
  allManufacturersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Manufacturer']>>, "allManufacturersList", ParentType, ContextType, Partial<SubscriptionallManufacturersListArgs>>;
  allMediamanagers?: SubscriptionResolver<Maybe<ResolversTypes['MediamanagersConnection']>, "allMediamanagers", ParentType, ContextType, RequireFields<SubscriptionallMediamanagersArgs, 'orderBy'>>;
  allMediamanagersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Mediamanager']>>, "allMediamanagersList", ParentType, ContextType, Partial<SubscriptionallMediamanagersListArgs>>;
  allMeetings?: SubscriptionResolver<Maybe<ResolversTypes['MeetingsConnection']>, "allMeetings", ParentType, ContextType, RequireFields<SubscriptionallMeetingsArgs, 'orderBy'>>;
  allMeetingsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Meeting']>>, "allMeetingsList", ParentType, ContextType, Partial<SubscriptionallMeetingsListArgs>>;
  allMessages?: SubscriptionResolver<Maybe<ResolversTypes['MessagesConnection']>, "allMessages", ParentType, ContextType, RequireFields<SubscriptionallMessagesArgs, 'orderBy'>>;
  allMessagesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Message']>>, "allMessagesList", ParentType, ContextType, Partial<SubscriptionallMessagesListArgs>>;
  allNewsletters?: SubscriptionResolver<Maybe<ResolversTypes['NewslettersConnection']>, "allNewsletters", ParentType, ContextType, RequireFields<SubscriptionallNewslettersArgs, 'orderBy'>>;
  allNewslettersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Newsletter']>>, "allNewslettersList", ParentType, ContextType, Partial<SubscriptionallNewslettersListArgs>>;
  allOotos?: SubscriptionResolver<Maybe<ResolversTypes['OotosConnection']>, "allOotos", ParentType, ContextType, RequireFields<SubscriptionallOotosArgs, 'orderBy'>>;
  allOotosList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Ooto']>>, "allOotosList", ParentType, ContextType, Partial<SubscriptionallOotosListArgs>>;
  allOpportunities?: SubscriptionResolver<Maybe<ResolversTypes['OpportunitiesConnection']>, "allOpportunities", ParentType, ContextType, RequireFields<SubscriptionallOpportunitiesArgs, 'orderBy'>>;
  allOpportunitiesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Opportunity']>>, "allOpportunitiesList", ParentType, ContextType, Partial<SubscriptionallOpportunitiesListArgs>>;
  allOrders?: SubscriptionResolver<Maybe<ResolversTypes['OrdersConnection']>, "allOrders", ParentType, ContextType, RequireFields<SubscriptionallOrdersArgs, 'orderBy'>>;
  allOrdersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Order']>>, "allOrdersList", ParentType, ContextType, Partial<SubscriptionallOrdersListArgs>>;
  allPages?: SubscriptionResolver<Maybe<ResolversTypes['PagesConnection']>, "allPages", ParentType, ContextType, RequireFields<SubscriptionallPagesArgs, 'orderBy'>>;
  allPagesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Page']>>, "allPagesList", ParentType, ContextType, Partial<SubscriptionallPagesListArgs>>;
  allPartners?: SubscriptionResolver<Maybe<ResolversTypes['PartnersConnection']>, "allPartners", ParentType, ContextType, RequireFields<SubscriptionallPartnersArgs, 'orderBy'>>;
  allPartnersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Partner']>>, "allPartnersList", ParentType, ContextType, Partial<SubscriptionallPartnersListArgs>>;
  allPayments?: SubscriptionResolver<Maybe<ResolversTypes['PaymentsConnection']>, "allPayments", ParentType, ContextType, RequireFields<SubscriptionallPaymentsArgs, 'orderBy'>>;
  allPaymentsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Payment']>>, "allPaymentsList", ParentType, ContextType, Partial<SubscriptionallPaymentsListArgs>>;
  allPermissions?: SubscriptionResolver<Maybe<ResolversTypes['PermissionsConnection']>, "allPermissions", ParentType, ContextType, RequireFields<SubscriptionallPermissionsArgs, 'orderBy'>>;
  allPermissionsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Permission']>>, "allPermissionsList", ParentType, ContextType, Partial<SubscriptionallPermissionsListArgs>>;
  allPlugins?: SubscriptionResolver<Maybe<ResolversTypes['PluginsConnection']>, "allPlugins", ParentType, ContextType, RequireFields<SubscriptionallPluginsArgs, 'orderBy'>>;
  allPluginsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Plugin']>>, "allPluginsList", ParentType, ContextType, Partial<SubscriptionallPluginsListArgs>>;
  allPolls?: SubscriptionResolver<Maybe<ResolversTypes['PollsConnection']>, "allPolls", ParentType, ContextType, RequireFields<SubscriptionallPollsArgs, 'orderBy'>>;
  allPollsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Poll']>>, "allPollsList", ParentType, ContextType, Partial<SubscriptionallPollsListArgs>>;
  allProductTypes?: SubscriptionResolver<Maybe<ResolversTypes['ProductTypesConnection']>, "allProductTypes", ParentType, ContextType, RequireFields<SubscriptionallProductTypesArgs, 'orderBy'>>;
  allProductTypesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['ProductType']>>, "allProductTypesList", ParentType, ContextType, Partial<SubscriptionallProductTypesListArgs>>;
  allProducts?: SubscriptionResolver<Maybe<ResolversTypes['ProductsConnection']>, "allProducts", ParentType, ContextType, RequireFields<SubscriptionallProductsArgs, 'orderBy'>>;
  allProductsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Product']>>, "allProductsList", ParentType, ContextType, Partial<SubscriptionallProductsListArgs>>;
  allProjects?: SubscriptionResolver<Maybe<ResolversTypes['ProjectsConnection']>, "allProjects", ParentType, ContextType, RequireFields<SubscriptionallProjectsArgs, 'orderBy'>>;
  allProjectsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Project']>>, "allProjectsList", ParentType, ContextType, Partial<SubscriptionallProjectsListArgs>>;
  allProviders?: SubscriptionResolver<Maybe<ResolversTypes['ProvidersConnection']>, "allProviders", ParentType, ContextType, RequireFields<SubscriptionallProvidersArgs, 'orderBy'>>;
  allProvidersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Provider']>>, "allProvidersList", ParentType, ContextType, Partial<SubscriptionallProvidersListArgs>>;
  allQuotes?: SubscriptionResolver<Maybe<ResolversTypes['QuotesConnection']>, "allQuotes", ParentType, ContextType, RequireFields<SubscriptionallQuotesArgs, 'orderBy'>>;
  allQuotesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Quote']>>, "allQuotesList", ParentType, ContextType, Partial<SubscriptionallQuotesListArgs>>;
  allRatings?: SubscriptionResolver<Maybe<ResolversTypes['RatingsConnection']>, "allRatings", ParentType, ContextType, RequireFields<SubscriptionallRatingsArgs, 'orderBy'>>;
  allRatingsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Rating']>>, "allRatingsList", ParentType, ContextType, Partial<SubscriptionallRatingsListArgs>>;
  allReports?: SubscriptionResolver<Maybe<ResolversTypes['ReportsConnection']>, "allReports", ParentType, ContextType, RequireFields<SubscriptionallReportsArgs, 'orderBy'>>;
  allReportsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Report']>>, "allReportsList", ParentType, ContextType, Partial<SubscriptionallReportsListArgs>>;
  allReturns?: SubscriptionResolver<Maybe<ResolversTypes['ReturnsConnection']>, "allReturns", ParentType, ContextType, RequireFields<SubscriptionallReturnsArgs, 'orderBy'>>;
  allReturnsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Return']>>, "allReturnsList", ParentType, ContextType, Partial<SubscriptionallReturnsListArgs>>;
  allReviews?: SubscriptionResolver<Maybe<ResolversTypes['ReviewsConnection']>, "allReviews", ParentType, ContextType, RequireFields<SubscriptionallReviewsArgs, 'orderBy'>>;
  allReviewsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Review']>>, "allReviewsList", ParentType, ContextType, Partial<SubscriptionallReviewsListArgs>>;
  allRewards?: SubscriptionResolver<Maybe<ResolversTypes['RewardsConnection']>, "allRewards", ParentType, ContextType, RequireFields<SubscriptionallRewardsArgs, 'orderBy'>>;
  allRewardsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Reward']>>, "allRewardsList", ParentType, ContextType, Partial<SubscriptionallRewardsListArgs>>;
  allRoles?: SubscriptionResolver<Maybe<ResolversTypes['RolesConnection']>, "allRoles", ParentType, ContextType, RequireFields<SubscriptionallRolesArgs, 'orderBy'>>;
  allRolesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Role']>>, "allRolesList", ParentType, ContextType, Partial<SubscriptionallRolesListArgs>>;
  allSchedulers?: SubscriptionResolver<Maybe<ResolversTypes['SchedulersConnection']>, "allSchedulers", ParentType, ContextType, RequireFields<SubscriptionallSchedulersArgs, 'orderBy'>>;
  allSchedulersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Scheduler']>>, "allSchedulersList", ParentType, ContextType, Partial<SubscriptionallSchedulersListArgs>>;
  allSegments?: SubscriptionResolver<Maybe<ResolversTypes['SegmentsConnection']>, "allSegments", ParentType, ContextType, RequireFields<SubscriptionallSegmentsArgs, 'orderBy'>>;
  allSegmentsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Segment']>>, "allSegmentsList", ParentType, ContextType, Partial<SubscriptionallSegmentsListArgs>>;
  allSettings?: SubscriptionResolver<Maybe<ResolversTypes['SettingsConnection']>, "allSettings", ParentType, ContextType, RequireFields<SubscriptionallSettingsArgs, 'orderBy'>>;
  allSettingsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Setting']>>, "allSettingsList", ParentType, ContextType, Partial<SubscriptionallSettingsListArgs>>;
  allShipments?: SubscriptionResolver<Maybe<ResolversTypes['ShipmentsConnection']>, "allShipments", ParentType, ContextType, RequireFields<SubscriptionallShipmentsArgs, 'orderBy'>>;
  allShipmentsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Shipment']>>, "allShipmentsList", ParentType, ContextType, Partial<SubscriptionallShipmentsListArgs>>;
  allSpecialDiscounts?: SubscriptionResolver<Maybe<ResolversTypes['SpecialDiscountsConnection']>, "allSpecialDiscounts", ParentType, ContextType, RequireFields<SubscriptionallSpecialDiscountsArgs, 'orderBy'>>;
  allSpecialDiscountsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['SpecialDiscount']>>, "allSpecialDiscountsList", ParentType, ContextType, Partial<SubscriptionallSpecialDiscountsListArgs>>;
  allStates?: SubscriptionResolver<Maybe<ResolversTypes['StatesConnection']>, "allStates", ParentType, ContextType, RequireFields<SubscriptionallStatesArgs, 'orderBy'>>;
  allStatesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['State']>>, "allStatesList", ParentType, ContextType, Partial<SubscriptionallStatesListArgs>>;
  allStatistics?: SubscriptionResolver<Maybe<ResolversTypes['StatisticsConnection']>, "allStatistics", ParentType, ContextType, RequireFields<SubscriptionallStatisticsArgs, 'orderBy'>>;
  allStatisticsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Statistic']>>, "allStatisticsList", ParentType, ContextType, Partial<SubscriptionallStatisticsListArgs>>;
  allStocks?: SubscriptionResolver<Maybe<ResolversTypes['StocksConnection']>, "allStocks", ParentType, ContextType, RequireFields<SubscriptionallStocksArgs, 'orderBy'>>;
  allStocksList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Stock']>>, "allStocksList", ParentType, ContextType, Partial<SubscriptionallStocksListArgs>>;
  allSurveys?: SubscriptionResolver<Maybe<ResolversTypes['SurveysConnection']>, "allSurveys", ParentType, ContextType, RequireFields<SubscriptionallSurveysArgs, 'orderBy'>>;
  allSurveysList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Survey']>>, "allSurveysList", ParentType, ContextType, Partial<SubscriptionallSurveysListArgs>>;
  allTags?: SubscriptionResolver<Maybe<ResolversTypes['TagsConnection']>, "allTags", ParentType, ContextType, RequireFields<SubscriptionallTagsArgs, 'orderBy'>>;
  allTagsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Tag']>>, "allTagsList", ParentType, ContextType, Partial<SubscriptionallTagsListArgs>>;
  allTargets?: SubscriptionResolver<Maybe<ResolversTypes['TargetsConnection']>, "allTargets", ParentType, ContextType, RequireFields<SubscriptionallTargetsArgs, 'orderBy'>>;
  allTargetsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Target']>>, "allTargetsList", ParentType, ContextType, Partial<SubscriptionallTargetsListArgs>>;
  allTaxCategories?: SubscriptionResolver<Maybe<ResolversTypes['TaxCategoriesConnection']>, "allTaxCategories", ParentType, ContextType, RequireFields<SubscriptionallTaxCategoriesArgs, 'orderBy'>>;
  allTaxCategoriesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['TaxCategory']>>, "allTaxCategoriesList", ParentType, ContextType, Partial<SubscriptionallTaxCategoriesListArgs>>;
  allTaxRates?: SubscriptionResolver<Maybe<ResolversTypes['TaxRatesConnection']>, "allTaxRates", ParentType, ContextType, RequireFields<SubscriptionallTaxRatesArgs, 'orderBy'>>;
  allTaxRatesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['TaxRate']>>, "allTaxRatesList", ParentType, ContextType, Partial<SubscriptionallTaxRatesListArgs>>;
  allTaxRules?: SubscriptionResolver<Maybe<ResolversTypes['TaxRulesConnection']>, "allTaxRules", ParentType, ContextType, RequireFields<SubscriptionallTaxRulesArgs, 'orderBy'>>;
  allTaxRulesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['TaxRule']>>, "allTaxRulesList", ParentType, ContextType, Partial<SubscriptionallTaxRulesListArgs>>;
  allTemplates?: SubscriptionResolver<Maybe<ResolversTypes['TemplatesConnection']>, "allTemplates", ParentType, ContextType, RequireFields<SubscriptionallTemplatesArgs, 'orderBy'>>;
  allTemplatesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Template']>>, "allTemplatesList", ParentType, ContextType, Partial<SubscriptionallTemplatesListArgs>>;
  allThemes?: SubscriptionResolver<Maybe<ResolversTypes['ThemesConnection']>, "allThemes", ParentType, ContextType, RequireFields<SubscriptionallThemesArgs, 'orderBy'>>;
  allThemesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Theme']>>, "allThemesList", ParentType, ContextType, Partial<SubscriptionallThemesListArgs>>;
  allTicketings?: SubscriptionResolver<Maybe<ResolversTypes['TicketingsConnection']>, "allTicketings", ParentType, ContextType, RequireFields<SubscriptionallTicketingsArgs, 'orderBy'>>;
  allTicketingsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Ticketing']>>, "allTicketingsList", ParentType, ContextType, Partial<SubscriptionallTicketingsListArgs>>;
  allTrainings?: SubscriptionResolver<Maybe<ResolversTypes['TrainingsConnection']>, "allTrainings", ParentType, ContextType, RequireFields<SubscriptionallTrainingsArgs, 'orderBy'>>;
  allTrainingsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Training']>>, "allTrainingsList", ParentType, ContextType, Partial<SubscriptionallTrainingsListArgs>>;
  allTransactions?: SubscriptionResolver<Maybe<ResolversTypes['TransactionsConnection']>, "allTransactions", ParentType, ContextType, RequireFields<SubscriptionallTransactionsArgs, 'orderBy'>>;
  allTransactionsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Transaction']>>, "allTransactionsList", ParentType, ContextType, Partial<SubscriptionallTransactionsListArgs>>;
  allUploadFiles?: SubscriptionResolver<Maybe<ResolversTypes['UploadFilesConnection']>, "allUploadFiles", ParentType, ContextType, RequireFields<SubscriptionallUploadFilesArgs, 'orderBy'>>;
  allUploadFilesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['UploadFile']>>, "allUploadFilesList", ParentType, ContextType, Partial<SubscriptionallUploadFilesListArgs>>;
  allUsers?: SubscriptionResolver<Maybe<ResolversTypes['UsersConnection']>, "allUsers", ParentType, ContextType, RequireFields<SubscriptionallUsersArgs, 'orderBy'>>;
  allUsersList?: SubscriptionResolver<Maybe<Array<ResolversTypes['User']>>, "allUsersList", ParentType, ContextType, Partial<SubscriptionallUsersListArgs>>;
  allVendors?: SubscriptionResolver<Maybe<ResolversTypes['VendorsConnection']>, "allVendors", ParentType, ContextType, RequireFields<SubscriptionallVendorsArgs, 'orderBy'>>;
  allVendorsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Vendor']>>, "allVendorsList", ParentType, ContextType, Partial<SubscriptionallVendorsListArgs>>;
  allVisits?: SubscriptionResolver<Maybe<ResolversTypes['VisitsConnection']>, "allVisits", ParentType, ContextType, RequireFields<SubscriptionallVisitsArgs, 'orderBy'>>;
  allVisitsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Visit']>>, "allVisitsList", ParentType, ContextType, Partial<SubscriptionallVisitsListArgs>>;
  allWarehouses?: SubscriptionResolver<Maybe<ResolversTypes['WarehousesConnection']>, "allWarehouses", ParentType, ContextType, RequireFields<SubscriptionallWarehousesArgs, 'orderBy'>>;
  allWarehousesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Warehouse']>>, "allWarehousesList", ParentType, ContextType, Partial<SubscriptionallWarehousesListArgs>>;
  allWebhooks?: SubscriptionResolver<Maybe<ResolversTypes['WebhooksConnection']>, "allWebhooks", ParentType, ContextType, RequireFields<SubscriptionallWebhooksArgs, 'orderBy'>>;
  allWebhooksList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Webhook']>>, "allWebhooksList", ParentType, ContextType, Partial<SubscriptionallWebhooksListArgs>>;
  allWebsites?: SubscriptionResolver<Maybe<ResolversTypes['WebsitesConnection']>, "allWebsites", ParentType, ContextType, RequireFields<SubscriptionallWebsitesArgs, 'orderBy'>>;
  allWebsitesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Website']>>, "allWebsitesList", ParentType, ContextType, Partial<SubscriptionallWebsitesListArgs>>;
  allWishlists?: SubscriptionResolver<Maybe<ResolversTypes['WishlistsConnection']>, "allWishlists", ParentType, ContextType, RequireFields<SubscriptionallWishlistsArgs, 'orderBy'>>;
  allWishlistsList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Wishlist']>>, "allWishlistsList", ParentType, ContextType, Partial<SubscriptionallWishlistsListArgs>>;
  allWorkspaces?: SubscriptionResolver<Maybe<ResolversTypes['WorkspacesConnection']>, "allWorkspaces", ParentType, ContextType, RequireFields<SubscriptionallWorkspacesArgs, 'orderBy'>>;
  allWorkspacesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Workspace']>>, "allWorkspacesList", ParentType, ContextType, Partial<SubscriptionallWorkspacesListArgs>>;
  allZones?: SubscriptionResolver<Maybe<ResolversTypes['ZonesConnection']>, "allZones", ParentType, ContextType, RequireFields<SubscriptionallZonesArgs, 'orderBy'>>;
  allZonesList?: SubscriptionResolver<Maybe<Array<ResolversTypes['Zone']>>, "allZonesList", ParentType, ContextType, Partial<SubscriptionallZonesListArgs>>;
  accountById?: SubscriptionResolver<Maybe<ResolversTypes['Account']>, "accountById", ParentType, ContextType, RequireFields<SubscriptionaccountByIdArgs, 'id'>>;
  agreementById?: SubscriptionResolver<Maybe<ResolversTypes['Agreement']>, "agreementById", ParentType, ContextType, RequireFields<SubscriptionagreementByIdArgs, 'id'>>;
  analyticById?: SubscriptionResolver<Maybe<ResolversTypes['Analytic']>, "analyticById", ParentType, ContextType, RequireFields<SubscriptionanalyticByIdArgs, 'id'>>;
  apitokenById?: SubscriptionResolver<Maybe<ResolversTypes['Apitoken']>, "apitokenById", ParentType, ContextType, RequireFields<SubscriptionapitokenByIdArgs, 'id'>>;
  articleById?: SubscriptionResolver<Maybe<ResolversTypes['Article']>, "articleById", ParentType, ContextType, RequireFields<SubscriptionarticleByIdArgs, 'id'>>;
  attributeById?: SubscriptionResolver<Maybe<ResolversTypes['Attribute']>, "attributeById", ParentType, ContextType, RequireFields<SubscriptionattributeByIdArgs, 'id'>>;
  brandById?: SubscriptionResolver<Maybe<ResolversTypes['Brand']>, "brandById", ParentType, ContextType, RequireFields<SubscriptionbrandByIdArgs, 'id'>>;
  cartPriceRuleById?: SubscriptionResolver<Maybe<ResolversTypes['CartPriceRule']>, "cartPriceRuleById", ParentType, ContextType, RequireFields<SubscriptioncartPriceRuleByIdArgs, 'id'>>;
  caseById?: SubscriptionResolver<Maybe<ResolversTypes['Case']>, "caseById", ParentType, ContextType, RequireFields<SubscriptioncaseByIdArgs, 'id'>>;
  catalogPriceRuleById?: SubscriptionResolver<Maybe<ResolversTypes['CatalogPriceRule']>, "catalogPriceRuleById", ParentType, ContextType, RequireFields<SubscriptioncatalogPriceRuleByIdArgs, 'id'>>;
  categoryById?: SubscriptionResolver<Maybe<ResolversTypes['Category']>, "categoryById", ParentType, ContextType, RequireFields<SubscriptioncategoryByIdArgs, 'id'>>;
  channelById?: SubscriptionResolver<Maybe<ResolversTypes['Channel']>, "channelById", ParentType, ContextType, RequireFields<SubscriptionchannelByIdArgs, 'id'>>;
  checklistById?: SubscriptionResolver<Maybe<ResolversTypes['Checklist']>, "checklistById", ParentType, ContextType, RequireFields<SubscriptionchecklistByIdArgs, 'id'>>;
  cityById?: SubscriptionResolver<Maybe<ResolversTypes['City']>, "cityById", ParentType, ContextType, RequireFields<SubscriptioncityByIdArgs, 'id'>>;
  collectionById?: SubscriptionResolver<Maybe<ResolversTypes['Collection']>, "collectionById", ParentType, ContextType, RequireFields<SubscriptioncollectionByIdArgs, 'id'>>;
  commentById?: SubscriptionResolver<Maybe<ResolversTypes['Comment']>, "commentById", ParentType, ContextType, RequireFields<SubscriptioncommentByIdArgs, 'id'>>;
  contentTypeById?: SubscriptionResolver<Maybe<ResolversTypes['ContentType']>, "contentTypeById", ParentType, ContextType, RequireFields<SubscriptioncontentTypeByIdArgs, 'id'>>;
  contractById?: SubscriptionResolver<Maybe<ResolversTypes['Contract']>, "contractById", ParentType, ContextType, RequireFields<SubscriptioncontractByIdArgs, 'id'>>;
  countryById?: SubscriptionResolver<Maybe<ResolversTypes['Country']>, "countryById", ParentType, ContextType, RequireFields<SubscriptioncountryByIdArgs, 'id'>>;
  couponById?: SubscriptionResolver<Maybe<ResolversTypes['Coupon']>, "couponById", ParentType, ContextType, RequireFields<SubscriptioncouponByIdArgs, 'id'>>;
  creditMemoByCreditMemoAndId?: SubscriptionResolver<Maybe<ResolversTypes['CreditMemo']>, "creditMemoByCreditMemoAndId", ParentType, ContextType, RequireFields<SubscriptioncreditMemoByCreditMemoAndIdArgs, 'creditMemo' | 'id'>>;
  currencyById?: SubscriptionResolver<Maybe<ResolversTypes['Currency']>, "currencyById", ParentType, ContextType, RequireFields<SubscriptioncurrencyByIdArgs, 'id'>>;
  currencyRateByImportService?: SubscriptionResolver<Maybe<ResolversTypes['CurrencyRate']>, "currencyRateByImportService", ParentType, ContextType, RequireFields<SubscriptioncurrencyRateByImportServiceArgs, 'importService'>>;
  currencySymbolBySymbol?: SubscriptionResolver<Maybe<ResolversTypes['CurrencySymbol']>, "currencySymbolBySymbol", ParentType, ContextType, RequireFields<SubscriptioncurrencySymbolBySymbolArgs, 'symbol'>>;
  customerGroupById?: SubscriptionResolver<Maybe<ResolversTypes['CustomerGroup']>, "customerGroupById", ParentType, ContextType, RequireFields<SubscriptioncustomerGroupByIdArgs, 'id'>>;
  customerById?: SubscriptionResolver<Maybe<ResolversTypes['Customer']>, "customerById", ParentType, ContextType, RequireFields<SubscriptioncustomerByIdArgs, 'id'>>;
  customizationById?: SubscriptionResolver<Maybe<ResolversTypes['Customization']>, "customizationById", ParentType, ContextType, RequireFields<SubscriptioncustomizationByIdArgs, 'id'>>;
  dashboardById?: SubscriptionResolver<Maybe<ResolversTypes['Dashboard']>, "dashboardById", ParentType, ContextType, RequireFields<SubscriptiondashboardByIdArgs, 'id'>>;
  deepdiveById?: SubscriptionResolver<Maybe<ResolversTypes['Deepdive']>, "deepdiveById", ParentType, ContextType, RequireFields<SubscriptiondeepdiveByIdArgs, 'id'>>;
  digiboardById?: SubscriptionResolver<Maybe<ResolversTypes['Digiboard']>, "digiboardById", ParentType, ContextType, RequireFields<SubscriptiondigiboardByIdArgs, 'id'>>;
  emailById?: SubscriptionResolver<Maybe<ResolversTypes['Email']>, "emailById", ParentType, ContextType, RequireFields<SubscriptionemailByIdArgs, 'id'>>;
  endofshiftById?: SubscriptionResolver<Maybe<ResolversTypes['Endofshift']>, "endofshiftById", ParentType, ContextType, RequireFields<SubscriptionendofshiftByIdArgs, 'id'>>;
  eventById?: SubscriptionResolver<Maybe<ResolversTypes['Event']>, "eventById", ParentType, ContextType, RequireFields<SubscriptioneventByIdArgs, 'id'>>;
  fullfillmentById?: SubscriptionResolver<Maybe<ResolversTypes['Fullfillment']>, "fullfillmentById", ParentType, ContextType, RequireFields<SubscriptionfullfillmentByIdArgs, 'id'>>;
  giftCertificateById?: SubscriptionResolver<Maybe<ResolversTypes['GiftCertificate']>, "giftCertificateById", ParentType, ContextType, RequireFields<SubscriptiongiftCertificateByIdArgs, 'id'>>;
  glossaryById?: SubscriptionResolver<Maybe<ResolversTypes['Glossary']>, "glossaryById", ParentType, ContextType, RequireFields<SubscriptionglossaryByIdArgs, 'id'>>;
  importmById?: SubscriptionResolver<Maybe<ResolversTypes['Importm']>, "importmById", ParentType, ContextType, RequireFields<SubscriptionimportmByIdArgs, 'id'>>;
  integrationById?: SubscriptionResolver<Maybe<ResolversTypes['Integration']>, "integrationById", ParentType, ContextType, RequireFields<SubscriptionintegrationByIdArgs, 'id'>>;
  internalizationById?: SubscriptionResolver<Maybe<ResolversTypes['Internalization']>, "internalizationById", ParentType, ContextType, RequireFields<SubscriptioninternalizationByIdArgs, 'id'>>;
  invitationById?: SubscriptionResolver<Maybe<ResolversTypes['Invitation']>, "invitationById", ParentType, ContextType, RequireFields<SubscriptioninvitationByIdArgs, 'id'>>;
  invoiceById?: SubscriptionResolver<Maybe<ResolversTypes['Invoice']>, "invoiceById", ParentType, ContextType, RequireFields<SubscriptioninvoiceByIdArgs, 'id'>>;
  leadById?: SubscriptionResolver<Maybe<ResolversTypes['Lead']>, "leadById", ParentType, ContextType, RequireFields<SubscriptionleadByIdArgs, 'id'>>;
  manufacturerById?: SubscriptionResolver<Maybe<ResolversTypes['Manufacturer']>, "manufacturerById", ParentType, ContextType, RequireFields<SubscriptionmanufacturerByIdArgs, 'id'>>;
  mediamanagerById?: SubscriptionResolver<Maybe<ResolversTypes['Mediamanager']>, "mediamanagerById", ParentType, ContextType, RequireFields<SubscriptionmediamanagerByIdArgs, 'id'>>;
  meetingById?: SubscriptionResolver<Maybe<ResolversTypes['Meeting']>, "meetingById", ParentType, ContextType, RequireFields<SubscriptionmeetingByIdArgs, 'id'>>;
  messageById?: SubscriptionResolver<Maybe<ResolversTypes['Message']>, "messageById", ParentType, ContextType, RequireFields<SubscriptionmessageByIdArgs, 'id'>>;
  newsletterById?: SubscriptionResolver<Maybe<ResolversTypes['Newsletter']>, "newsletterById", ParentType, ContextType, RequireFields<SubscriptionnewsletterByIdArgs, 'id'>>;
  ootoById?: SubscriptionResolver<Maybe<ResolversTypes['Ooto']>, "ootoById", ParentType, ContextType, RequireFields<SubscriptionootoByIdArgs, 'id'>>;
  opportunityById?: SubscriptionResolver<Maybe<ResolversTypes['Opportunity']>, "opportunityById", ParentType, ContextType, RequireFields<SubscriptionopportunityByIdArgs, 'id'>>;
  orderById?: SubscriptionResolver<Maybe<ResolversTypes['Order']>, "orderById", ParentType, ContextType, RequireFields<SubscriptionorderByIdArgs, 'id'>>;
  pageById?: SubscriptionResolver<Maybe<ResolversTypes['Page']>, "pageById", ParentType, ContextType, RequireFields<SubscriptionpageByIdArgs, 'id'>>;
  partnerById?: SubscriptionResolver<Maybe<ResolversTypes['Partner']>, "partnerById", ParentType, ContextType, RequireFields<SubscriptionpartnerByIdArgs, 'id'>>;
  paymentById?: SubscriptionResolver<Maybe<ResolversTypes['Payment']>, "paymentById", ParentType, ContextType, RequireFields<SubscriptionpaymentByIdArgs, 'id'>>;
  permissionById?: SubscriptionResolver<Maybe<ResolversTypes['Permission']>, "permissionById", ParentType, ContextType, RequireFields<SubscriptionpermissionByIdArgs, 'id'>>;
  pluginById?: SubscriptionResolver<Maybe<ResolversTypes['Plugin']>, "pluginById", ParentType, ContextType, RequireFields<SubscriptionpluginByIdArgs, 'id'>>;
  pollById?: SubscriptionResolver<Maybe<ResolversTypes['Poll']>, "pollById", ParentType, ContextType, RequireFields<SubscriptionpollByIdArgs, 'id'>>;
  productTypeById?: SubscriptionResolver<Maybe<ResolversTypes['ProductType']>, "productTypeById", ParentType, ContextType, RequireFields<SubscriptionproductTypeByIdArgs, 'id'>>;
  productById?: SubscriptionResolver<Maybe<ResolversTypes['Product']>, "productById", ParentType, ContextType, RequireFields<SubscriptionproductByIdArgs, 'id'>>;
  projectById?: SubscriptionResolver<Maybe<ResolversTypes['Project']>, "projectById", ParentType, ContextType, RequireFields<SubscriptionprojectByIdArgs, 'id'>>;
  providerById?: SubscriptionResolver<Maybe<ResolversTypes['Provider']>, "providerById", ParentType, ContextType, RequireFields<SubscriptionproviderByIdArgs, 'id'>>;
  quoteById?: SubscriptionResolver<Maybe<ResolversTypes['Quote']>, "quoteById", ParentType, ContextType, RequireFields<SubscriptionquoteByIdArgs, 'id'>>;
  ratingById?: SubscriptionResolver<Maybe<ResolversTypes['Rating']>, "ratingById", ParentType, ContextType, RequireFields<SubscriptionratingByIdArgs, 'id'>>;
  reportById?: SubscriptionResolver<Maybe<ResolversTypes['Report']>, "reportById", ParentType, ContextType, RequireFields<SubscriptionreportByIdArgs, 'id'>>;
  returnById?: SubscriptionResolver<Maybe<ResolversTypes['Return']>, "returnById", ParentType, ContextType, RequireFields<SubscriptionreturnByIdArgs, 'id'>>;
  reviewById?: SubscriptionResolver<Maybe<ResolversTypes['Review']>, "reviewById", ParentType, ContextType, RequireFields<SubscriptionreviewByIdArgs, 'id'>>;
  rewardById?: SubscriptionResolver<Maybe<ResolversTypes['Reward']>, "rewardById", ParentType, ContextType, RequireFields<SubscriptionrewardByIdArgs, 'id'>>;
  roleById?: SubscriptionResolver<Maybe<ResolversTypes['Role']>, "roleById", ParentType, ContextType, RequireFields<SubscriptionroleByIdArgs, 'id'>>;
  schedulerById?: SubscriptionResolver<Maybe<ResolversTypes['Scheduler']>, "schedulerById", ParentType, ContextType, RequireFields<SubscriptionschedulerByIdArgs, 'id'>>;
  segmentById?: SubscriptionResolver<Maybe<ResolversTypes['Segment']>, "segmentById", ParentType, ContextType, RequireFields<SubscriptionsegmentByIdArgs, 'id'>>;
  settingById?: SubscriptionResolver<Maybe<ResolversTypes['Setting']>, "settingById", ParentType, ContextType, RequireFields<SubscriptionsettingByIdArgs, 'id'>>;
  shipmentById?: SubscriptionResolver<Maybe<ResolversTypes['Shipment']>, "shipmentById", ParentType, ContextType, RequireFields<SubscriptionshipmentByIdArgs, 'id'>>;
  specialDiscountById?: SubscriptionResolver<Maybe<ResolversTypes['SpecialDiscount']>, "specialDiscountById", ParentType, ContextType, RequireFields<SubscriptionspecialDiscountByIdArgs, 'id'>>;
  stateById?: SubscriptionResolver<Maybe<ResolversTypes['State']>, "stateById", ParentType, ContextType, RequireFields<SubscriptionstateByIdArgs, 'id'>>;
  statisticById?: SubscriptionResolver<Maybe<ResolversTypes['Statistic']>, "statisticById", ParentType, ContextType, RequireFields<SubscriptionstatisticByIdArgs, 'id'>>;
  stockById?: SubscriptionResolver<Maybe<ResolversTypes['Stock']>, "stockById", ParentType, ContextType, RequireFields<SubscriptionstockByIdArgs, 'id'>>;
  surveyById?: SubscriptionResolver<Maybe<ResolversTypes['Survey']>, "surveyById", ParentType, ContextType, RequireFields<SubscriptionsurveyByIdArgs, 'id'>>;
  tagById?: SubscriptionResolver<Maybe<ResolversTypes['Tag']>, "tagById", ParentType, ContextType, RequireFields<SubscriptiontagByIdArgs, 'id'>>;
  targetById?: SubscriptionResolver<Maybe<ResolversTypes['Target']>, "targetById", ParentType, ContextType, RequireFields<SubscriptiontargetByIdArgs, 'id'>>;
  taxCategoryById?: SubscriptionResolver<Maybe<ResolversTypes['TaxCategory']>, "taxCategoryById", ParentType, ContextType, RequireFields<SubscriptiontaxCategoryByIdArgs, 'id'>>;
  taxRateById?: SubscriptionResolver<Maybe<ResolversTypes['TaxRate']>, "taxRateById", ParentType, ContextType, RequireFields<SubscriptiontaxRateByIdArgs, 'id'>>;
  taxRuleById?: SubscriptionResolver<Maybe<ResolversTypes['TaxRule']>, "taxRuleById", ParentType, ContextType, RequireFields<SubscriptiontaxRuleByIdArgs, 'id'>>;
  templateById?: SubscriptionResolver<Maybe<ResolversTypes['Template']>, "templateById", ParentType, ContextType, RequireFields<SubscriptiontemplateByIdArgs, 'id'>>;
  themeById?: SubscriptionResolver<Maybe<ResolversTypes['Theme']>, "themeById", ParentType, ContextType, RequireFields<SubscriptionthemeByIdArgs, 'id'>>;
  ticketingById?: SubscriptionResolver<Maybe<ResolversTypes['Ticketing']>, "ticketingById", ParentType, ContextType, RequireFields<SubscriptionticketingByIdArgs, 'id'>>;
  trainingById?: SubscriptionResolver<Maybe<ResolversTypes['Training']>, "trainingById", ParentType, ContextType, RequireFields<SubscriptiontrainingByIdArgs, 'id'>>;
  transactionById?: SubscriptionResolver<Maybe<ResolversTypes['Transaction']>, "transactionById", ParentType, ContextType, RequireFields<SubscriptiontransactionByIdArgs, 'id'>>;
  uploadFileById?: SubscriptionResolver<Maybe<ResolversTypes['UploadFile']>, "uploadFileById", ParentType, ContextType, RequireFields<SubscriptionuploadFileByIdArgs, 'id'>>;
  userById?: SubscriptionResolver<Maybe<ResolversTypes['User']>, "userById", ParentType, ContextType, RequireFields<SubscriptionuserByIdArgs, 'id'>>;
  vendorById?: SubscriptionResolver<Maybe<ResolversTypes['Vendor']>, "vendorById", ParentType, ContextType, RequireFields<SubscriptionvendorByIdArgs, 'id'>>;
  visitById?: SubscriptionResolver<Maybe<ResolversTypes['Visit']>, "visitById", ParentType, ContextType, RequireFields<SubscriptionvisitByIdArgs, 'id'>>;
  warehouseById?: SubscriptionResolver<Maybe<ResolversTypes['Warehouse']>, "warehouseById", ParentType, ContextType, RequireFields<SubscriptionwarehouseByIdArgs, 'id'>>;
  webhookById?: SubscriptionResolver<Maybe<ResolversTypes['Webhook']>, "webhookById", ParentType, ContextType, RequireFields<SubscriptionwebhookByIdArgs, 'id'>>;
  websiteById?: SubscriptionResolver<Maybe<ResolversTypes['Website']>, "websiteById", ParentType, ContextType, RequireFields<SubscriptionwebsiteByIdArgs, 'id'>>;
  wishlistById?: SubscriptionResolver<Maybe<ResolversTypes['Wishlist']>, "wishlistById", ParentType, ContextType, RequireFields<SubscriptionwishlistByIdArgs, 'id'>>;
  workspaceById?: SubscriptionResolver<Maybe<ResolversTypes['Workspace']>, "workspaceById", ParentType, ContextType, RequireFields<SubscriptionworkspaceByIdArgs, 'id'>>;
  zoneById?: SubscriptionResolver<Maybe<ResolversTypes['Zone']>, "zoneById", ParentType, ContextType, RequireFields<SubscriptionzoneByIdArgs, 'id'>>;
  account?: SubscriptionResolver<Maybe<ResolversTypes['Account']>, "account", ParentType, ContextType, RequireFields<SubscriptionaccountArgs, 'nodeId'>>;
  agreement?: SubscriptionResolver<Maybe<ResolversTypes['Agreement']>, "agreement", ParentType, ContextType, RequireFields<SubscriptionagreementArgs, 'nodeId'>>;
  analytic?: SubscriptionResolver<Maybe<ResolversTypes['Analytic']>, "analytic", ParentType, ContextType, RequireFields<SubscriptionanalyticArgs, 'nodeId'>>;
  apitoken?: SubscriptionResolver<Maybe<ResolversTypes['Apitoken']>, "apitoken", ParentType, ContextType, RequireFields<SubscriptionapitokenArgs, 'nodeId'>>;
  article?: SubscriptionResolver<Maybe<ResolversTypes['Article']>, "article", ParentType, ContextType, RequireFields<SubscriptionarticleArgs, 'nodeId'>>;
  attribute?: SubscriptionResolver<Maybe<ResolversTypes['Attribute']>, "attribute", ParentType, ContextType, RequireFields<SubscriptionattributeArgs, 'nodeId'>>;
  brand?: SubscriptionResolver<Maybe<ResolversTypes['Brand']>, "brand", ParentType, ContextType, RequireFields<SubscriptionbrandArgs, 'nodeId'>>;
  cartPriceRule?: SubscriptionResolver<Maybe<ResolversTypes['CartPriceRule']>, "cartPriceRule", ParentType, ContextType, RequireFields<SubscriptioncartPriceRuleArgs, 'nodeId'>>;
  case?: SubscriptionResolver<Maybe<ResolversTypes['Case']>, "case", ParentType, ContextType, RequireFields<SubscriptioncaseArgs, 'nodeId'>>;
  catalogPriceRule?: SubscriptionResolver<Maybe<ResolversTypes['CatalogPriceRule']>, "catalogPriceRule", ParentType, ContextType, RequireFields<SubscriptioncatalogPriceRuleArgs, 'nodeId'>>;
  category?: SubscriptionResolver<Maybe<ResolversTypes['Category']>, "category", ParentType, ContextType, RequireFields<SubscriptioncategoryArgs, 'nodeId'>>;
  channel?: SubscriptionResolver<Maybe<ResolversTypes['Channel']>, "channel", ParentType, ContextType, RequireFields<SubscriptionchannelArgs, 'nodeId'>>;
  checklist?: SubscriptionResolver<Maybe<ResolversTypes['Checklist']>, "checklist", ParentType, ContextType, RequireFields<SubscriptionchecklistArgs, 'nodeId'>>;
  city?: SubscriptionResolver<Maybe<ResolversTypes['City']>, "city", ParentType, ContextType, RequireFields<SubscriptioncityArgs, 'nodeId'>>;
  collection?: SubscriptionResolver<Maybe<ResolversTypes['Collection']>, "collection", ParentType, ContextType, RequireFields<SubscriptioncollectionArgs, 'nodeId'>>;
  comment?: SubscriptionResolver<Maybe<ResolversTypes['Comment']>, "comment", ParentType, ContextType, RequireFields<SubscriptioncommentArgs, 'nodeId'>>;
  contentType?: SubscriptionResolver<Maybe<ResolversTypes['ContentType']>, "contentType", ParentType, ContextType, RequireFields<SubscriptioncontentTypeArgs, 'nodeId'>>;
  contract?: SubscriptionResolver<Maybe<ResolversTypes['Contract']>, "contract", ParentType, ContextType, RequireFields<SubscriptioncontractArgs, 'nodeId'>>;
  country?: SubscriptionResolver<Maybe<ResolversTypes['Country']>, "country", ParentType, ContextType, RequireFields<SubscriptioncountryArgs, 'nodeId'>>;
  coupon?: SubscriptionResolver<Maybe<ResolversTypes['Coupon']>, "coupon", ParentType, ContextType, RequireFields<SubscriptioncouponArgs, 'nodeId'>>;
  creditMemo?: SubscriptionResolver<Maybe<ResolversTypes['CreditMemo']>, "creditMemo", ParentType, ContextType, RequireFields<SubscriptioncreditMemoArgs, 'nodeId'>>;
  currency?: SubscriptionResolver<Maybe<ResolversTypes['Currency']>, "currency", ParentType, ContextType, RequireFields<SubscriptioncurrencyArgs, 'nodeId'>>;
  currencyRate?: SubscriptionResolver<Maybe<ResolversTypes['CurrencyRate']>, "currencyRate", ParentType, ContextType, RequireFields<SubscriptioncurrencyRateArgs, 'nodeId'>>;
  currencySymbol?: SubscriptionResolver<Maybe<ResolversTypes['CurrencySymbol']>, "currencySymbol", ParentType, ContextType, RequireFields<SubscriptioncurrencySymbolArgs, 'nodeId'>>;
  customerGroup?: SubscriptionResolver<Maybe<ResolversTypes['CustomerGroup']>, "customerGroup", ParentType, ContextType, RequireFields<SubscriptioncustomerGroupArgs, 'nodeId'>>;
  customer?: SubscriptionResolver<Maybe<ResolversTypes['Customer']>, "customer", ParentType, ContextType, RequireFields<SubscriptioncustomerArgs, 'nodeId'>>;
  customization?: SubscriptionResolver<Maybe<ResolversTypes['Customization']>, "customization", ParentType, ContextType, RequireFields<SubscriptioncustomizationArgs, 'nodeId'>>;
  dashboard?: SubscriptionResolver<Maybe<ResolversTypes['Dashboard']>, "dashboard", ParentType, ContextType, RequireFields<SubscriptiondashboardArgs, 'nodeId'>>;
  deepdive?: SubscriptionResolver<Maybe<ResolversTypes['Deepdive']>, "deepdive", ParentType, ContextType, RequireFields<SubscriptiondeepdiveArgs, 'nodeId'>>;
  digiboard?: SubscriptionResolver<Maybe<ResolversTypes['Digiboard']>, "digiboard", ParentType, ContextType, RequireFields<SubscriptiondigiboardArgs, 'nodeId'>>;
  email?: SubscriptionResolver<Maybe<ResolversTypes['Email']>, "email", ParentType, ContextType, RequireFields<SubscriptionemailArgs, 'nodeId'>>;
  endofshift?: SubscriptionResolver<Maybe<ResolversTypes['Endofshift']>, "endofshift", ParentType, ContextType, RequireFields<SubscriptionendofshiftArgs, 'nodeId'>>;
  event?: SubscriptionResolver<Maybe<ResolversTypes['Event']>, "event", ParentType, ContextType, RequireFields<SubscriptioneventArgs, 'nodeId'>>;
  fullfillment?: SubscriptionResolver<Maybe<ResolversTypes['Fullfillment']>, "fullfillment", ParentType, ContextType, RequireFields<SubscriptionfullfillmentArgs, 'nodeId'>>;
  giftCertificate?: SubscriptionResolver<Maybe<ResolversTypes['GiftCertificate']>, "giftCertificate", ParentType, ContextType, RequireFields<SubscriptiongiftCertificateArgs, 'nodeId'>>;
  glossary?: SubscriptionResolver<Maybe<ResolversTypes['Glossary']>, "glossary", ParentType, ContextType, RequireFields<SubscriptionglossaryArgs, 'nodeId'>>;
  importm?: SubscriptionResolver<Maybe<ResolversTypes['Importm']>, "importm", ParentType, ContextType, RequireFields<SubscriptionimportmArgs, 'nodeId'>>;
  integration?: SubscriptionResolver<Maybe<ResolversTypes['Integration']>, "integration", ParentType, ContextType, RequireFields<SubscriptionintegrationArgs, 'nodeId'>>;
  internalization?: SubscriptionResolver<Maybe<ResolversTypes['Internalization']>, "internalization", ParentType, ContextType, RequireFields<SubscriptioninternalizationArgs, 'nodeId'>>;
  invitation?: SubscriptionResolver<Maybe<ResolversTypes['Invitation']>, "invitation", ParentType, ContextType, RequireFields<SubscriptioninvitationArgs, 'nodeId'>>;
  invoice?: SubscriptionResolver<Maybe<ResolversTypes['Invoice']>, "invoice", ParentType, ContextType, RequireFields<SubscriptioninvoiceArgs, 'nodeId'>>;
  lead?: SubscriptionResolver<Maybe<ResolversTypes['Lead']>, "lead", ParentType, ContextType, RequireFields<SubscriptionleadArgs, 'nodeId'>>;
  manufacturer?: SubscriptionResolver<Maybe<ResolversTypes['Manufacturer']>, "manufacturer", ParentType, ContextType, RequireFields<SubscriptionmanufacturerArgs, 'nodeId'>>;
  mediamanager?: SubscriptionResolver<Maybe<ResolversTypes['Mediamanager']>, "mediamanager", ParentType, ContextType, RequireFields<SubscriptionmediamanagerArgs, 'nodeId'>>;
  meeting?: SubscriptionResolver<Maybe<ResolversTypes['Meeting']>, "meeting", ParentType, ContextType, RequireFields<SubscriptionmeetingArgs, 'nodeId'>>;
  message?: SubscriptionResolver<Maybe<ResolversTypes['Message']>, "message", ParentType, ContextType, RequireFields<SubscriptionmessageArgs, 'nodeId'>>;
  newsletter?: SubscriptionResolver<Maybe<ResolversTypes['Newsletter']>, "newsletter", ParentType, ContextType, RequireFields<SubscriptionnewsletterArgs, 'nodeId'>>;
  ooto?: SubscriptionResolver<Maybe<ResolversTypes['Ooto']>, "ooto", ParentType, ContextType, RequireFields<SubscriptionootoArgs, 'nodeId'>>;
  opportunity?: SubscriptionResolver<Maybe<ResolversTypes['Opportunity']>, "opportunity", ParentType, ContextType, RequireFields<SubscriptionopportunityArgs, 'nodeId'>>;
  order?: SubscriptionResolver<Maybe<ResolversTypes['Order']>, "order", ParentType, ContextType, RequireFields<SubscriptionorderArgs, 'nodeId'>>;
  page?: SubscriptionResolver<Maybe<ResolversTypes['Page']>, "page", ParentType, ContextType, RequireFields<SubscriptionpageArgs, 'nodeId'>>;
  partner?: SubscriptionResolver<Maybe<ResolversTypes['Partner']>, "partner", ParentType, ContextType, RequireFields<SubscriptionpartnerArgs, 'nodeId'>>;
  payment?: SubscriptionResolver<Maybe<ResolversTypes['Payment']>, "payment", ParentType, ContextType, RequireFields<SubscriptionpaymentArgs, 'nodeId'>>;
  permission?: SubscriptionResolver<Maybe<ResolversTypes['Permission']>, "permission", ParentType, ContextType, RequireFields<SubscriptionpermissionArgs, 'nodeId'>>;
  plugin?: SubscriptionResolver<Maybe<ResolversTypes['Plugin']>, "plugin", ParentType, ContextType, RequireFields<SubscriptionpluginArgs, 'nodeId'>>;
  poll?: SubscriptionResolver<Maybe<ResolversTypes['Poll']>, "poll", ParentType, ContextType, RequireFields<SubscriptionpollArgs, 'nodeId'>>;
  productType?: SubscriptionResolver<Maybe<ResolversTypes['ProductType']>, "productType", ParentType, ContextType, RequireFields<SubscriptionproductTypeArgs, 'nodeId'>>;
  product?: SubscriptionResolver<Maybe<ResolversTypes['Product']>, "product", ParentType, ContextType, RequireFields<SubscriptionproductArgs, 'nodeId'>>;
  project?: SubscriptionResolver<Maybe<ResolversTypes['Project']>, "project", ParentType, ContextType, RequireFields<SubscriptionprojectArgs, 'nodeId'>>;
  provider?: SubscriptionResolver<Maybe<ResolversTypes['Provider']>, "provider", ParentType, ContextType, RequireFields<SubscriptionproviderArgs, 'nodeId'>>;
  quote?: SubscriptionResolver<Maybe<ResolversTypes['Quote']>, "quote", ParentType, ContextType, RequireFields<SubscriptionquoteArgs, 'nodeId'>>;
  rating?: SubscriptionResolver<Maybe<ResolversTypes['Rating']>, "rating", ParentType, ContextType, RequireFields<SubscriptionratingArgs, 'nodeId'>>;
  report?: SubscriptionResolver<Maybe<ResolversTypes['Report']>, "report", ParentType, ContextType, RequireFields<SubscriptionreportArgs, 'nodeId'>>;
  return?: SubscriptionResolver<Maybe<ResolversTypes['Return']>, "return", ParentType, ContextType, RequireFields<SubscriptionreturnArgs, 'nodeId'>>;
  review?: SubscriptionResolver<Maybe<ResolversTypes['Review']>, "review", ParentType, ContextType, RequireFields<SubscriptionreviewArgs, 'nodeId'>>;
  reward?: SubscriptionResolver<Maybe<ResolversTypes['Reward']>, "reward", ParentType, ContextType, RequireFields<SubscriptionrewardArgs, 'nodeId'>>;
  role?: SubscriptionResolver<Maybe<ResolversTypes['Role']>, "role", ParentType, ContextType, RequireFields<SubscriptionroleArgs, 'nodeId'>>;
  scheduler?: SubscriptionResolver<Maybe<ResolversTypes['Scheduler']>, "scheduler", ParentType, ContextType, RequireFields<SubscriptionschedulerArgs, 'nodeId'>>;
  segment?: SubscriptionResolver<Maybe<ResolversTypes['Segment']>, "segment", ParentType, ContextType, RequireFields<SubscriptionsegmentArgs, 'nodeId'>>;
  setting?: SubscriptionResolver<Maybe<ResolversTypes['Setting']>, "setting", ParentType, ContextType, RequireFields<SubscriptionsettingArgs, 'nodeId'>>;
  shipment?: SubscriptionResolver<Maybe<ResolversTypes['Shipment']>, "shipment", ParentType, ContextType, RequireFields<SubscriptionshipmentArgs, 'nodeId'>>;
  specialDiscount?: SubscriptionResolver<Maybe<ResolversTypes['SpecialDiscount']>, "specialDiscount", ParentType, ContextType, RequireFields<SubscriptionspecialDiscountArgs, 'nodeId'>>;
  state?: SubscriptionResolver<Maybe<ResolversTypes['State']>, "state", ParentType, ContextType, RequireFields<SubscriptionstateArgs, 'nodeId'>>;
  statistic?: SubscriptionResolver<Maybe<ResolversTypes['Statistic']>, "statistic", ParentType, ContextType, RequireFields<SubscriptionstatisticArgs, 'nodeId'>>;
  stock?: SubscriptionResolver<Maybe<ResolversTypes['Stock']>, "stock", ParentType, ContextType, RequireFields<SubscriptionstockArgs, 'nodeId'>>;
  survey?: SubscriptionResolver<Maybe<ResolversTypes['Survey']>, "survey", ParentType, ContextType, RequireFields<SubscriptionsurveyArgs, 'nodeId'>>;
  tag?: SubscriptionResolver<Maybe<ResolversTypes['Tag']>, "tag", ParentType, ContextType, RequireFields<SubscriptiontagArgs, 'nodeId'>>;
  target?: SubscriptionResolver<Maybe<ResolversTypes['Target']>, "target", ParentType, ContextType, RequireFields<SubscriptiontargetArgs, 'nodeId'>>;
  taxCategory?: SubscriptionResolver<Maybe<ResolversTypes['TaxCategory']>, "taxCategory", ParentType, ContextType, RequireFields<SubscriptiontaxCategoryArgs, 'nodeId'>>;
  taxRate?: SubscriptionResolver<Maybe<ResolversTypes['TaxRate']>, "taxRate", ParentType, ContextType, RequireFields<SubscriptiontaxRateArgs, 'nodeId'>>;
  taxRule?: SubscriptionResolver<Maybe<ResolversTypes['TaxRule']>, "taxRule", ParentType, ContextType, RequireFields<SubscriptiontaxRuleArgs, 'nodeId'>>;
  template?: SubscriptionResolver<Maybe<ResolversTypes['Template']>, "template", ParentType, ContextType, RequireFields<SubscriptiontemplateArgs, 'nodeId'>>;
  theme?: SubscriptionResolver<Maybe<ResolversTypes['Theme']>, "theme", ParentType, ContextType, RequireFields<SubscriptionthemeArgs, 'nodeId'>>;
  ticketing?: SubscriptionResolver<Maybe<ResolversTypes['Ticketing']>, "ticketing", ParentType, ContextType, RequireFields<SubscriptionticketingArgs, 'nodeId'>>;
  training?: SubscriptionResolver<Maybe<ResolversTypes['Training']>, "training", ParentType, ContextType, RequireFields<SubscriptiontrainingArgs, 'nodeId'>>;
  transaction?: SubscriptionResolver<Maybe<ResolversTypes['Transaction']>, "transaction", ParentType, ContextType, RequireFields<SubscriptiontransactionArgs, 'nodeId'>>;
  uploadFile?: SubscriptionResolver<Maybe<ResolversTypes['UploadFile']>, "uploadFile", ParentType, ContextType, RequireFields<SubscriptionuploadFileArgs, 'nodeId'>>;
  user?: SubscriptionResolver<Maybe<ResolversTypes['User']>, "user", ParentType, ContextType, RequireFields<SubscriptionuserArgs, 'nodeId'>>;
  vendor?: SubscriptionResolver<Maybe<ResolversTypes['Vendor']>, "vendor", ParentType, ContextType, RequireFields<SubscriptionvendorArgs, 'nodeId'>>;
  visit?: SubscriptionResolver<Maybe<ResolversTypes['Visit']>, "visit", ParentType, ContextType, RequireFields<SubscriptionvisitArgs, 'nodeId'>>;
  warehouse?: SubscriptionResolver<Maybe<ResolversTypes['Warehouse']>, "warehouse", ParentType, ContextType, RequireFields<SubscriptionwarehouseArgs, 'nodeId'>>;
  webhook?: SubscriptionResolver<Maybe<ResolversTypes['Webhook']>, "webhook", ParentType, ContextType, RequireFields<SubscriptionwebhookArgs, 'nodeId'>>;
  website?: SubscriptionResolver<Maybe<ResolversTypes['Website']>, "website", ParentType, ContextType, RequireFields<SubscriptionwebsiteArgs, 'nodeId'>>;
  wishlist?: SubscriptionResolver<Maybe<ResolversTypes['Wishlist']>, "wishlist", ParentType, ContextType, RequireFields<SubscriptionwishlistArgs, 'nodeId'>>;
  workspace?: SubscriptionResolver<Maybe<ResolversTypes['Workspace']>, "workspace", ParentType, ContextType, RequireFields<SubscriptionworkspaceArgs, 'nodeId'>>;
  zone?: SubscriptionResolver<Maybe<ResolversTypes['Zone']>, "zone", ParentType, ContextType, RequireFields<SubscriptionzoneArgs, 'nodeId'>>;
}>;

export type Resolvers<ContextType = MeshContext> = ResolversObject<{
  Query?: QueryResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  AccountsConnection?: AccountsConnectionResolvers<ContextType>;
  Account?: AccountResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  Datetime?: GraphQLScalarType;
  AccountsEdge?: AccountsEdgeResolvers<ContextType>;
  Cursor?: GraphQLScalarType;
  PageInfo?: PageInfoResolvers<ContextType>;
  AccountsOrderBy?: AccountsOrderByResolvers;
  AgreementsConnection?: AgreementsConnectionResolvers<ContextType>;
  Agreement?: AgreementResolvers<ContextType>;
  AgreementsEdge?: AgreementsEdgeResolvers<ContextType>;
  AgreementsOrderBy?: AgreementsOrderByResolvers;
  AnalyticsConnection?: AnalyticsConnectionResolvers<ContextType>;
  Analytic?: AnalyticResolvers<ContextType>;
  AnalyticsEdge?: AnalyticsEdgeResolvers<ContextType>;
  AnalyticsOrderBy?: AnalyticsOrderByResolvers;
  ApitokensConnection?: ApitokensConnectionResolvers<ContextType>;
  Apitoken?: ApitokenResolvers<ContextType>;
  ApitokensEdge?: ApitokensEdgeResolvers<ContextType>;
  ApitokensOrderBy?: ApitokensOrderByResolvers;
  ArticlesConnection?: ArticlesConnectionResolvers<ContextType>;
  Article?: ArticleResolvers<ContextType>;
  ArticlesEdge?: ArticlesEdgeResolvers<ContextType>;
  ArticlesOrderBy?: ArticlesOrderByResolvers;
  AttributesConnection?: AttributesConnectionResolvers<ContextType>;
  Attribute?: AttributeResolvers<ContextType>;
  AttributesEdge?: AttributesEdgeResolvers<ContextType>;
  AttributesOrderBy?: AttributesOrderByResolvers;
  BrandsConnection?: BrandsConnectionResolvers<ContextType>;
  Brand?: BrandResolvers<ContextType>;
  BrandsEdge?: BrandsEdgeResolvers<ContextType>;
  BrandsOrderBy?: BrandsOrderByResolvers;
  CartPriceRulesConnection?: CartPriceRulesConnectionResolvers<ContextType>;
  CartPriceRule?: CartPriceRuleResolvers<ContextType>;
  Date?: GraphQLScalarType;
  BigFloat?: GraphQLScalarType;
  CartPriceRulesEdge?: CartPriceRulesEdgeResolvers<ContextType>;
  CartPriceRulesOrderBy?: CartPriceRulesOrderByResolvers;
  CasesConnection?: CasesConnectionResolvers<ContextType>;
  Case?: CaseResolvers<ContextType>;
  CasesEdge?: CasesEdgeResolvers<ContextType>;
  CasesOrderBy?: CasesOrderByResolvers;
  CatalogPriceRulesConnection?: CatalogPriceRulesConnectionResolvers<ContextType>;
  CatalogPriceRule?: CatalogPriceRuleResolvers<ContextType>;
  CatalogPriceRulesEdge?: CatalogPriceRulesEdgeResolvers<ContextType>;
  CatalogPriceRulesOrderBy?: CatalogPriceRulesOrderByResolvers;
  CategoriesConnection?: CategoriesConnectionResolvers<ContextType>;
  Category?: CategoryResolvers<ContextType>;
  CategoriesEdge?: CategoriesEdgeResolvers<ContextType>;
  CategoriesOrderBy?: CategoriesOrderByResolvers;
  ChannelsConnection?: ChannelsConnectionResolvers<ContextType>;
  Channel?: ChannelResolvers<ContextType>;
  ChannelsEdge?: ChannelsEdgeResolvers<ContextType>;
  ChannelsOrderBy?: ChannelsOrderByResolvers;
  ChecklistsConnection?: ChecklistsConnectionResolvers<ContextType>;
  Checklist?: ChecklistResolvers<ContextType>;
  ChecklistsEdge?: ChecklistsEdgeResolvers<ContextType>;
  ChecklistsOrderBy?: ChecklistsOrderByResolvers;
  CitiesConnection?: CitiesConnectionResolvers<ContextType>;
  City?: CityResolvers<ContextType>;
  CitiesEdge?: CitiesEdgeResolvers<ContextType>;
  CitiesOrderBy?: CitiesOrderByResolvers;
  CollectionsConnection?: CollectionsConnectionResolvers<ContextType>;
  Collection?: CollectionResolvers<ContextType>;
  CollectionsEdge?: CollectionsEdgeResolvers<ContextType>;
  CollectionsOrderBy?: CollectionsOrderByResolvers;
  CommentsConnection?: CommentsConnectionResolvers<ContextType>;
  Comment?: CommentResolvers<ContextType>;
  CommentsEdge?: CommentsEdgeResolvers<ContextType>;
  CommentsOrderBy?: CommentsOrderByResolvers;
  ContentTypesConnection?: ContentTypesConnectionResolvers<ContextType>;
  ContentType?: ContentTypeResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  Time?: GraphQLScalarType;
  ContentTypesEdge?: ContentTypesEdgeResolvers<ContextType>;
  ContentTypesOrderBy?: ContentTypesOrderByResolvers;
  ContractsConnection?: ContractsConnectionResolvers<ContextType>;
  Contract?: ContractResolvers<ContextType>;
  ContractsEdge?: ContractsEdgeResolvers<ContextType>;
  ContractsOrderBy?: ContractsOrderByResolvers;
  CountriesConnection?: CountriesConnectionResolvers<ContextType>;
  Country?: CountryResolvers<ContextType>;
  CountriesEdge?: CountriesEdgeResolvers<ContextType>;
  CountriesOrderBy?: CountriesOrderByResolvers;
  CouponsConnection?: CouponsConnectionResolvers<ContextType>;
  Coupon?: CouponResolvers<ContextType>;
  CouponsEdge?: CouponsEdgeResolvers<ContextType>;
  CouponsOrderBy?: CouponsOrderByResolvers;
  CreditMemosConnection?: CreditMemosConnectionResolvers<ContextType>;
  CreditMemo?: CreditMemoResolvers<ContextType>;
  CreditMemosEdge?: CreditMemosEdgeResolvers<ContextType>;
  CreditMemosOrderBy?: CreditMemosOrderByResolvers;
  CurrenciesConnection?: CurrenciesConnectionResolvers<ContextType>;
  Currency?: CurrencyResolvers<ContextType>;
  CurrenciesEdge?: CurrenciesEdgeResolvers<ContextType>;
  CurrenciesOrderBy?: CurrenciesOrderByResolvers;
  CurrencyRatesConnection?: CurrencyRatesConnectionResolvers<ContextType>;
  CurrencyRate?: CurrencyRateResolvers<ContextType>;
  CurrencyRatesEdge?: CurrencyRatesEdgeResolvers<ContextType>;
  CurrencyRatesOrderBy?: CurrencyRatesOrderByResolvers;
  CurrencySymbolsConnection?: CurrencySymbolsConnectionResolvers<ContextType>;
  CurrencySymbol?: CurrencySymbolResolvers<ContextType>;
  CurrencySymbolsEdge?: CurrencySymbolsEdgeResolvers<ContextType>;
  CurrencySymbolsOrderBy?: CurrencySymbolsOrderByResolvers;
  CustomerGroupsConnection?: CustomerGroupsConnectionResolvers<ContextType>;
  CustomerGroup?: CustomerGroupResolvers<ContextType>;
  CustomerGroupsEdge?: CustomerGroupsEdgeResolvers<ContextType>;
  CustomerGroupsOrderBy?: CustomerGroupsOrderByResolvers;
  CustomersConnection?: CustomersConnectionResolvers<ContextType>;
  Customer?: CustomerResolvers<ContextType>;
  CustomersEdge?: CustomersEdgeResolvers<ContextType>;
  CustomersOrderBy?: CustomersOrderByResolvers;
  CustomizationsConnection?: CustomizationsConnectionResolvers<ContextType>;
  Customization?: CustomizationResolvers<ContextType>;
  CustomizationsEdge?: CustomizationsEdgeResolvers<ContextType>;
  CustomizationsOrderBy?: CustomizationsOrderByResolvers;
  DashboardsConnection?: DashboardsConnectionResolvers<ContextType>;
  Dashboard?: DashboardResolvers<ContextType>;
  DashboardsEdge?: DashboardsEdgeResolvers<ContextType>;
  DashboardsOrderBy?: DashboardsOrderByResolvers;
  DeepdivesConnection?: DeepdivesConnectionResolvers<ContextType>;
  Deepdive?: DeepdiveResolvers<ContextType>;
  DeepdivesEdge?: DeepdivesEdgeResolvers<ContextType>;
  DeepdivesOrderBy?: DeepdivesOrderByResolvers;
  DigiboardsConnection?: DigiboardsConnectionResolvers<ContextType>;
  Digiboard?: DigiboardResolvers<ContextType>;
  DigiboardsEdge?: DigiboardsEdgeResolvers<ContextType>;
  DigiboardsOrderBy?: DigiboardsOrderByResolvers;
  EmailsConnection?: EmailsConnectionResolvers<ContextType>;
  Email?: EmailResolvers<ContextType>;
  EmailsEdge?: EmailsEdgeResolvers<ContextType>;
  EmailsOrderBy?: EmailsOrderByResolvers;
  EndofshiftsConnection?: EndofshiftsConnectionResolvers<ContextType>;
  Endofshift?: EndofshiftResolvers<ContextType>;
  EndofshiftsEdge?: EndofshiftsEdgeResolvers<ContextType>;
  EndofshiftsOrderBy?: EndofshiftsOrderByResolvers;
  EventsConnection?: EventsConnectionResolvers<ContextType>;
  Event?: EventResolvers<ContextType>;
  EventsEdge?: EventsEdgeResolvers<ContextType>;
  EventsOrderBy?: EventsOrderByResolvers;
  FullfillmentsConnection?: FullfillmentsConnectionResolvers<ContextType>;
  Fullfillment?: FullfillmentResolvers<ContextType>;
  FullfillmentsEdge?: FullfillmentsEdgeResolvers<ContextType>;
  FullfillmentsOrderBy?: FullfillmentsOrderByResolvers;
  GiftCertificatesConnection?: GiftCertificatesConnectionResolvers<ContextType>;
  GiftCertificate?: GiftCertificateResolvers<ContextType>;
  GiftCertificatesEdge?: GiftCertificatesEdgeResolvers<ContextType>;
  GiftCertificatesOrderBy?: GiftCertificatesOrderByResolvers;
  GlossariesConnection?: GlossariesConnectionResolvers<ContextType>;
  Glossary?: GlossaryResolvers<ContextType>;
  GlossariesEdge?: GlossariesEdgeResolvers<ContextType>;
  GlossariesOrderBy?: GlossariesOrderByResolvers;
  ImportmsConnection?: ImportmsConnectionResolvers<ContextType>;
  Importm?: ImportmResolvers<ContextType>;
  ImportmsEdge?: ImportmsEdgeResolvers<ContextType>;
  ImportmsOrderBy?: ImportmsOrderByResolvers;
  IntegrationsConnection?: IntegrationsConnectionResolvers<ContextType>;
  Integration?: IntegrationResolvers<ContextType>;
  IntegrationsEdge?: IntegrationsEdgeResolvers<ContextType>;
  IntegrationsOrderBy?: IntegrationsOrderByResolvers;
  InternalizationsConnection?: InternalizationsConnectionResolvers<ContextType>;
  Internalization?: InternalizationResolvers<ContextType>;
  InternalizationsEdge?: InternalizationsEdgeResolvers<ContextType>;
  InternalizationsOrderBy?: InternalizationsOrderByResolvers;
  InvitationsConnection?: InvitationsConnectionResolvers<ContextType>;
  Invitation?: InvitationResolvers<ContextType>;
  InvitationsEdge?: InvitationsEdgeResolvers<ContextType>;
  InvitationsOrderBy?: InvitationsOrderByResolvers;
  InvoicesConnection?: InvoicesConnectionResolvers<ContextType>;
  Invoice?: InvoiceResolvers<ContextType>;
  InvoicesEdge?: InvoicesEdgeResolvers<ContextType>;
  InvoicesOrderBy?: InvoicesOrderByResolvers;
  LeadsConnection?: LeadsConnectionResolvers<ContextType>;
  Lead?: LeadResolvers<ContextType>;
  LeadsEdge?: LeadsEdgeResolvers<ContextType>;
  LeadsOrderBy?: LeadsOrderByResolvers;
  ManufacturersConnection?: ManufacturersConnectionResolvers<ContextType>;
  Manufacturer?: ManufacturerResolvers<ContextType>;
  ManufacturersEdge?: ManufacturersEdgeResolvers<ContextType>;
  ManufacturersOrderBy?: ManufacturersOrderByResolvers;
  MediamanagersConnection?: MediamanagersConnectionResolvers<ContextType>;
  Mediamanager?: MediamanagerResolvers<ContextType>;
  MediamanagersEdge?: MediamanagersEdgeResolvers<ContextType>;
  MediamanagersOrderBy?: MediamanagersOrderByResolvers;
  MeetingsConnection?: MeetingsConnectionResolvers<ContextType>;
  Meeting?: MeetingResolvers<ContextType>;
  MeetingsEdge?: MeetingsEdgeResolvers<ContextType>;
  MeetingsOrderBy?: MeetingsOrderByResolvers;
  MessagesConnection?: MessagesConnectionResolvers<ContextType>;
  Message?: MessageResolvers<ContextType>;
  MessagesEdge?: MessagesEdgeResolvers<ContextType>;
  MessagesOrderBy?: MessagesOrderByResolvers;
  NewslettersConnection?: NewslettersConnectionResolvers<ContextType>;
  Newsletter?: NewsletterResolvers<ContextType>;
  NewslettersEdge?: NewslettersEdgeResolvers<ContextType>;
  NewslettersOrderBy?: NewslettersOrderByResolvers;
  OotosConnection?: OotosConnectionResolvers<ContextType>;
  Ooto?: OotoResolvers<ContextType>;
  OotosEdge?: OotosEdgeResolvers<ContextType>;
  OotosOrderBy?: OotosOrderByResolvers;
  OpportunitiesConnection?: OpportunitiesConnectionResolvers<ContextType>;
  Opportunity?: OpportunityResolvers<ContextType>;
  OpportunitiesEdge?: OpportunitiesEdgeResolvers<ContextType>;
  OpportunitiesOrderBy?: OpportunitiesOrderByResolvers;
  OrdersConnection?: OrdersConnectionResolvers<ContextType>;
  Order?: OrderResolvers<ContextType>;
  OrdersEdge?: OrdersEdgeResolvers<ContextType>;
  OrdersOrderBy?: OrdersOrderByResolvers;
  PagesConnection?: PagesConnectionResolvers<ContextType>;
  Page?: PageResolvers<ContextType>;
  PagesEdge?: PagesEdgeResolvers<ContextType>;
  PagesOrderBy?: PagesOrderByResolvers;
  PartnersConnection?: PartnersConnectionResolvers<ContextType>;
  Partner?: PartnerResolvers<ContextType>;
  PartnersEdge?: PartnersEdgeResolvers<ContextType>;
  PartnersOrderBy?: PartnersOrderByResolvers;
  PaymentsConnection?: PaymentsConnectionResolvers<ContextType>;
  Payment?: PaymentResolvers<ContextType>;
  PaymentsEdge?: PaymentsEdgeResolvers<ContextType>;
  PaymentsOrderBy?: PaymentsOrderByResolvers;
  PermissionsConnection?: PermissionsConnectionResolvers<ContextType>;
  Permission?: PermissionResolvers<ContextType>;
  PermissionsEdge?: PermissionsEdgeResolvers<ContextType>;
  PermissionsOrderBy?: PermissionsOrderByResolvers;
  PluginsConnection?: PluginsConnectionResolvers<ContextType>;
  Plugin?: PluginResolvers<ContextType>;
  PluginsEdge?: PluginsEdgeResolvers<ContextType>;
  PluginsOrderBy?: PluginsOrderByResolvers;
  PollsConnection?: PollsConnectionResolvers<ContextType>;
  Poll?: PollResolvers<ContextType>;
  PollsEdge?: PollsEdgeResolvers<ContextType>;
  PollsOrderBy?: PollsOrderByResolvers;
  ProductTypesConnection?: ProductTypesConnectionResolvers<ContextType>;
  ProductType?: ProductTypeResolvers<ContextType>;
  ProductTypesEdge?: ProductTypesEdgeResolvers<ContextType>;
  ProductTypesOrderBy?: ProductTypesOrderByResolvers;
  ProductsConnection?: ProductsConnectionResolvers<ContextType>;
  Product?: ProductResolvers<ContextType>;
  ProductsEdge?: ProductsEdgeResolvers<ContextType>;
  ProductsOrderBy?: ProductsOrderByResolvers;
  ProjectsConnection?: ProjectsConnectionResolvers<ContextType>;
  Project?: ProjectResolvers<ContextType>;
  ProjectsEdge?: ProjectsEdgeResolvers<ContextType>;
  ProjectsOrderBy?: ProjectsOrderByResolvers;
  ProvidersConnection?: ProvidersConnectionResolvers<ContextType>;
  Provider?: ProviderResolvers<ContextType>;
  ProvidersEdge?: ProvidersEdgeResolvers<ContextType>;
  ProvidersOrderBy?: ProvidersOrderByResolvers;
  QuotesConnection?: QuotesConnectionResolvers<ContextType>;
  Quote?: QuoteResolvers<ContextType>;
  QuotesEdge?: QuotesEdgeResolvers<ContextType>;
  QuotesOrderBy?: QuotesOrderByResolvers;
  RatingsConnection?: RatingsConnectionResolvers<ContextType>;
  Rating?: RatingResolvers<ContextType>;
  RatingsEdge?: RatingsEdgeResolvers<ContextType>;
  RatingsOrderBy?: RatingsOrderByResolvers;
  ReportsConnection?: ReportsConnectionResolvers<ContextType>;
  Report?: ReportResolvers<ContextType>;
  ReportsEdge?: ReportsEdgeResolvers<ContextType>;
  ReportsOrderBy?: ReportsOrderByResolvers;
  ReturnsConnection?: ReturnsConnectionResolvers<ContextType>;
  Return?: ReturnResolvers<ContextType>;
  ReturnsEdge?: ReturnsEdgeResolvers<ContextType>;
  ReturnsOrderBy?: ReturnsOrderByResolvers;
  ReviewsConnection?: ReviewsConnectionResolvers<ContextType>;
  Review?: ReviewResolvers<ContextType>;
  ReviewsEdge?: ReviewsEdgeResolvers<ContextType>;
  ReviewsOrderBy?: ReviewsOrderByResolvers;
  RewardsConnection?: RewardsConnectionResolvers<ContextType>;
  Reward?: RewardResolvers<ContextType>;
  RewardsEdge?: RewardsEdgeResolvers<ContextType>;
  RewardsOrderBy?: RewardsOrderByResolvers;
  RolesConnection?: RolesConnectionResolvers<ContextType>;
  Role?: RoleResolvers<ContextType>;
  RolesEdge?: RolesEdgeResolvers<ContextType>;
  RolesOrderBy?: RolesOrderByResolvers;
  SchedulersConnection?: SchedulersConnectionResolvers<ContextType>;
  Scheduler?: SchedulerResolvers<ContextType>;
  SchedulersEdge?: SchedulersEdgeResolvers<ContextType>;
  SchedulersOrderBy?: SchedulersOrderByResolvers;
  SegmentsConnection?: SegmentsConnectionResolvers<ContextType>;
  Segment?: SegmentResolvers<ContextType>;
  SegmentsEdge?: SegmentsEdgeResolvers<ContextType>;
  SegmentsOrderBy?: SegmentsOrderByResolvers;
  SettingsConnection?: SettingsConnectionResolvers<ContextType>;
  Setting?: SettingResolvers<ContextType>;
  SettingsEdge?: SettingsEdgeResolvers<ContextType>;
  SettingsOrderBy?: SettingsOrderByResolvers;
  ShipmentsConnection?: ShipmentsConnectionResolvers<ContextType>;
  Shipment?: ShipmentResolvers<ContextType>;
  ShipmentsEdge?: ShipmentsEdgeResolvers<ContextType>;
  ShipmentsOrderBy?: ShipmentsOrderByResolvers;
  SpecialDiscountsConnection?: SpecialDiscountsConnectionResolvers<ContextType>;
  SpecialDiscount?: SpecialDiscountResolvers<ContextType>;
  SpecialDiscountsEdge?: SpecialDiscountsEdgeResolvers<ContextType>;
  SpecialDiscountsOrderBy?: SpecialDiscountsOrderByResolvers;
  StatesConnection?: StatesConnectionResolvers<ContextType>;
  State?: StateResolvers<ContextType>;
  StatesEdge?: StatesEdgeResolvers<ContextType>;
  StatesOrderBy?: StatesOrderByResolvers;
  StatisticsConnection?: StatisticsConnectionResolvers<ContextType>;
  Statistic?: StatisticResolvers<ContextType>;
  StatisticsEdge?: StatisticsEdgeResolvers<ContextType>;
  StatisticsOrderBy?: StatisticsOrderByResolvers;
  StocksConnection?: StocksConnectionResolvers<ContextType>;
  Stock?: StockResolvers<ContextType>;
  StocksEdge?: StocksEdgeResolvers<ContextType>;
  StocksOrderBy?: StocksOrderByResolvers;
  SurveysConnection?: SurveysConnectionResolvers<ContextType>;
  Survey?: SurveyResolvers<ContextType>;
  SurveysEdge?: SurveysEdgeResolvers<ContextType>;
  SurveysOrderBy?: SurveysOrderByResolvers;
  TagsConnection?: TagsConnectionResolvers<ContextType>;
  Tag?: TagResolvers<ContextType>;
  TagsEdge?: TagsEdgeResolvers<ContextType>;
  TagsOrderBy?: TagsOrderByResolvers;
  TargetsConnection?: TargetsConnectionResolvers<ContextType>;
  Target?: TargetResolvers<ContextType>;
  TargetsEdge?: TargetsEdgeResolvers<ContextType>;
  TargetsOrderBy?: TargetsOrderByResolvers;
  TaxCategoriesConnection?: TaxCategoriesConnectionResolvers<ContextType>;
  TaxCategory?: TaxCategoryResolvers<ContextType>;
  TaxCategoriesEdge?: TaxCategoriesEdgeResolvers<ContextType>;
  TaxCategoriesOrderBy?: TaxCategoriesOrderByResolvers;
  TaxRatesConnection?: TaxRatesConnectionResolvers<ContextType>;
  TaxRate?: TaxRateResolvers<ContextType>;
  TaxRatesEdge?: TaxRatesEdgeResolvers<ContextType>;
  TaxRatesOrderBy?: TaxRatesOrderByResolvers;
  TaxRulesConnection?: TaxRulesConnectionResolvers<ContextType>;
  TaxRule?: TaxRuleResolvers<ContextType>;
  TaxRulesEdge?: TaxRulesEdgeResolvers<ContextType>;
  TaxRulesOrderBy?: TaxRulesOrderByResolvers;
  TemplatesConnection?: TemplatesConnectionResolvers<ContextType>;
  Template?: TemplateResolvers<ContextType>;
  TemplatesEdge?: TemplatesEdgeResolvers<ContextType>;
  TemplatesOrderBy?: TemplatesOrderByResolvers;
  ThemesConnection?: ThemesConnectionResolvers<ContextType>;
  Theme?: ThemeResolvers<ContextType>;
  ThemesEdge?: ThemesEdgeResolvers<ContextType>;
  ThemesOrderBy?: ThemesOrderByResolvers;
  TicketingsConnection?: TicketingsConnectionResolvers<ContextType>;
  Ticketing?: TicketingResolvers<ContextType>;
  TicketingsEdge?: TicketingsEdgeResolvers<ContextType>;
  TicketingsOrderBy?: TicketingsOrderByResolvers;
  TrainingsConnection?: TrainingsConnectionResolvers<ContextType>;
  Training?: TrainingResolvers<ContextType>;
  TrainingsEdge?: TrainingsEdgeResolvers<ContextType>;
  TrainingsOrderBy?: TrainingsOrderByResolvers;
  TransactionsConnection?: TransactionsConnectionResolvers<ContextType>;
  Transaction?: TransactionResolvers<ContextType>;
  TransactionsEdge?: TransactionsEdgeResolvers<ContextType>;
  TransactionsOrderBy?: TransactionsOrderByResolvers;
  UploadFilesConnection?: UploadFilesConnectionResolvers<ContextType>;
  UploadFile?: UploadFileResolvers<ContextType>;
  UploadFilesEdge?: UploadFilesEdgeResolvers<ContextType>;
  UploadFilesOrderBy?: UploadFilesOrderByResolvers;
  UsersConnection?: UsersConnectionResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UsersEdge?: UsersEdgeResolvers<ContextType>;
  UsersOrderBy?: UsersOrderByResolvers;
  VendorsConnection?: VendorsConnectionResolvers<ContextType>;
  Vendor?: VendorResolvers<ContextType>;
  VendorsEdge?: VendorsEdgeResolvers<ContextType>;
  VendorsOrderBy?: VendorsOrderByResolvers;
  VisitsConnection?: VisitsConnectionResolvers<ContextType>;
  Visit?: VisitResolvers<ContextType>;
  VisitsEdge?: VisitsEdgeResolvers<ContextType>;
  VisitsOrderBy?: VisitsOrderByResolvers;
  WarehousesConnection?: WarehousesConnectionResolvers<ContextType>;
  Warehouse?: WarehouseResolvers<ContextType>;
  WarehousesEdge?: WarehousesEdgeResolvers<ContextType>;
  WarehousesOrderBy?: WarehousesOrderByResolvers;
  WebhooksConnection?: WebhooksConnectionResolvers<ContextType>;
  Webhook?: WebhookResolvers<ContextType>;
  WebhooksEdge?: WebhooksEdgeResolvers<ContextType>;
  WebhooksOrderBy?: WebhooksOrderByResolvers;
  WebsitesConnection?: WebsitesConnectionResolvers<ContextType>;
  Website?: WebsiteResolvers<ContextType>;
  WebsitesEdge?: WebsitesEdgeResolvers<ContextType>;
  WebsitesOrderBy?: WebsitesOrderByResolvers;
  WishlistsConnection?: WishlistsConnectionResolvers<ContextType>;
  Wishlist?: WishlistResolvers<ContextType>;
  WishlistsEdge?: WishlistsEdgeResolvers<ContextType>;
  WishlistsOrderBy?: WishlistsOrderByResolvers;
  WorkspacesConnection?: WorkspacesConnectionResolvers<ContextType>;
  Workspace?: WorkspaceResolvers<ContextType>;
  WorkspacesEdge?: WorkspacesEdgeResolvers<ContextType>;
  WorkspacesOrderBy?: WorkspacesOrderByResolvers;
  ZonesConnection?: ZonesConnectionResolvers<ContextType>;
  Zone?: ZoneResolvers<ContextType>;
  ZonesEdge?: ZonesEdgeResolvers<ContextType>;
  ZonesOrderBy?: ZonesOrderByResolvers;
  Mutation?: MutationResolvers<ContextType>;
  CreateAccountPayload?: CreateAccountPayloadResolvers<ContextType>;
  CreateAgreementPayload?: CreateAgreementPayloadResolvers<ContextType>;
  CreateAnalyticPayload?: CreateAnalyticPayloadResolvers<ContextType>;
  CreateApitokenPayload?: CreateApitokenPayloadResolvers<ContextType>;
  CreateArticlePayload?: CreateArticlePayloadResolvers<ContextType>;
  CreateAttributePayload?: CreateAttributePayloadResolvers<ContextType>;
  CreateBrandPayload?: CreateBrandPayloadResolvers<ContextType>;
  CreateCartPriceRulePayload?: CreateCartPriceRulePayloadResolvers<ContextType>;
  CreateCasePayload?: CreateCasePayloadResolvers<ContextType>;
  CreateCatalogPriceRulePayload?: CreateCatalogPriceRulePayloadResolvers<ContextType>;
  CreateCategoryPayload?: CreateCategoryPayloadResolvers<ContextType>;
  CreateChannelPayload?: CreateChannelPayloadResolvers<ContextType>;
  CreateChecklistPayload?: CreateChecklistPayloadResolvers<ContextType>;
  CreateCityPayload?: CreateCityPayloadResolvers<ContextType>;
  CreateCollectionPayload?: CreateCollectionPayloadResolvers<ContextType>;
  CreateCommentPayload?: CreateCommentPayloadResolvers<ContextType>;
  CreateContentTypePayload?: CreateContentTypePayloadResolvers<ContextType>;
  CreateContractPayload?: CreateContractPayloadResolvers<ContextType>;
  CreateCountryPayload?: CreateCountryPayloadResolvers<ContextType>;
  CreateCouponPayload?: CreateCouponPayloadResolvers<ContextType>;
  CreateCreditMemoPayload?: CreateCreditMemoPayloadResolvers<ContextType>;
  CreateCurrencyPayload?: CreateCurrencyPayloadResolvers<ContextType>;
  CreateCurrencyRatePayload?: CreateCurrencyRatePayloadResolvers<ContextType>;
  CreateCurrencySymbolPayload?: CreateCurrencySymbolPayloadResolvers<ContextType>;
  CreateCustomerGroupPayload?: CreateCustomerGroupPayloadResolvers<ContextType>;
  CreateCustomerPayload?: CreateCustomerPayloadResolvers<ContextType>;
  CreateCustomizationPayload?: CreateCustomizationPayloadResolvers<ContextType>;
  CreateDashboardPayload?: CreateDashboardPayloadResolvers<ContextType>;
  CreateDeepdivePayload?: CreateDeepdivePayloadResolvers<ContextType>;
  CreateDigiboardPayload?: CreateDigiboardPayloadResolvers<ContextType>;
  CreateEmailPayload?: CreateEmailPayloadResolvers<ContextType>;
  CreateEndofshiftPayload?: CreateEndofshiftPayloadResolvers<ContextType>;
  CreateEventPayload?: CreateEventPayloadResolvers<ContextType>;
  CreateFullfillmentPayload?: CreateFullfillmentPayloadResolvers<ContextType>;
  CreateGiftCertificatePayload?: CreateGiftCertificatePayloadResolvers<ContextType>;
  CreateGlossaryPayload?: CreateGlossaryPayloadResolvers<ContextType>;
  CreateImportmPayload?: CreateImportmPayloadResolvers<ContextType>;
  CreateIntegrationPayload?: CreateIntegrationPayloadResolvers<ContextType>;
  CreateInternalizationPayload?: CreateInternalizationPayloadResolvers<ContextType>;
  CreateInvitationPayload?: CreateInvitationPayloadResolvers<ContextType>;
  CreateInvoicePayload?: CreateInvoicePayloadResolvers<ContextType>;
  CreateLeadPayload?: CreateLeadPayloadResolvers<ContextType>;
  CreateManufacturerPayload?: CreateManufacturerPayloadResolvers<ContextType>;
  CreateMediamanagerPayload?: CreateMediamanagerPayloadResolvers<ContextType>;
  CreateMeetingPayload?: CreateMeetingPayloadResolvers<ContextType>;
  CreateMessagePayload?: CreateMessagePayloadResolvers<ContextType>;
  CreateNewsletterPayload?: CreateNewsletterPayloadResolvers<ContextType>;
  CreateOotoPayload?: CreateOotoPayloadResolvers<ContextType>;
  CreateOpportunityPayload?: CreateOpportunityPayloadResolvers<ContextType>;
  CreateOrderPayload?: CreateOrderPayloadResolvers<ContextType>;
  CreatePagePayload?: CreatePagePayloadResolvers<ContextType>;
  CreatePartnerPayload?: CreatePartnerPayloadResolvers<ContextType>;
  CreatePaymentPayload?: CreatePaymentPayloadResolvers<ContextType>;
  CreatePermissionPayload?: CreatePermissionPayloadResolvers<ContextType>;
  CreatePluginPayload?: CreatePluginPayloadResolvers<ContextType>;
  CreatePollPayload?: CreatePollPayloadResolvers<ContextType>;
  CreateProductTypePayload?: CreateProductTypePayloadResolvers<ContextType>;
  CreateProductPayload?: CreateProductPayloadResolvers<ContextType>;
  CreateProjectPayload?: CreateProjectPayloadResolvers<ContextType>;
  CreateProviderPayload?: CreateProviderPayloadResolvers<ContextType>;
  CreateQuotePayload?: CreateQuotePayloadResolvers<ContextType>;
  CreateRatingPayload?: CreateRatingPayloadResolvers<ContextType>;
  CreateReportPayload?: CreateReportPayloadResolvers<ContextType>;
  CreateReturnPayload?: CreateReturnPayloadResolvers<ContextType>;
  CreateReviewPayload?: CreateReviewPayloadResolvers<ContextType>;
  CreateRewardPayload?: CreateRewardPayloadResolvers<ContextType>;
  CreateRolePayload?: CreateRolePayloadResolvers<ContextType>;
  CreateSchedulerPayload?: CreateSchedulerPayloadResolvers<ContextType>;
  CreateSegmentPayload?: CreateSegmentPayloadResolvers<ContextType>;
  CreateSettingPayload?: CreateSettingPayloadResolvers<ContextType>;
  CreateShipmentPayload?: CreateShipmentPayloadResolvers<ContextType>;
  CreateSpecialDiscountPayload?: CreateSpecialDiscountPayloadResolvers<ContextType>;
  CreateStatePayload?: CreateStatePayloadResolvers<ContextType>;
  CreateStatisticPayload?: CreateStatisticPayloadResolvers<ContextType>;
  CreateStockPayload?: CreateStockPayloadResolvers<ContextType>;
  CreateSurveyPayload?: CreateSurveyPayloadResolvers<ContextType>;
  CreateTagPayload?: CreateTagPayloadResolvers<ContextType>;
  CreateTargetPayload?: CreateTargetPayloadResolvers<ContextType>;
  CreateTaxCategoryPayload?: CreateTaxCategoryPayloadResolvers<ContextType>;
  CreateTaxRatePayload?: CreateTaxRatePayloadResolvers<ContextType>;
  CreateTaxRulePayload?: CreateTaxRulePayloadResolvers<ContextType>;
  CreateTemplatePayload?: CreateTemplatePayloadResolvers<ContextType>;
  CreateThemePayload?: CreateThemePayloadResolvers<ContextType>;
  CreateTicketingPayload?: CreateTicketingPayloadResolvers<ContextType>;
  CreateTrainingPayload?: CreateTrainingPayloadResolvers<ContextType>;
  CreateTransactionPayload?: CreateTransactionPayloadResolvers<ContextType>;
  CreateUploadFilePayload?: CreateUploadFilePayloadResolvers<ContextType>;
  CreateUserPayload?: CreateUserPayloadResolvers<ContextType>;
  CreateVendorPayload?: CreateVendorPayloadResolvers<ContextType>;
  CreateVisitPayload?: CreateVisitPayloadResolvers<ContextType>;
  CreateWarehousePayload?: CreateWarehousePayloadResolvers<ContextType>;
  CreateWebhookPayload?: CreateWebhookPayloadResolvers<ContextType>;
  CreateWebsitePayload?: CreateWebsitePayloadResolvers<ContextType>;
  CreateWishlistPayload?: CreateWishlistPayloadResolvers<ContextType>;
  CreateWorkspacePayload?: CreateWorkspacePayloadResolvers<ContextType>;
  CreateZonePayload?: CreateZonePayloadResolvers<ContextType>;
  UpdateAccountPayload?: UpdateAccountPayloadResolvers<ContextType>;
  UpdateAgreementPayload?: UpdateAgreementPayloadResolvers<ContextType>;
  UpdateAnalyticPayload?: UpdateAnalyticPayloadResolvers<ContextType>;
  UpdateApitokenPayload?: UpdateApitokenPayloadResolvers<ContextType>;
  UpdateArticlePayload?: UpdateArticlePayloadResolvers<ContextType>;
  UpdateAttributePayload?: UpdateAttributePayloadResolvers<ContextType>;
  UpdateBrandPayload?: UpdateBrandPayloadResolvers<ContextType>;
  UpdateCartPriceRulePayload?: UpdateCartPriceRulePayloadResolvers<ContextType>;
  UpdateCasePayload?: UpdateCasePayloadResolvers<ContextType>;
  UpdateCatalogPriceRulePayload?: UpdateCatalogPriceRulePayloadResolvers<ContextType>;
  UpdateCategoryPayload?: UpdateCategoryPayloadResolvers<ContextType>;
  UpdateChannelPayload?: UpdateChannelPayloadResolvers<ContextType>;
  UpdateChecklistPayload?: UpdateChecklistPayloadResolvers<ContextType>;
  UpdateCityPayload?: UpdateCityPayloadResolvers<ContextType>;
  UpdateCollectionPayload?: UpdateCollectionPayloadResolvers<ContextType>;
  UpdateCommentPayload?: UpdateCommentPayloadResolvers<ContextType>;
  UpdateContentTypePayload?: UpdateContentTypePayloadResolvers<ContextType>;
  UpdateContractPayload?: UpdateContractPayloadResolvers<ContextType>;
  UpdateCountryPayload?: UpdateCountryPayloadResolvers<ContextType>;
  UpdateCouponPayload?: UpdateCouponPayloadResolvers<ContextType>;
  UpdateCreditMemoPayload?: UpdateCreditMemoPayloadResolvers<ContextType>;
  UpdateCurrencyPayload?: UpdateCurrencyPayloadResolvers<ContextType>;
  UpdateCurrencyRatePayload?: UpdateCurrencyRatePayloadResolvers<ContextType>;
  UpdateCurrencySymbolPayload?: UpdateCurrencySymbolPayloadResolvers<ContextType>;
  UpdateCustomerGroupPayload?: UpdateCustomerGroupPayloadResolvers<ContextType>;
  UpdateCustomerPayload?: UpdateCustomerPayloadResolvers<ContextType>;
  UpdateCustomizationPayload?: UpdateCustomizationPayloadResolvers<ContextType>;
  UpdateDashboardPayload?: UpdateDashboardPayloadResolvers<ContextType>;
  UpdateDeepdivePayload?: UpdateDeepdivePayloadResolvers<ContextType>;
  UpdateDigiboardPayload?: UpdateDigiboardPayloadResolvers<ContextType>;
  UpdateEmailPayload?: UpdateEmailPayloadResolvers<ContextType>;
  UpdateEndofshiftPayload?: UpdateEndofshiftPayloadResolvers<ContextType>;
  UpdateEventPayload?: UpdateEventPayloadResolvers<ContextType>;
  UpdateFullfillmentPayload?: UpdateFullfillmentPayloadResolvers<ContextType>;
  UpdateGiftCertificatePayload?: UpdateGiftCertificatePayloadResolvers<ContextType>;
  UpdateGlossaryPayload?: UpdateGlossaryPayloadResolvers<ContextType>;
  UpdateImportmPayload?: UpdateImportmPayloadResolvers<ContextType>;
  UpdateIntegrationPayload?: UpdateIntegrationPayloadResolvers<ContextType>;
  UpdateInternalizationPayload?: UpdateInternalizationPayloadResolvers<ContextType>;
  UpdateInvitationPayload?: UpdateInvitationPayloadResolvers<ContextType>;
  UpdateInvoicePayload?: UpdateInvoicePayloadResolvers<ContextType>;
  UpdateLeadPayload?: UpdateLeadPayloadResolvers<ContextType>;
  UpdateManufacturerPayload?: UpdateManufacturerPayloadResolvers<ContextType>;
  UpdateMediamanagerPayload?: UpdateMediamanagerPayloadResolvers<ContextType>;
  UpdateMeetingPayload?: UpdateMeetingPayloadResolvers<ContextType>;
  UpdateMessagePayload?: UpdateMessagePayloadResolvers<ContextType>;
  UpdateNewsletterPayload?: UpdateNewsletterPayloadResolvers<ContextType>;
  UpdateOotoPayload?: UpdateOotoPayloadResolvers<ContextType>;
  UpdateOpportunityPayload?: UpdateOpportunityPayloadResolvers<ContextType>;
  UpdateOrderPayload?: UpdateOrderPayloadResolvers<ContextType>;
  UpdatePagePayload?: UpdatePagePayloadResolvers<ContextType>;
  UpdatePartnerPayload?: UpdatePartnerPayloadResolvers<ContextType>;
  UpdatePaymentPayload?: UpdatePaymentPayloadResolvers<ContextType>;
  UpdatePermissionPayload?: UpdatePermissionPayloadResolvers<ContextType>;
  UpdatePluginPayload?: UpdatePluginPayloadResolvers<ContextType>;
  UpdatePollPayload?: UpdatePollPayloadResolvers<ContextType>;
  UpdateProductTypePayload?: UpdateProductTypePayloadResolvers<ContextType>;
  UpdateProductPayload?: UpdateProductPayloadResolvers<ContextType>;
  UpdateProjectPayload?: UpdateProjectPayloadResolvers<ContextType>;
  UpdateProviderPayload?: UpdateProviderPayloadResolvers<ContextType>;
  UpdateQuotePayload?: UpdateQuotePayloadResolvers<ContextType>;
  UpdateRatingPayload?: UpdateRatingPayloadResolvers<ContextType>;
  UpdateReportPayload?: UpdateReportPayloadResolvers<ContextType>;
  UpdateReturnPayload?: UpdateReturnPayloadResolvers<ContextType>;
  UpdateReviewPayload?: UpdateReviewPayloadResolvers<ContextType>;
  UpdateRewardPayload?: UpdateRewardPayloadResolvers<ContextType>;
  UpdateRolePayload?: UpdateRolePayloadResolvers<ContextType>;
  UpdateSchedulerPayload?: UpdateSchedulerPayloadResolvers<ContextType>;
  UpdateSegmentPayload?: UpdateSegmentPayloadResolvers<ContextType>;
  UpdateSettingPayload?: UpdateSettingPayloadResolvers<ContextType>;
  UpdateShipmentPayload?: UpdateShipmentPayloadResolvers<ContextType>;
  UpdateSpecialDiscountPayload?: UpdateSpecialDiscountPayloadResolvers<ContextType>;
  UpdateStatePayload?: UpdateStatePayloadResolvers<ContextType>;
  UpdateStatisticPayload?: UpdateStatisticPayloadResolvers<ContextType>;
  UpdateStockPayload?: UpdateStockPayloadResolvers<ContextType>;
  UpdateSurveyPayload?: UpdateSurveyPayloadResolvers<ContextType>;
  UpdateTagPayload?: UpdateTagPayloadResolvers<ContextType>;
  UpdateTargetPayload?: UpdateTargetPayloadResolvers<ContextType>;
  UpdateTaxCategoryPayload?: UpdateTaxCategoryPayloadResolvers<ContextType>;
  UpdateTaxRatePayload?: UpdateTaxRatePayloadResolvers<ContextType>;
  UpdateTaxRulePayload?: UpdateTaxRulePayloadResolvers<ContextType>;
  UpdateTemplatePayload?: UpdateTemplatePayloadResolvers<ContextType>;
  UpdateThemePayload?: UpdateThemePayloadResolvers<ContextType>;
  UpdateTicketingPayload?: UpdateTicketingPayloadResolvers<ContextType>;
  UpdateTrainingPayload?: UpdateTrainingPayloadResolvers<ContextType>;
  UpdateTransactionPayload?: UpdateTransactionPayloadResolvers<ContextType>;
  UpdateUploadFilePayload?: UpdateUploadFilePayloadResolvers<ContextType>;
  UpdateUserPayload?: UpdateUserPayloadResolvers<ContextType>;
  UpdateVendorPayload?: UpdateVendorPayloadResolvers<ContextType>;
  UpdateVisitPayload?: UpdateVisitPayloadResolvers<ContextType>;
  UpdateWarehousePayload?: UpdateWarehousePayloadResolvers<ContextType>;
  UpdateWebhookPayload?: UpdateWebhookPayloadResolvers<ContextType>;
  UpdateWebsitePayload?: UpdateWebsitePayloadResolvers<ContextType>;
  UpdateWishlistPayload?: UpdateWishlistPayloadResolvers<ContextType>;
  UpdateWorkspacePayload?: UpdateWorkspacePayloadResolvers<ContextType>;
  UpdateZonePayload?: UpdateZonePayloadResolvers<ContextType>;
  DeleteAccountPayload?: DeleteAccountPayloadResolvers<ContextType>;
  DeleteAgreementPayload?: DeleteAgreementPayloadResolvers<ContextType>;
  DeleteAnalyticPayload?: DeleteAnalyticPayloadResolvers<ContextType>;
  DeleteApitokenPayload?: DeleteApitokenPayloadResolvers<ContextType>;
  DeleteArticlePayload?: DeleteArticlePayloadResolvers<ContextType>;
  DeleteAttributePayload?: DeleteAttributePayloadResolvers<ContextType>;
  DeleteBrandPayload?: DeleteBrandPayloadResolvers<ContextType>;
  DeleteCartPriceRulePayload?: DeleteCartPriceRulePayloadResolvers<ContextType>;
  DeleteCasePayload?: DeleteCasePayloadResolvers<ContextType>;
  DeleteCatalogPriceRulePayload?: DeleteCatalogPriceRulePayloadResolvers<ContextType>;
  DeleteCategoryPayload?: DeleteCategoryPayloadResolvers<ContextType>;
  DeleteChannelPayload?: DeleteChannelPayloadResolvers<ContextType>;
  DeleteChecklistPayload?: DeleteChecklistPayloadResolvers<ContextType>;
  DeleteCityPayload?: DeleteCityPayloadResolvers<ContextType>;
  DeleteCollectionPayload?: DeleteCollectionPayloadResolvers<ContextType>;
  DeleteCommentPayload?: DeleteCommentPayloadResolvers<ContextType>;
  DeleteContentTypePayload?: DeleteContentTypePayloadResolvers<ContextType>;
  DeleteContractPayload?: DeleteContractPayloadResolvers<ContextType>;
  DeleteCountryPayload?: DeleteCountryPayloadResolvers<ContextType>;
  DeleteCouponPayload?: DeleteCouponPayloadResolvers<ContextType>;
  DeleteCreditMemoPayload?: DeleteCreditMemoPayloadResolvers<ContextType>;
  DeleteCurrencyPayload?: DeleteCurrencyPayloadResolvers<ContextType>;
  DeleteCurrencyRatePayload?: DeleteCurrencyRatePayloadResolvers<ContextType>;
  DeleteCurrencySymbolPayload?: DeleteCurrencySymbolPayloadResolvers<ContextType>;
  DeleteCustomerGroupPayload?: DeleteCustomerGroupPayloadResolvers<ContextType>;
  DeleteCustomerPayload?: DeleteCustomerPayloadResolvers<ContextType>;
  DeleteCustomizationPayload?: DeleteCustomizationPayloadResolvers<ContextType>;
  DeleteDashboardPayload?: DeleteDashboardPayloadResolvers<ContextType>;
  DeleteDeepdivePayload?: DeleteDeepdivePayloadResolvers<ContextType>;
  DeleteDigiboardPayload?: DeleteDigiboardPayloadResolvers<ContextType>;
  DeleteEmailPayload?: DeleteEmailPayloadResolvers<ContextType>;
  DeleteEndofshiftPayload?: DeleteEndofshiftPayloadResolvers<ContextType>;
  DeleteEventPayload?: DeleteEventPayloadResolvers<ContextType>;
  DeleteFullfillmentPayload?: DeleteFullfillmentPayloadResolvers<ContextType>;
  DeleteGiftCertificatePayload?: DeleteGiftCertificatePayloadResolvers<ContextType>;
  DeleteGlossaryPayload?: DeleteGlossaryPayloadResolvers<ContextType>;
  DeleteImportmPayload?: DeleteImportmPayloadResolvers<ContextType>;
  DeleteIntegrationPayload?: DeleteIntegrationPayloadResolvers<ContextType>;
  DeleteInternalizationPayload?: DeleteInternalizationPayloadResolvers<ContextType>;
  DeleteInvitationPayload?: DeleteInvitationPayloadResolvers<ContextType>;
  DeleteInvoicePayload?: DeleteInvoicePayloadResolvers<ContextType>;
  DeleteLeadPayload?: DeleteLeadPayloadResolvers<ContextType>;
  DeleteManufacturerPayload?: DeleteManufacturerPayloadResolvers<ContextType>;
  DeleteMediamanagerPayload?: DeleteMediamanagerPayloadResolvers<ContextType>;
  DeleteMeetingPayload?: DeleteMeetingPayloadResolvers<ContextType>;
  DeleteMessagePayload?: DeleteMessagePayloadResolvers<ContextType>;
  DeleteNewsletterPayload?: DeleteNewsletterPayloadResolvers<ContextType>;
  DeleteOotoPayload?: DeleteOotoPayloadResolvers<ContextType>;
  DeleteOpportunityPayload?: DeleteOpportunityPayloadResolvers<ContextType>;
  DeleteOrderPayload?: DeleteOrderPayloadResolvers<ContextType>;
  DeletePagePayload?: DeletePagePayloadResolvers<ContextType>;
  DeletePartnerPayload?: DeletePartnerPayloadResolvers<ContextType>;
  DeletePaymentPayload?: DeletePaymentPayloadResolvers<ContextType>;
  DeletePermissionPayload?: DeletePermissionPayloadResolvers<ContextType>;
  DeletePluginPayload?: DeletePluginPayloadResolvers<ContextType>;
  DeletePollPayload?: DeletePollPayloadResolvers<ContextType>;
  DeleteProductTypePayload?: DeleteProductTypePayloadResolvers<ContextType>;
  DeleteProductPayload?: DeleteProductPayloadResolvers<ContextType>;
  DeleteProjectPayload?: DeleteProjectPayloadResolvers<ContextType>;
  DeleteProviderPayload?: DeleteProviderPayloadResolvers<ContextType>;
  DeleteQuotePayload?: DeleteQuotePayloadResolvers<ContextType>;
  DeleteRatingPayload?: DeleteRatingPayloadResolvers<ContextType>;
  DeleteReportPayload?: DeleteReportPayloadResolvers<ContextType>;
  DeleteReturnPayload?: DeleteReturnPayloadResolvers<ContextType>;
  DeleteReviewPayload?: DeleteReviewPayloadResolvers<ContextType>;
  DeleteRewardPayload?: DeleteRewardPayloadResolvers<ContextType>;
  DeleteRolePayload?: DeleteRolePayloadResolvers<ContextType>;
  DeleteSchedulerPayload?: DeleteSchedulerPayloadResolvers<ContextType>;
  DeleteSegmentPayload?: DeleteSegmentPayloadResolvers<ContextType>;
  DeleteSettingPayload?: DeleteSettingPayloadResolvers<ContextType>;
  DeleteShipmentPayload?: DeleteShipmentPayloadResolvers<ContextType>;
  DeleteSpecialDiscountPayload?: DeleteSpecialDiscountPayloadResolvers<ContextType>;
  DeleteStatePayload?: DeleteStatePayloadResolvers<ContextType>;
  DeleteStatisticPayload?: DeleteStatisticPayloadResolvers<ContextType>;
  DeleteStockPayload?: DeleteStockPayloadResolvers<ContextType>;
  DeleteSurveyPayload?: DeleteSurveyPayloadResolvers<ContextType>;
  DeleteTagPayload?: DeleteTagPayloadResolvers<ContextType>;
  DeleteTargetPayload?: DeleteTargetPayloadResolvers<ContextType>;
  DeleteTaxCategoryPayload?: DeleteTaxCategoryPayloadResolvers<ContextType>;
  DeleteTaxRatePayload?: DeleteTaxRatePayloadResolvers<ContextType>;
  DeleteTaxRulePayload?: DeleteTaxRulePayloadResolvers<ContextType>;
  DeleteTemplatePayload?: DeleteTemplatePayloadResolvers<ContextType>;
  DeleteThemePayload?: DeleteThemePayloadResolvers<ContextType>;
  DeleteTicketingPayload?: DeleteTicketingPayloadResolvers<ContextType>;
  DeleteTrainingPayload?: DeleteTrainingPayloadResolvers<ContextType>;
  DeleteTransactionPayload?: DeleteTransactionPayloadResolvers<ContextType>;
  DeleteUploadFilePayload?: DeleteUploadFilePayloadResolvers<ContextType>;
  DeleteUserPayload?: DeleteUserPayloadResolvers<ContextType>;
  DeleteVendorPayload?: DeleteVendorPayloadResolvers<ContextType>;
  DeleteVisitPayload?: DeleteVisitPayloadResolvers<ContextType>;
  DeleteWarehousePayload?: DeleteWarehousePayloadResolvers<ContextType>;
  DeleteWebhookPayload?: DeleteWebhookPayloadResolvers<ContextType>;
  DeleteWebsitePayload?: DeleteWebsitePayloadResolvers<ContextType>;
  DeleteWishlistPayload?: DeleteWishlistPayloadResolvers<ContextType>;
  DeleteWorkspacePayload?: DeleteWorkspacePayloadResolvers<ContextType>;
  DeleteZonePayload?: DeleteZonePayloadResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
}>;


export type MeshContext = MainDbTypes.Context & BaseMeshContext;


const baseDir = pathModule.join(typeof __dirname === 'string' ? __dirname : '/', '..');

const importFn: ImportFn = <T>(moduleId: string) => {
  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\').join('/').replace(baseDir + '/', '');
  switch(relativeModuleId) {
    case ".mesh/sources/MainDB/pgCache.json":
      return Promise.resolve(importedModule$0) as T;
    
    default:
      return Promise.reject(new Error(`Cannot find module '${relativeModuleId}'.`));
  }
};

const rootStore = new MeshStore('.mesh', new FsStoreStorageAdapter({
  cwd: baseDir,
  importFn,
  fileType: "ts",
}), {
  readonly: true,
  validate: false
});

export const rawServeConfig: YamlConfig.Config['serve'] = undefined as any
export async function getMeshOptions(): Promise<GetMeshOptions> {
const pubsub = new PubSub();
const sourcesStore = rootStore.child('sources');
const logger = new DefaultLogger("🕸️  Mesh");
const cache = new (MeshCache as any)({
      ...({} as any),
      importFn,
      store: rootStore.child('cache'),
      pubsub,
      logger,
    } as any)

const sources: MeshResolvedSource[] = [];
const transforms: MeshTransform[] = [];
const additionalEnvelopPlugins: MeshPlugin<any>[] = [];
const mainDbTransforms = [];
const additionalTypeDefs = [] as any[];
const mainDbHandler = new PostgraphileHandler({
              name: "MainDB",
              config: {"connectionString":"postgres://{env.DB_USER}:{env.DB_PASSWORD}@{env.DB_HOST}/{env.DB_USER}?schema={env.DB_SCHEMA}"},
              baseDir,
              cache,
              pubsub,
              store: sourcesStore.child("MainDB"),
              logger: logger.child("MainDB"),
              importFn,
            });
sources[0] = {
          name: 'MainDB',
          handler: mainDbHandler,
          transforms: mainDbTransforms
        }
const additionalResolvers = [] as any[]
const merger = new(BareMerger as any)({
        cache,
        pubsub,
        logger: logger.child('bareMerger'),
        store: rootStore.child('bareMerger')
      })

  return {
    sources,
    transforms,
    additionalTypeDefs,
    additionalResolvers,
    cache,
    pubsub,
    merger,
    logger,
    additionalEnvelopPlugins,
    get documents() {
      return [
      
    ];
    },
    fetchFn,
  };
}

export function createBuiltMeshHTTPHandler<TServerContext = {}>(): MeshHTTPHandler<TServerContext> {
  return createMeshHTTPHandler<TServerContext>({
    baseDir,
    getBuiltMesh: getBuiltMesh,
    rawServeConfig: undefined,
  })
}


let meshInstance$: Promise<MeshInstance> | undefined;

export function getBuiltMesh(): Promise<MeshInstance> {
  if (meshInstance$ == null) {
    meshInstance$ = getMeshOptions().then(meshOptions => getMesh(meshOptions)).then(mesh => {
      const id = mesh.pubsub.subscribe('destroy', () => {
        meshInstance$ = undefined;
        mesh.pubsub.unsubscribe(id);
      });
      return mesh;
    });
  }
  return meshInstance$;
}

export const execute: ExecuteMeshFn = (...args) => getBuiltMesh().then(({ execute }) => execute(...args));

export const subscribe: SubscribeMeshFn = (...args) => getBuiltMesh().then(({ subscribe }) => subscribe(...args));